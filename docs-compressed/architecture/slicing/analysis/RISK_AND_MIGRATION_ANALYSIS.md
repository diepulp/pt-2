PT-2 Risk Migration Strategy 2025-10-09 Decision risk migration 7/8 services 98 tests velocity 4x improvement

PT-2 implemented horizontal service interfaces dependencies context integrity aligns horizontal layering anti-patterns PT-1 implementation pragmatic hybrid solo developer velocity architectural consistency trajectory incremental tension slicing layering false PT-2 needs separation feature-complete user value LOW approach minimizes disruption leverages patterns

Current State Analysis Implemented Service 2 87.5% shared Horizontal infrastructure operation-wrapper error handling types ServiceResult contracts Shared utilities Domain-bounded service index PlayerService interface crud.ts CRUD operations module Session context Performance tracking-financial Financial ledger Venue management table-context Table lifecycle Compliance domain index.ts MTLService crud.ts Transaction CRUD queries CTR aggregation logic Explicit interfaces Typed dependencies Functional factories class-based services Bounded context integrity Consistent error handling Root-level test standardization 98 tests >80% coverage 4x velocity improvement Server Actions layer React Query hooks UI components Real-time subscriptions Established Patterns Module servicesexport interface MTLService CRUD operations create<ServiceResult getById Query operations getPendingCTRReports(...) Promise<ServiceResult export function createMTLService crudService queriesService separation CRUD business logic queries Explicit contracts prevent overwrites reusability without Testable Bounded Context RatingSlip Service interface average_bet Performance metric points Loyalty calculation NO financial fields

PlayerFinancial Service cash_in Financial ledger chips Money tracking performance metrics Domain separation prevents coupling Single responsibility service Aggregation client/action layer Referential integrity FKs object nesting Technical Debt Assessment-Risk Pattern duplication Template scaffolding generation consistency Validation schema redundancy Shared validation-specific rules isolation Critical Debt Zero class-based anti-patterns global singletons inference violations escapes direct calls

Risk Assessment Matrix 2.1 Vertical Slicing Risks Feature Directories Restructure services into feature-based directories Proposed vertical structure domains player create-player create.service update-player delete-player Likelihood Impact Severity Explanation **Duplication of CRUD Logic** slice reimplements DB access patterns Violates DRY shared operations Boundary Erosion** No clear "PlayerService contract each slice mini-service cross-domain composition unclear **Discoverability developers navigate nested slice directories **Testing Fragmentation** Tests per slice harder run tests **Migration Disruption** 7 services Casino High rework cost unproven benefitVelocity 4x velocity SERVICE_TEMPLATE.md invalidated new templates retrain patterns Vertical Slicing Recommended large 98 tests structure 7 services 2 days rework 14 days lost velocity developer Cognitive locality critical codebase Horizontal Layering Risks Continue service layer add Action/UI layers Horizontal service layer index contract crud module business Workflows queries Complex queries

/actions/player Action layer create-player-action update-player-action.ts UI hooks use-players.ts-create-player.ts **Risks** Likelihood Impact Severity Explanation **Layer Boundary Services call services ESLint rules code review-Engineering Temptation create BaseService abstractions PRD bans classes **Cross-Cutting Concerns** Logging validation error handling centralized `services/shared **Delayed UI Services without UI consumersPhase 3 prioritizes vertical completion files feature hook Code generation templates Horizontal Layering 7 services 98 tests zero PRD violations interfaces prevent coupling 4x improvement Add Action/UI layers rework Hybrid Approach Risks Vertical Delivery horizontal layers deliver features vertically Implementation sequence Service Layer.create Action Hook Query UI vertical slice DB Service Action Hook UI

Risk Likelihood Impact Severity Explanation \*\*Architectural exclusive clarifies hybrid model-Layer Action layer import wrong service methods Explicit service interfaces safety Strategy test layers or slices Pyramid (60% unit 30% integration 10% E2E defined features implement differently Template updates code review standards Hybrid Approach trade-off Technical clarity feature delivery solo Horizontal structure vertical progress tracking Extend patterns Next.js App Router follows model

Migration Path 3.1 Path A Trajectory horizontal service layer vertical delivery UI Week 1 Service Layer Completion Finalize MTL Service queries 2-3 Add search/query modules 7 services 4-5 Integration testing Phase 2 audit Week 2-3 Action Layer Player Visit RatingSlip cache strategy Week 4-5 UI Layer React Query Player UI Visit real-time integration RatingSlip end-to-end testing Week 6 Real-Time Infrastructure Enhancement wrapper Batch invalidation scheduler Domain real-time hooks Memory leak testing Zero rework 7 services template velocity (4x architectural consistency Incremental risk Solo developer friendly Clear progression Delayed UI value layer violations ESLint rules architecture tests 6 weeks vertical delivery UI 3.2 Path B Verticalservices directories Week 1-2 Architecture Redesign vertical directory structure templates slices Prototype feature Document patterns VERTICAL-SLICING

Week 3-6 Service Migration Migrate Player Visit PlayerFinancial Casino TableContext MTL Week 7-8 Test Migration Validation Migrate 98 tests new structure Re test coverage >80% Fix imports Update documentation Week 9-12 Action/UI Layers Path Implement actions hooks UI per slice Feature cohesion Easier delete features isolation weeks lost Invalidates 98 tests 4x template velocity gains evidence services large Duplication CRUD patterns Unclear service boundaries PlayerService contract developer loses structural clarity 12 weeks match functionality vertical delivery high cost unproven benefit Path C Strict Horizontal Layers Formalize 4-layer architecture strict boundaries Week 1: Layer Formalization Create LAYER_CONTRACTS.interfaces Implement Create cache invalidation ESLint rules layer violations 2-3 Service Layer Enhancement Add business queries transforms Refactor code boundaries 4-6 Action Layer 7-9 UI Layer 10 Testing Validation

clear layer responsibilities Easy enforce tooling Scales for multi-developer teams Predictable structure Potential over-engineering future Boilerplate overhead files per domain Rigidity experiment new Solo developer overkill 10 weeks complete formalization overhead good for team scale overkill solo Path D Hybrid Model (Recommended Horizontal technical layers vertical feature delivery cadence Week 1: Service Layer Finalization Week 2-3 Action Layer Vertical Slice Player domain actions UI Management feature Week 4-5 Tracking feature Week 6 RatingSlip Domain Creation feature Week 7 Real-Time Infrastructure Week 8 Integration Testing Production Hardening Technical clarity feature delivery Zero rework services Delivers features every 2 weeks horizontal consistency Pragmatic for solo developerLeverages template velocity (4x improvement Incremental risk Requires discipline mixing paradigms Documentation code review checklist confusion horizontal features 8 weeks vertical delivery real

builds delivers incrementally

Decision Criteria Analysis 4.1 Time to MVP Delivery Weeks First UI Feature Complete MVP **Path 4 6 weeks **Path 9 12 weeks 5 weeks 10 weeks **Path D** 3 weeks 8 weeks fastest first feature competitive MVP 4.2 Solo Developer Context Cognitive Load Onboarding Complexity Debugging Ease **Path B** MEDIUM LOW-MEDIUM A maintain structural clarity Developer No need advanced feature isolation person knows code Horizontal layers Vertical delivery tracks progress without nested directories Template velocity valuable extreme modularity 4.3 Maintainability Long-Term Evolution Refactorability Test Isolation Dependency ManagementMEDIUM **Path HIGH **Path D\*\* C long-term architecture Service contracts prevent coupling Clear layer boundaries ease refactoring Test coverage important location support >80% 4.4 Testing Quality Assurance

Path Test Migration Cost Coverage Maintenance E2E Complexity **Path NONE (0 days **Path HIGH (10 days C** LOW (2 days **Path D** NONE (0 days A/D** zero rework maintains 98/98 tests Pyramid paths support 60% unit 30% integration 10% E2E Horizontal layers mocking Vertical slices E2E test organization Hybrid benefits Onboarding Complexity Team Growth Documentation Burden Pattern Consistency Discoverability Winner MEDIUM **Path LOW MEDIUM **Path C\*\* predictable structure player creation Path A/player Path Bslices search C Same stricter contracts D vertical delivery

Pragmatic Recommendation Path D (Hybrid Model Working 7 services 98 tests zero PRD violations First UI feature 3 weeks Management additions no rework Developer Horizontal structure vertical progress tracking Velocity 4x improvement gains 8 weeks MVP 12 10 weeks C layers vertical Technical Layers Data Schema Service Business logic validation Action Server actions strategies UI Layer Components hooks Delivery Cadence Player Visit RatingSlip Phased Implementation Plan 2 7/8 services interfaces 98 tests >80% coverage context integrity Root-level test standardization MTL Service queries aggregation Search/query modules 7 services Integration testing Phase 2 audit 4-5 3: Action Layer Vertical Player Domain Vertical Slice Server actionsQuery Day 3-4 UI 5 E2E tests demo Working Player Management UI 3: Visit Domain Vertical 1-2 Server actions end cancel Query 4-5 UI 6 E2E tests demo

Visit Tracking UI 3: RatingSlip 5) Server actions React Query hooks 3-4 UI components 5 E2E tests demo Rating Slip Creation UI 4: Real-Time 6) Batch invalidation scheduler 3-4 real-time hooks 5 Memory leak testing multi-tab sync validation Real-time UI synchronization 5 Production Integration Testing Performance Cross-domain workflows RatingSlip Bundle analysis code splitting Lighthouse CI gates ≤2.5s ≤200ms RLS policy audit Deployment automation Production-ready MVP Rollback Strategies Mitigation Action service layer Revert Server Components Re-evaluate action wrapper patterns 2 days stabilize Commit layer separately Layer React Query Performance issuescomplexity SWR server actions Service unaffected Action 3 days migrate management Wrap React Query hooks-Time memory leaks leaks connection instability Disable real hooks polling Manual refresh Service layers unaffected 1 day add polling Real-time enhancement dependency

Path architecture flaw Service stable (7 services 98 tests Re-evaluate Action layer No rework 5 days redesign Service layer independence coupling Success Metrics 2 Completion 7/7 services 110+ tests coverage >80% Zero PRD violations Documentation 3 Delivery 3 slices Working UI E2E tests actions <500ms latency React Query cache >70% 4 Real-Time updates <1s latency Zero memory leaks Multi-tab synchronization Subscription lifecycle orphaned channels 5 Production LCP ≤2.5s TBT ≤200ms JS ≤250KB Zero security advisor warnings Deployment pipeline automated Health check endpoints Structured logging telemetry

Architectural Decision Justification Vertical Slicing services large PlayerService 1 file 1 CRUD module MTLService 2 modules Complexity manageable CRUD feature( violation Shared error handling harder 8 weeks rework 0 weeks addition 7 services 2 days 14 days lost 98 tests restructure-verification Template velocity gains invalidated slice operation Features complex Solo developer modularity load Cross-feature reuse rare CRUD Reconsider Vertical Service files 500 lines 5 modules service Team size >3 developers Feature independence Strict Horizontal Layers Solo developer formalization overhead Strict module boundaries overhead Documentation burden LAYER_CONTRACTSpremature optimistic updates layer model real-time formalize contracts Innovation compliance files future value requires business queries transforms Action wrapper modules UI separation 10-person team solo Layer contracts 5+ developers 1 developer knows layers Premature formalization maintenance debt

Reconsider Strict Team size >3 developers Onboarding>1 person/month Layer violations code review zero Technical debt ad-hoc patterns clean Hybrid D Optimal Service layer 7 services 98 tests zero violations Template velocity 4x improvement Bounded contexts Service Responsibility Matrix Add Action layer validate UI hooks real-time week optional enhancement addition rolled back independently progress Week 2: Management 4: Tracking 5 Slip Creation Stakeholder-friendly milestones layer 90% done developer Horizontal layers map Vertical delivery progress tracking motivation structure momentum Next.js App Router Rails Django Model Horizontal player logic services Business logic Server orchestration React Query wrappers UI Vertical create() methodserver action hooks React Query components Feature DB UI

Monitoring Adaptation Health Indicators Layer Test pass rate 100% coverage >80% PRD violations Service file size >500 Module count >5 Layer response time <500ms Cache hit rate >70% Error rate <1% over-invalidation Layer Query cache size memory leaks Component render count >10 Real message rate storm conditions Subscription cleanup orphaned channels Drift Service-to-service calls Layer violations type usage Global singletons Adaptation Triggers Service Complexity file >500 lines >5 modules Evaluate feature-based slicing 10 operations Team size >3 developers Formalize layer contracts Add ESLint rulesstricter reviews Cross-Domain >3 services user Introduce orchestration workflow module Visit Performance response >500ms UI load >3s Evaluate caching optimize queries code splitting real reduction Testing suite >10 minutes maintenance >20% dev time Re-evaluate testing add integration tests reduce duplication 60% 40%

Recommendation D Model Horizontal Layers Vertical Complete MTL Service queries Add search modules 7 services 2-3 Integration testing Phase 2 audit 4-5 Update SESSION_HANDOFF.md 2 Document hybrid model ARCHITECTURE_DECISION.md Implement Player actions hooks UI E2E tests demo Player Management Week 3: First UI 5 Second 6 Third Slip Creation 7 Real-time synchronization 8 Production-ready layer Service layer rework Template velocity (4x improvement Test coverage>80% Monitor service complexity lines Track team growth Measure performance Review quarterly 1.0 Architecture Team Approved Implementation End Phase 3 5)

Appendix A Risk Matrix Approach Overall Risk Time MVP Solo Dev Fit ROI Recommendation **Path Trajectory 6 weeks Vertical 12 weeks Not Recommended **Path Horizontal 10 weeks Team Growth Path **Path LOW 8 weeks **RECOMMENDED\*\*

Appendix B Decision Tree restructure architecture Evaluate Path B problematic Continue Path D team size >3 developers Add Path C Continue Path D MVP critical<8 weeks Path D REQUIRED Path C horizontal acceptable solo developer context Path D Path A optimal Re-evaluate team patterns PT-2 horizontal service layer build hybrid model D fastest time value architectural integrity velocity gains
