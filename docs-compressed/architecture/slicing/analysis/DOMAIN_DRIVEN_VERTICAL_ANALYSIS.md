Domain Slicing Analysis 2025-10-09 System Architect Analysis

analyzes PT-2 domain vertical slicing Service Responsibility Matrix Layer Architecture Vertical Slicing Philosophy recommends-level contexts feature-level slices Treat context Casino vertical slice database service action hook UI service module pattern

Vertical Slice Definition Boundaries Recommended Approach Domain-Level Vertical Slices Each context vertical slice features Aligns boundaries Service Responsibility Matrix Leverages service layer structure Matches patterns Reduces duplication Simplifies team ownership testing boundaries 1.2 Identified Vertical Slices PT-2 vertical Slice 1: Identity Context (Player) Database table identity contact loyalty Service `services/player/ Actions/actions/player-actions Hooks UI/players Total visits points Financial history None Slice 2: Location Context (Casino) gaming activity Database tables Service/casino/ management Actions/actions/casino-actionsHooks/casino UI/casinos management table configuration Active visits Table utilization metrics Rating slips None 3: Session Context (Visit player's session Database table-in/out mode status Service/visit management state transitions Actions Hooks/visit UI/visits-in session tracking check-out Rating slips Financial transactions Session duration activity metrics Player_id Casino_id Server actions Player Casino lookups Visit Performance Context (RatingSlip

Database table bet time points game Service metrics point calculations status transitions Actions/ratingslip Hooks UI/performance slip creation real tracking None entity performance ledger Player Visit Gaming Table Actions Visit validation Table availability RatingSlip Finance Context money Database_financial_transaction table/out chips reconciliation Service-financial transactions reconciliation net change ActionsHooks UI/finance log reconciliation None ledger Player Visit RatingSlip link RatingSlip performance financial tracking Vertical Slice User Journey Database schema migrations RLS policies security Service layer interfaces Server actions React Query hooks data UI components Unit integration E2E tests Player Visit Casino slice evolves Performance Finance slices Context Services reference domains ID calls Aggregation action layer cross communication contracts

Implementation Sequencing Strategy Dependency-Driven Delivery Order dependencies business value recommended implementation sequence Phase 1: Foundation Verticals Development Player Identity Casino Location 2-3 weeks No dependencies parallel Identity Database table Service implemented queries Create player-actions.ts operations list detail forms Location Database tables implemented management Create casino-actions.ts operations list floor view table configuration casino management create players manage casino settings tables tests >80% coverage Lighthouse performance budgets ≤ 2.5s 250KB Phase 2: Session Context Development Visit Session 2 weeks Requires Player Casino integration Phase 3 Session Database Service implemented CRUD management Create-actionscheck-in-out workflows casinoId Validates player casino creates Closes triggers cleanup(casinoId Cross-domain query dashboard Check-in form visits dashboard check-out workflow Cross-domain integration Casino calls PlayerService CasinoService.getById triggers queries Real updates tracking

User check player casino Active visits casino details closure updates changes Phase 3: Performance Finance RatingSlip PlayerFinancial Finance 3-4 weeks depend Visit business value Performance Database table UUID Service implemented point calculations Create ratingslip-actions Validates visit table Updates performance data Finalizes points triggers reconciliation useRatingSlip UI Rating slip creation performance tracker form Performance calculation cross integration Finance Database table PlayerFinancialService CRUD operations Business logic net change calculation Query operations summary transaction history financial-actionsvisitId Aggregates transactions Historical view useFinancialTransaction Transaction log reconciliation dashboard financial summary Reconciliation logic cross-domain integration Financial RatingSlip Financial reference Visit call summary links transactions performance track rating slips real calculations record financial transactions Visit closure aggregates performance financial No cross-domain service calls Rationale Sequencing Casino Foundation no dependencies service action hook UI pattern business value Parallel development velocity

cross-domain integration orchestration Performance Finance Validates subscription Critical PlayerFinancial complex business logic calculations reconciliation Benefits patterns Parallel development velocity business value compliance

Integration Patterns 3.1 Service Layer Integration Services call FORBIDDEN Service-to-service call RatingSlipService create visit await.getById return.insert coupling Violates context integrity testing Obscures transaction boundaries 3.2 Action Layer Orchestration Server actions orchestrate cross workflows Action orchestrates services createRatingSlipAction createClient Orchestrate domain services Validate cross-domain constraints visitResult await.getById not found tableResult await tableService.getById not found Create rating slip validation await ratingSlipService.create Invalidate caches revalidatePathreturn orchestration transaction boundaries Services Cache invalidation Data Flow Pattern

Client Layer (UI) Player List Visit Dashboard RatingSlip Tracker React Query Hooks Layer usePlayerList() fetches useActiveVisits() useRatingSlipsByTable() real updates Server Actions Layer) getPlayerListAction() PlayerService.list( getActiveVisitsAction(casinoId) VisitService.getActive( PlayerService.getById CasinoService createRatingSlipAction(data) VisitService.getById( TableService.getById() RatingSlipService.create() Service Layer (Domain Boundaries) Player Visit RatingSlip Service getById() getActive│ create() list() getByVisit│ Database Layer (RLS) player table visit table_id casino_id ratingslip table player_id visit_id table_id RLS policies enforce security Foreign keys enforce referential integrity 3.4 Cross-Domain Query Aggregation complete session summary visit Server Action Session summary export async function getSessionSummaryAction(visitId string supabase createClient Instantiate domain services visitService ratingSlipServiceRatingSlipService financialService casinoService fetch domains ratingSlips transactions await Promise visitService ratingSlipService financialService success false error 'Visit not found Fetch entities casino await Promise playerService casinoService

Aggregate action layer success data visit player casino performance totalPoints.points totalTimeSeconds.accumulated_seconds slips finance totalCashIn transactions.reduce tx.cash_in totalChipsOut transactions.chips_taken 0 transactions Aggregation logic action services Parallel fetches independent domains Sequential fetches dependent data Structured return clear domain sections 3.5 Real-Time Cross-Domain Updates Domain-specific hooks batched invalidations Real-time visit updates cross-domain cache invalidation export useVisitRealtime(visitId queryClient supabase createBrowserClient channel_changes event schema table filter `idBatch invalidations scheduler scheduleBatchInvalidation(queryClient-visit Cross-domain invalidation visitId.subscribe return.unsubscribe [visitId queryClient Domain-specific subscription Cross-domain cache invalidation service coupling Scheduler batches invalidations React Query storms Clean cleanup unmount

Cross-Cutting Concerns Shared Infrastructure Layers Cross-cutting concerns handled horizontal layers vertical Database Layer Cross-Cutting Supabase migrations RLS policies triggers RLS policies Audit logging triggers UUID generation Timestamp defaults Shared migration templates domain table Shared RLS policy template view records.uid player visit tables Service Layer Cross-Cutting/shared Operation wrapper ServiceResult type builders Error catalogues mapping Request ID generation Validation utilities functions imported domain services-wrapper async function executeOperation requestId await operation success true error null status 200 timestamp false Used domain servicesexport function createPlayerCrudService getById async string executeOperation.getById data error await supabase(('id.single return data Action Layer Cross-Cutting/actions/shared Auth validation Transaction boundaries Cache invalidation strategies Error response formatting Telemetry/logging Wrapper functions middleware app/actions/shared-auth export function withAuth StaffRole async supabase createClient data user error await supabase.auth.getUser success false error 'Unauthorized hasRole await checkUserRole success false error 'Forbidden

action(user domain action export createPlayerAction async playerData PlayerCreateInput supabase createClient playerService createPlayerService playerService.create Require supervisor role UI Layer Cross-Cutting `components/ui presentational primitives (Button Modal Input Card Layout components (PageHeader ContentWrapper Loading states Spinner Error boundaries Design system components NO business logic components/button presentational export function Button ButtonProps onClick domain-specific components-form.tsx Domain-specific export function PlayerForm createPlayer useCreatePlayer createPlayer Name Shared Domain-Specific Decision Matrix Shared Infrastructure Domain-Specific Location RLS Policy Templates/migrations/shared-policiessql Audit Logging Trigger `supabase/migrations/audit-trigger.sql Operation Wrapper/shared/operation-wrapper.ts ServiceResult Type/shared.ts Error Codes/player/errors.ts domain Validation Schemas/player/validation.ts domain Auth Wrapper/actions/shared/with-auth.ts Transaction Helper.ts Button Component `components/ui/button.tsx Player Form/player-form.tsx React Query Keys/player/query-keys.ts domain Real-time Hooks/visit.ts domain Zero domain knowledge utility 3+ domains **Domain-Specific** business rules domain terminology unique workflows Validation Strategy \*\*Shared Validation services/shared/validation-utilsexport function(value boolean return[0-9a-f]{8}{4}{12}.test(value);

export isValidEmail **Domain-Specific Validation services/player/validation import z from from/validation-utils export playerCreateSchema z email 'Invalid email format first_name last_name loyalty_tier export playerUpdateSchema playerCreateSchema.partial **Validation Action receives untyped input data JSON validates domain schema.safeParse valid passes DTO to service performs business rule validation duplicate email check Database enforces constraints

Team Structure Implications 5.1 Ownership Model-Level Each developer owns vertical slice Developer Vertical Slice Scope Dev A Player Identity Database service actions hooks UI tests Dev B Casino Location Dev C Visit Session Dev D RatingSlip Performance Dev E PlayerFinancial Finance UI **Cognitive understands feature stack evolve domain without handoffs Clear ownership for bugs feature requests No coordination intra-domain changes-Domain Requires collaboration full-stack competency Shared primitives require governance 5.2 Integration Contracts Service Interface Contracts domain owner PlayerService getById create update **Contract-service.contract.testdescribe Contract returns PlayerDTO fields service createPlayerService result await service.getById.success).toBe.data).toMatchObject id email first last_name DTO Type Contracts export interface PlayerDTO id email first last loyalty created updated PlayerCreateDTO email first last loyalty PlayerUpdateDTO extends<PlayerCreateDTO fails DTOs change shape without updating

Database Schema Contracts Foreign key constraints enforce referential integrity CREATE TABLE UUID KEY DEFAULT_random_uuid player_id casino_id check_in_date check_out_date status NOT NULL'ACTIVE 'COMPLETED 'CANCELLED Migration tests verify foreign key relationships 5.3 Testing Boundaries Unit Tests (Domain-Scoped) Domain developer Service layer modules.test player valid data result.create(result.success).toBe Integration Tests (Cross-Domain Orchestration layer Tech lead Server actions multi orchestration-actions.integration visit valid player casino Create player casino Create visit createVisitAction player_id casino_id.player visit invalid player async casino createTestCasino result createVisitAction player_id 'invalid casino_id not found End-to-End Tests Team lead Complete user workflows verticals-workflow Session Workflow check in create rating slip check out async Setup player createTestPlayer casino Act Check in visit.id casino'ACTIVE Create rating slip createRatingSlip visit_id table_id casino average_bet 25'ACTIVE Check out closedVisit checkOutPlayer'COMPLETED Session summary getSessionSummary.performanceCollaboration Patterns Standup Domain updates

Dev A Added search blocked UI B Table management integration C Player Casino contracts D slice Point calculation integrate Visit tomorrow Pull Request Workflow-Domain Add search Reviewers Tech-Domain integration check workflow Player Casino service B Reviewers Dev A Tech lead Integration Meetings Review service interface changes Coordinate action-layer orchestration Discuss infrastructure Plan E2E test scenarios Updated integration contract documentation

Trade-Offs Risks Domain-Level Feature-Level Slicing Domain-Level Visit RatingSlip-Off Domain-Level Feature-Level Low Shared modules High repeats patterns Medium Understand domain Focus single feature Moderate Test unit Narrow Developer owns Fragmented Features split devs High enforces patterns Low Feature drift governance Split >8 operations Infinite Add features limit domains cohesive service architecture domain-level Feature-level duplication context boundaries align domain-level slices Domains grow large Split domain core operations introduces sub-domainsPlayer split 6.2 Service Layer Composition Strategy Horizontal modules domain vertical-Off Horizontal Modules Vertical Share patterns domains Duplicate CRUD Test CRUD Business Query Test feature stack Understand module composition Linear feature flow Update CRUD pattern Update feature individually Learn module pattern Follow single feature path

CRUD/Business/Query separation reduces load Existing services use pattern Module composition straightforward Testing module granularity improves coverage Horizontal dependencies modules/shared utilities no domain logic 6.3 Cross-Domain Orchestration Location Server Actions-Off Action Layer Service-to-Service Event Bus High Explicit orchestration Hidden Medium Async event flow Action Service-scoped assertions coupled-driven decoupling Async event tracing Keeps services pure testable cross-domain knowledge Transaction boundaries explicit Follows client layer rule Service Responsibility Matrix Simpler than event-driven architecture Action layer becomes orchestration Keep actions focused workflow integration tests 6.4 Migration Strategy Big-bang verticalAspect Vertical Big-Bang Horizontal Layers Early Working features Late No Medium Wrong patterns Low layer Fast Incremental Slow All-or-nothing Low Independent development High Handoffs layers Medium Fix early slices Low Fix before implementation

Delivers features Validates service action hook UI feedback before Reduces coordination overhead patterns architecture review update templates 2 Real-Time Update Strategy Domain-specific hooks batched invalidations-Off Domain Hooks Global Manager Low Hook subscriptions High Singleton state management Mock channel hook global Good Batched invalidations Poor React Query storms Manager lifecycle forbids global real-time managers Domain hooks slice independence Batched invalidations prevent React Query storms Clean cleanup semantics Duplicate channel subscription logic Shared helper domain-specific hooks

Code Organization Directory

/diepulp/pt-2/ supabase migrations Forward-only migrations 20250828_init_corrected.sql 20251007_rls_policies.sql 20251008_player_financial.sql.toml types database.types.ts Canonical source domains Domain DTOs player.dto-filters.dto casino visit ratingslip financial services shared Cross-cutting infrastructure operation-wrapper types ServiceResult ServiceError validation-utils error-mapping player Identity vertical layer index.ts Factory interface export crud.ts module business.ts Business logic module queries transforms.ts DTO mapping validation.ts Zod schemas errorsDomain error codes casino/ Casino Location vertical (service layer structure visit Session vertical structure ratingslip Performance vertical layer structure player-financial/ PlayerFinancial Finance vertical layer structure app actions Server actions shared with-auth.ts-transaction.ts invalidation-helpers.ts player-actions.ts domain actions casino-actions.ts actions visit-actions.ts ratingslip-actions.ts actions financial-actions.ts actions session-actions.ts Cross-domain workflows players Player Identity vertical (UI layer) page.tsx Player list page [id] page.tsx Player detail page player-list.tsx List component player-detail.tsx player-form.tsx Create/edit form player-search.tsx Search component casinos/ Casino Location vertical (UI layer) [similar structure visits/ Visit Session vertical layer check-in.tsx active-visits-dashboard.tsx check-out.tsx performance RatingSlip vertical layer rating-slip-tracker.tsx create-slip-form.tsx close-slip-form.tsx finance PlayerFinancial Finance vertical layer transaction-log.tsx reconciliation-dashboard.tsx financial-summary.tsx layout.tsx hooks React hooks-scoped shared use-supabase-channel.ts-batch-invalidation.ts player vertical hooks query-keys.ts usePlayer.ts usePlayerList.ts usePlayerMutations.ts casino vertical hooks visit vertical hooks useVisit.ts useActiveVisits.ts useVisitLifecycle useVisitRealtime.ts ratingslip hooks useRatingSlip.ts useActiveSlipsByTable useRatingSlipRealtime.ts financial vertical hooks useFinancialTransaction.ts useVisitReconciliation.ts usePlayerFinancialHistory.ts components ui Shared presentational primitives button.tsx modal.tsx input.tsx card.tsx skeleton.services Service unit tests domain player crud.test business.test queries.test casino visit ratingslip player-financial actions Action integration tests-domain player-actions.integration.test visit-actions session-actions hooks Hook tests domain player visit ratingslip contracts Contract tests interfaces player-service.contract.test casino-service.contract visit-service.contract e2e End-to-end tests player-management.e2e.test session-workflow performance-tracking

7.2 Structure Rationale domain casino `services logic/actions Orchestration server actions `hooks React Query hooks real-time subscriptions UI components pages Domain-specific tests `services/shared service utilities/actions Auth transaction invalidation wrappers `hooks hook utilities `components/ui Presentational primitives `types/ Canonical types DTOs Clear vertical boundaries Shared infrastructure Testing mirrors developers navigate domain Anti-Patterns `services/player/types No class abstractions functional factories shared utilities/real-time/global-manager No managers Domain-specific hooks cleanup-all-players Breaks domain locality/actions Violates domain separationdomain/player-button.tsx Business logic UI `components/ui/button.tsx/players-form.tsx Cross-service imports coupling actions orchestration

Success Metrics Phase Completion Criteria Phase 1: Foundation Verticals Casino Player CRUD business queries modules Casino table management Explicit interfaces operations return<T-actions CRUD-actions table operations Auth wrappers access Cache invalidation React Query Player Casino Player list forms Casino list floor view table configuration Loading error boundaries validation feedback Service unit tests >80% Action integration tests CRUD Hook tests E2E tests casino Lighthouse LCP ≤ 2.5s Total Blocking Time 200ms Initial JS bundle 250KB Phase 2: Session Context Visit lifecycle management State transition validation RPC functions complex queries-actionscheck-in-out Cross-domain Casino validation Transaction boundaries batched invalidations Cross-domain cache invalidation Check-in form Player Casino Active visits real updates Check-out session summary Cross-domain integration Casino Real-time subscription tests visit lifecycle Phase 3: Performance Finance PlayerFinancial

RatingSlip point calculations PlayerFinancial reconciliation patterns-actions create operations-actions transaction recording-actions performance finance data useRatingSlip Real-time hooks domains Rating slip tracker updates Financial transaction log Reconciliation dashboard Session summary Performance calculation Reconciliation logic Cross-domain integration tests E2E session workflow Zero `any types parameters inference DTOs.types No direct calls global state services stateless functional Service layer >80% Action layer >70% Hook layer >60% E2E critical paths Lighthouse scores Performance >90 Accessibility >95 Bundle size Initial <250KB per-route <100KB API latency <500ms <1s aggregations ESLint Zero violations TypeScript Zero errors <5% duplication

Migration Playbook Phase 1: Foundation Verticals (Week 1-3 Week 1: Player Identity Vertical 1-2 Action Create player actions file-actions Implement CRUD actions Add auth wrappers cache invalidation 3-4 Hook Create player hooks directory Implement hooks/query-keys 5 UI Create player UI directory/players Implement pages components/page page page-list-form Create/edit form 6-7 Action integration tests/player-actions.integration.test Hook tests/usePlayer.test E2E tests-management.test Week 2: Casino Location Vertical pattern Day 1-2/actions/casino-actionsDay 3-4 5 6-7 Week 3: Phase 1 Review Refinement 1-3 Architecture service action hook UI improvements Phase 2 Update templates documentation 4-5 Performance Bundle analysis Lighthouse audit React Query optimization 6-7 Integration Cross-domain contract tests E2E paths Real-time subscription tests Phase 2: Session Context 4-5 Week 4: Visit Vertical Implementation 1-2 Action Layer Cross-Domain app startVisitAction player casino_id createClient Orchestrate Player Casino Visit services Validate player Validate casino

Create visit return visitService.create 3-4 Hook Layer Real export useVisitRealtime(visitId string queryClient useQueryClient useEffect channel createBrowserClient({visitId'postgres_changes table 'visit filter `id{visitId scheduleBatchInvalidation(queryClient'visit visitId-visit.subscribe channel.unsubscribe [visitId queryClient 5 UI Implement check-in/check-out workflow app 6-7 Integration-actions.integration.test'Cross-Domain Visit Workflow Player Casino creating Visit player createTestPlayer casino result startVisitAction player_id casino_id expect(result.Phase 3: Performance Finance 6-9 Week 6-7 RatingSlip Performance Vertical Track 1-2/actions/ratingslip Table validation 3-4/ratingslip calculation 5/performance UI 6-7 Testing calculations cross integration Week 6-7 PlayerFinancial Finance Vertical Track 1-2 `services/player-financial reconciliation logic 3-4/actions/financial-actions recording 5/financial hooks 6-7 Testing financial calculations Week 8 Cross-Domain Session Summary RatingSlip app/actions-actions getSessionSummaryAction createClient player casino Week 9 Phase 3 Final Testing Documentation 1-3 E2E Complete Session-session-workflowcheck record transaction out workflow test 4-5 Performance Bundle analysis subscription React Query cache tuning

6-7 vertical slicing cross-domain team onboarding

Conclusion Recommendations Slice-Level Player Casino Visit RatingSlip spans database service action hook UI horizontal modules 1 (3 weeks Player Casino 2 Visit cross 3 (4 weeks RatingSlip PlayerFinancial service-to-layer Cross-domain workflows Type-safe cross-domain communication-time Domain-specific hooks batched invalidations-Cutting Validation schemas error business logic utilities domain logic Success Factors service interfaces Type-safe Supabase clients Comprehensive testing service action hook E2E levels Clear domain ownership developer vertical Contract-based integration Weekly sync meetings Architecture review Phase 1 Vertical delivery Early validation Parallel development velocity Continuous testing10.3 Steps Review Present analysis gather feedback Update_TEMPLATE.md vertical slice patterns 1 Assign Player Casino verticals Set Lighthouse CI analysis test coverage tracking onboarding guide vertical slice development 10.4 Questions 2-3 developers Phase 1 Design establish design primitives before implementation-Time domains updates E2E Cypress Playwright Cypress phase production

Appendix A References **Service/diepulp/projects/pt-2/docs/phase-2/SERVICE_RESPONSIBILITY Layer-prd_LAYER_ARCHITECTURE_DIAGRAM **Canonical Blueprint **Vertical Slicing_SLICING_PHILOSOPHY **Service/SERVICE_TEMPLATE.md

Appendix B pattern ownership boundaries domain Player Identity Visit Session feature path database to UI user functionality-Level context Visit RatingSlip features Internal service organization separation concerns Layer Server actions services cross-domain workflows Visit Player Casino Standardized return type success/error handling status codes request tracing Transfer Object Type-safe contract cross-domain communication communication vertical slices Analysis Complete team review approval Post-Phase 1 retrospective 3 weeks start
