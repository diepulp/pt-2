Layering Analysis PT-2 2025-10-09 Recommendation layer structure sequencing-layer communication Casino Tracker

Adopt-up-driven vertical PT-2 service pattern aligns layering formalizes boundaries sequencing cross-layer communication reusability integrity Implement-complete vertical domain balances architectural consistency rapid delivery over-engineering PT-1 90/100 PT-2 targets 95/100 anti-patterns layer contracts

Layer Definition Responsibilities Four-Layer Architecture UI LAYER React Components Hooks State Real-time Sync Rendering interaction updates Server Actions ACTION LAYER Actions Orchestration Cache Authorization Coordination invalidation auth checks Service Factories SERVICE LAYER Queries Transforms Validation Domain logic DTOs error handling Supabase Client DATA LAYER PostgreSQL RLS Policies Triggers Real-time Schema enforcement persistence security top-down Action Service DataResponsibility Matrix Files Schema enforcement persistence security Schema definitions RLS policies Database triggers Type generation Connection management logic Validation DTO transformation API contracts Business logic operations data transformation Domain DTOs Business rules CRUD operations Schema validation Error handling ServiceResult contracts HTTP routing Cache UI Database schema Client instantiation Server-side orchestration cache management Authorization checks-level logging Input sanitization logic Database access UI rendering Real-time subscriptionsRendering user interaction client state Component composition UI state React Query User input Optimistic updates Real-time UI sync Server actions Business logic Database access Validation-list Cross-Layer Communication Rules-Down UI Action React Query Service Data Layer Supabase client

Dependencies** Service Layer → Action Layer call actions UI Layer import React/UI Data Service circular dependencies UI Layer Service through Action direct Supabase client → React Query mutations calling server actions-create-player import useMutation/react-query createPlayerAction export useCreatePlayer( return useMutation queryClient.invalidateQueries( **Action → Dependency injection via factory/actions/player/create-player-action async createPlayerAction supabase await createServerClient playerService createPlayerService playerService.create → database access services/player export createPlayerCrudService async supabase.insert.select.single

Cross-Cutting Concerns Layer 2.1 Validation Strategy (Multi-Layer Defense Validate boundary security UX Layer Validation Type Tool Schema PostgreSQL CHECK Business rules Zod schemas `playerCreateSchema.parse(data Input sanitization Zod custom validators `sanitizeInput(actionInput UX validation React Hook Form Zod zodResolver Player Email Validation Across Data Layer supabase/migrations_create_player.sql TABLE player Service Layer services/player/validation export playerCreateSchema.object firstName lastName Action Layer app/actions/player/create-player-actionexport async createPlayerAction sanitized sanitizeInput server checks createServerClient playerService.create UI Layer components/player-form defaultValues email lastName Database prevents corrupt data Service enforces rules Action adds security checks UI user feedback Error Handling Strategy Transform errors layers Error PostgreSQL Code 23505 Map domain Error DUPLICATE_EMAIL Return ServiceResult Transform user-friendly Error exists Error Transformation Data Layer PostgreSQL violation 23505) Service Layer domain error/player.code 'DUPLICATE_EMAIL player email exists ServiceResult return data null error 'DUPLICATE_EMAIL success false status 400

Action Layer logging app/actions-action playerService.create.warn creation failed return result UI Layer User-friendly display components/player-form useCreatePlayer 'DUPLICATE_EMAIL email registered.setError exists Catalog services/player PlayerServiceError DUPLICATE_EMAIL NOT_FOUND VALIDATION_FAILED UNAUTHORIZED PostgreSQL errors domain errors ERROR_MAP PlayerServiceError '23505 PlayerServiceError.DUPLICATE_EMAIL '23503 PlayerServiceErrorNOT_FOUND 2.3 Data Transformation Strategy Transform data shape layer boundaries Transformation Layer Tool Row `PlayerDTO `toPlayerDTO() View `PlayerDTO() Input Action `CreatePlayerInput `parseFormData() Service `CreatePlayerInput `PlayerCreateDTO Direct mapping Player Data Transformation Data Layer database row PlayerRow Database id email firstName lastName metadata Service Layer Domain DTO services/player/transforms.ts export PlayerDTO export toPlayerDTO id email firstName lastName 3. Action Layer response/actions/player/create-player-action CreatePlayerResult PlayerDTO error ServiceError success boolean UI Layer View model display-player-view-modelexport interface PlayerViewModel id fullName Computed lastName emailDisplay Formatted display export function return id fullName emailDisplay.email.toLowerCase

Implementation Sequencing Strategy Recommended Approach-Up Vertical Data layer schema stability before services layer Higher layers depend lower layers vertical slices deliver features \*\*Sequencing Phase 1: Data Layer (1 Write migration Generate types Test schema Verify RLS Deploy remote Service Layer (2 days CRUD Business Queries Transforms Validation Unit tests Integration tests Code review commit Action Layer (1 Server actions Cache strategies Authorization middleware integration tests UI Layer (2 React Query Components Forms validation Real-time integration E2E tests Commit demo 6 days per domain-complete vertical slice Day 1: Data Layer supabase migration create Edit supabase npm gen:types commit data layer migration types Day 2-3Service Layer Create index crud business queries transforms validation npm test commit implementation Day Action Layer mkdir/actions Create update npm test commit cache strategies

Day 5-6 UI Layer mkdir hooks components hooks components forms real-time sync commit UI layer E2E tests 3.2 Alternative Approaches Recommended PT-2) UI layer no data services High rework risk Difficult test Prototyping UI fake data Validating user workflows Exploratory design sessions-Out-First Service Layer (2 Define DTOs operations Data Layer Implement schema DTOs Action Layer Wire services server actions UI Layer (2 days Build stable contracts Schema unstable API contracts Domain modeling iteration DTOs database over-engineering Rework middle schema-defined PRD migrations 3.3 PT-2 Current Status 2 Assessment Domain Data Service Action UI Layer(CRUD only) 50% RatingSlip (CRUD only 50% PlayerFinancial (CRUD only) 50% Casino (CRUD only) 50% TableContext (CRUD + Settings) 50% MTL (CRUD + Queries) 50%

Complete Service Layer Queries Transforms Validation domains Implement Action Layer MVP UI Layer Management integration hooks domain

Shared Infrastructure Reusability Horizontal Reusability Matrix Reusable Across Domains Example **Operation Wrapper** Single shared implementation/shared/operation-wrapper.ts **ServiceResult Single type definition/shared/types.ts **Error Shared wrapper function/shared/operation-wrapper.ts **Validation Shared Reusable Zod patterns `services/\*/validation.ts **DTO Domain-specific Unique domain//transforms.ts **Supabase Singleton factories/supabase/client **React Query Global config `lib/query-client.ts Action Wrapper** Shared wrapper `lib-server-action-wrapper.ts \*_Cache Shared patterns Domain-specific invalidation/actions/_/invalidation-helpersreusable shared implementation Pattern reusable domain-specific instances-specific not reusable 4.2 Shared Infrastructure Implementation Universal error handling services/shared/operation-wrapper.ts export async function executeOperation string Promise<ServiceResult requestId generateRequestId operation error null success true status 200 timestamp requestId handleServiceError SHARED Standard result contract services/shared export ServiceResult<T data error success status timestamp requestId ServiceError code message details unknown DOMAIN-SPECIFIC Reusable pattern services/player/validation.ts playerCreateSchema email firstName lastName services/casino/validation.ts casinoCreateSchema name address city

DOMAIN-SPECIFIC Not reusable services/transforms export id email firstName 4.3 DRY Principles Trade-offs DRY Shared infrastructure Common patterns error handling Cross-cutting concerns telemetry caching Premature Abstraction Domain-specific transformations-fitting Business rules unrelated domains Validation logic of abstract after 3 similar implementations Good Shared validation pattern export createEntitySchema playerSchema email firstName casinoSchema name address Bad Over-abstraction share GenericEntityDTO id data metadata unknown PlayerDTO CasinoDTO shape breaks domain autonomy

Testing Strategy Layer Testing Pyramid PT-2 E2E Tests workflows 10% tests Integration Tests Service Database 30% Action orchestration 10% Unit Tests RTL Service logic 40% UI components 10% Unit Service UI components Transforms/Validation (10%) Integration Service DB Actions E2E (10%) Layer-Specific Testing Approaches Type Boundaries Tools Location Schema Tests Constraints RLS Triggers Migrations SQL scripts Supabase CLI Unit Tests CRUD Business logic Transforms Errors Supabase Integration Tests DB queries Transactions RLS Integration Tests Service orchestration Cache Auth/actions Unit Tests Rendering Interactions State Mock React Query actions RTL/components E2E Tests User flows Real-time Forms app test DB Cypress/e2e 5.3 Mock Boundaries Layer SERVICE LAYER UNIT Mock Supabase/services/player-service.test mockSupabase mockPlayer error null SupabaseClient playerService result await playerService.getById

SERVICE LAYER INTEGRATION Real DB/services/player.integration.test supabase createClient_TEST_URL_KEY playerService createPlayerService result await playerService.create email firstName lastName Verify data database await supabase result.data(rows.data).toHaveLength(1) ACTION LAYER Mock Services/actions/player/create-player-action.test createPlayerService success true error null result await createPlayerAction.success).toBe 4. UI LAYER TESTS Mock Actions React Query/components/player-form.test createPlayerActionsuccess mockPlayer Test UI interactions server Test Coverage Targets Critical Paths Migrations 100% constraints policies triggers CRUD 90% errors validation 85% Workflows transitions concurrency Queries 80% Complex joins filters Transforms 100% mappings Validation 100% schema constraints Server Actions 80% Orchestration cache auth Components 70% User interactions conditional rendering Flows 100% CRUD session lifecycle compliance fails below targets

Real-Time Subscription Strategy Layer Placement Decision Real-time subscriptions NOT Service Layer Real-time UI concern remote changes Subscriptions require React lifecycle/unmount cleanup Service layer pure stateless Services manage WebSocket connections global state-Pattern PT-1 Global real-time manager service layer RealtimeManager connections RealtimeChannel void Global state singleton pattern breaks service purity Violates stateless service principle Pattern Domain-specific hook UI layer-players-realtime usePlayersRealtime queryClient channel Batch invalidation scheduler scheduleInvalidation.invalidateQueries Cleanup unmountunsubscribe [queryClient 6.2 Real-Time Integration Flow A Create Player INSERT Trigger Real-time Broadcast B usePlayersRealtime Hook Batch Invalidation Query Refetch B Re-render new player UI Component uses real-time hook components/player-list export PlayerList( usePlayers Subscribe changes.map Real-time hook manages subscription lifecycle-realtime usePlayersRealtime( queryClient channel createBrowserClient-changes Debounce changes scheduleInvalidation( queryClient.invalidateQueries(.subscribe channel.unsubscribe Scheduler prevents invalidation/invalidation-scheduler invalidationTimeout NodeJS.Timeout scheduleInvalidation void delay 300 clearTimeout setTimeout(callback

Practical Implementation Guidance Feature Workflow Management Implement Player Management feature real-time Day 1: Data Layer supabase migration create_player Edit migration file_player.sql CREATE TABLE player id UUID_random_uuid email created updated RLS policies ALTER TABLE ENABLE ROW LEVEL SECURITY CREATE POLICY viewable authenticated users authenticated Audit trigger CREATE player_audit_trigger INSERT UPDATE DELETE log_audit_event supabase db push npm gen commit data layer RLS policies Day 1-2 Service Layer services/player Create service modules interface operations workflows filters mapping schemas Create tests-service.test/services/player/crud.test.integration.test npm test/services/player tests passing git add commit -m service layer + tests Day 3: Action Layer (Morning) mkdir -p app/actions/player Create server actions/create-action-action Create tests/create-player.test.ts npm test/actions/player tests passing git add commit -m(player): action layer + cache strategies Day 3-4 UI Layer -p hooks/player components app/players Create hooks-players-create-delete-player-realtime Create components/player-list.tsx-form-card

Create page app/players tests-list.test-form cypress/e2e/player-management.cy npm test run cypress-management tests passing commit UI layer E2E tests Day 4: Integration Demo npm run dev http://localhost:3000/players Manual testing Create Update Delete Real-time sync RLS policies npm test Service layer 92% Action layer 85% UI layer 73% git tag player-management-v1.0 Player Management feature push Cross-Layer Communication Examples Creating Player Step UI Layer User submits form components/player-form.tsx useCreatePlayer Step UI Hook React Query mutation-create-playerexport function useCreatePlayer queryClient useMutation createPlayerAction queryClient.invalidateQueries created'Failed create player Step 3: Action Layer Server action-player-action export async function createPlayerAction<CreatePlayerResult supabase await createServerClient playerService result playerService.create email firstName lastName.success revalidatePath/players data result error success

Step 4: Service Layer Business logic services/player/crud.ts export createPlayerCrudService async PlayerCreateDTO executeOperation<PlayerDTO await supabase email firstName email Map database errors domain errors.code 'DUPLICATE_EMAIL player email exists error return toPlayerDTO Step 5 Data Layer PostgreSQL execution RLS policy authenticated users only Constraint check email unique format audit log entry INSERT successful returned Error Handling Across PostgreSQL constraint violation ERROR duplicate key value violates constraint_email_key exists CODE 23505 Layer Map domain error services/player/crud.ts'DUPLICATE_EMAIL player exists details email data postgres error executeOperation transforms data null error 'DUPLICATE_EMAIL player exists@example success false status 400 timestamp '2025-10-09T12:34:56.789Z requestId_abc123 Action Layer Pass logging/actions/create-player result await playerService.create.warn creation failed error result requestId email Don't log PII details return result UI Layer User display-create-player ServiceError 'DUPLICATE_EMAIL email registered different email.setError exists create player try again

Trade-offs Risk Assessment Architecture Trade-offs Advantages Disadvantages Mitigation-Up Stable foundation Testable layers Clear dependencies Low rework UI over-engineering Slower visibility Vertical slicing Schema reviews demos Layer Clean architecture Maintainable Isolated testing Slower Learning curve Code templates documentation-Layer UX feedback Security Duplicate validation Maintenance burden sync Shared schemas Single source Automated tests Consistent errors Type-safe responses Trackable requests Verbose return types overhead Non-standard pattern Helper functions Type inference utilities Team training Risk Matrix Mitigation 3rd use casereview shared code → Service Low ESLint rules review checklist architecture tests Medium Enforce orchestration Action layer anti-pattern ADRs Medium Shared executeOperation wrapper ServiceResult catalog domain Focus critical paths distribution boundaries-time sync Medium Scheduler pattern batching invalidation tests Automated type regeneration validation-only schema changes Medium Layer caching strategies budgets CI gates

Critical mitigation Medium Monitor Low Accept risk document decision

Success Metrics Governance Architecture Quality Indicators Target Measurement Frequency **Layer Boundary 0 manual code review Coverage >80% Layer >90% <60s CI pipeline metrics 100% TypeScript compiler **ServiceResult 100% methods Code review checklist Policy 100% tables Manual schema audit Development Velocity Indicators Target Frequency Domain 6 days Sprint velocity tracking Module >50% shared infrastructure Code analysis Execution <5min <15min **Developer Onboarding <4 hours first PR feedback Review <24 hours GitHub metrics **Bug Escape <5% to production Issue tracking Monthly 9.3 Governance Review Process Decision Records deviation requires ADR/architectureProblem Decision Consequences Alternatives Review Migration naming convention RLS policies tables Audit triggers sensitive tables Types regenerated Schema constraints

interface ReturnType supabase parameter methods return ServiceResult Error codes domain catalog Unit tests >90% Integration tests paths Server action directive Service orchestration business logic Cache invalidation Authorization checks tests No Supabase client React Query hooks data fetching Real-time hooks Components accept typed props E2E tests flows

Recommendations Steps Immediate Actions 1) Formalize Create_CONTRACTSinterfaces Document DTO transformation patterns Establish ServiceResult error code catalog domain Implement consistency Complete Service Casino Service Queries TableContext MTL Player Visit RatingSlip PlayerFinancial 3: Shared validation schema Create cache invalidation helpers Implement real scheduler pattern Medium-Term Actions (Weeks 2-4 4: Complete First Vertical Slice Player Actions CRUD server UI forms E2E tests Real-time Multi-tab sync 5 Expand Critical MVP Visit Management Actions UI E2E (4 Rating Slip Casino Configuration Actions E2E (4 6 Testing integration test database pipeline Create test data factories domain Implement Cypress E2E suite critical flows Add performance regression tests Long-Term Actions (Month 2+) 7 HorizonExtract query patterns utilities Build DTO library Create workflow templates bundle sizes

8 updates low-latency Add offline-first capabilities cross-domain aggregations Performance monitoring alerting 9 Documentation layer coding standards layer violation detection tools architecture review process onboarding guides

Recommendations Horizontal Vertical Data-time Service Business validation error Action Orchestration authorization UI sync Bottom-up stability Vertical slicing rapid 6-day cadence modules reusability domain logic Balance DRY domain-specific 3rd use case abstracting 60% unit tests 30% integration tests 10% E2E tests >80% coverage-Time UI-layer hooks Batch invalidations subscription lifecycle Domain-specific real-time hooks Success Criteria Zero layer boundary violations >80% test coverage 100% ServiceResult consistency RLS policy <60s build time 6-day vertical slice cadence >50% shared infrastructure reusability <4 hour developer onboarding <24 hour PR review <5% bug escape rate LCP 2.5s TBT 200ms Initial JS 250KB Migration7 domain services CRUD modules Business Queries Transforms Validation incomplete action UI

Week Complete Service Layer Add Business Queries Transforms Validation >90% service test coverage Week 2-3 Vertical Slice Management Actions UI E2E Demo stakeholders 4-6 Expand Vertical Slices Visit Management Rating Slip Creation Casino Configuration Week 7-8 Real-time Integration Invalidation scheduler Multi-tab sync Week 9 Domains Optimization TableContext MTL slice Performance optimization Production hardening 1.0 2025-10-09 Architecture Team Recommended Adoption 2025-10-23_BLUEPRINT_MVP_LAYER_RESPONSIBILITY_BASED_HORIZONTAL_LAYERING_ANALYSIS

Appendix A Example Domain A.1 Data Layer supabase/migrations_create_player CREATE TABLE player id UUID DEFAULT gen_random_uuid email NOT NULL "firstName NOT NULL "lastName NULL created updated ALTER TABLE player ENABLE ROW LEVEL SECURITY CREATE POLICY "Players viewable authenticated users POLICY "Players modifiable by staff.jwt Audit trigger CREATE TRIGGER player_audit_trigger UPDATE DELETE player ROW Updated timestamp trigger CREATE TRIGGER player_updated_trigger UPDATE A.2 Service Layer services/player/index.ts import SupabaseClient-js Database/types createPlayerCrudService createPlayerBusinessServiceimport createPlayerQueriesService from PlayerDTO PlayerCreateDTO PlayerUpdateDTO/transforms ServiceResult/shared/types export interface PlayerService getById Promise<ServiceResult create update delete activate Promise<ServiceResult deactivate<PlayerDTO>> searchPlayers Promise<ServiceResult<PlayerDTO getPlayerStats Promise<ServiceResult<PlayerStatsDTO>> export createPlayerService businessService queriesService createPlayerQueriesService return ...crudService ...queriesService export type PlayerDTO PlayerCreateDTO PlayerUpdateDTO Action Layer/actions/player/create-player-actionserver import createServerClient createPlayerService/services/player revalidatePath/cache PlayerCreateDTO PlayerDTO/services/player ServiceResult/shared/types export async createPlayerAction PlayerCreateDTO<ServiceResult supabase createServerClient playerService result await playerService.create revalidatePath/players return result

A.4 UI Layer hooks/player-create-player import useMutation useQueryClient@tanstack/react-query createPlayerAction/actions/player toast PlayerCreateDTO/services/player export useCreatePlayer() queryClient useQueryClient return useMutation createPlayerAction onSuccess (result queryClient.invalidateQueries queryKey'players.success created message result.error_EMAIL registered 'Failed create player toast.error onError'Failed create player try again components/player/player-form.tsx export function PlayerForm() mutate useCreatePlayer form resolver defaultValues email firstName lastName onSubmit PlayerCreateDTO mutate onSubmit.handleSubmit Player **End Analysis**
