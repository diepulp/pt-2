Layering PT-2 2025-10-09 Architecture Recommendation layer structure implementation sequencing

Adopt horizontal-up-driven vertical PT-2 aligns horizontal layering formalizes layer boundaries sequencing cross-layer communication reusability context integrity Implement-complete vertical Service Action domain balances architectural consistency rapid delivery

Layer Definition Responsibilities Four-Layer Architecture Layer (Client Components UI UIH#FF0000 Layer (Server Actions Middleware Cache Layer (Business Logic) CRUD Business Queries Transforms Validation Layer (Database Supabase Client DB RLS Policies RT-time UI UIH SA CRUD Business Queries Supabase DB RLS RT#fce4ec#880e4f actionLayer#f0f4c3 serviceLayer#e1f5fe#e8f5e9 UI SA,Middleware CRUD,Queries,Transforms,Validation Supabase,RLS 1.2 Layer Responsibility Matrix Primary Responsibility Example Files Databasesubscriptions Schema RLS Database triggers Type generation Connection management Business logic Validation DTO transformation API contracts Business logic operations data transformation validation Domain DTOs rules validation Error handling ServiceResult contracts HTTP routing Cache UI Database schema Client instantiation Orchestration execution cache authorization orchestration Cache Authorization checks Action-level logging Input sanitization Business logic Database access UI rendering Client state Real-time subscriptionsRendering user interaction updates client-side state Component UI state React Query User input updates Real-time sync Server actions Business logic Database access Validation-list Cross-Layer Dependency Rules Top-down Action Service Data

ALLOWED UI Action (Server Actions Service factories Data Layer (Supabase client FORBIDDEN Service Action call actions UI import React/UI Data (No circular dependencies UI Service (Direct service calls actions-Layer → React Query hooks server actions-create-player import useMutation-query createPlayerAction export useCreatePlayer( return useMutation queryClient.invalidateQueries \*\*Action → Service factory instantiation dependency injection/actions/create-player-action createPlayerAction supabase createServerClient createPlayerService playerService.create → Supabase client access services/player export createPlayerCrudService async await supabase.select.single

Layer-Specific Concerns 2.1 Validation Strategy-Layer Defense depth validate boundary Layer Validation Type Tool Example Schema PostgreSQL CHECK Business rules Zod schemas `playerCreateSchema.parse(data Input sanitization Zod custom validators `sanitizeInput UX validation React Hook Form Zod resolver(schema Player Email Validation\*\* Data Layer supabase/migrations_create_player.sql CREATE TABLE Service Layer services/player/validation export playerCreateSchema z.object email firstName lastName Action Layer app/actions/player/create-player-actionexport async createPlayerAction server-side checks sanitized sanitizeInput UI Layer components/player-form form useForm resolver defaultValues email lastName 2.2 Error Handling Strategy Transform errors layers Error Code Error ServiceResult Error Response Error Message domain error ServiceResult UI-safe dbLayer#e8f5e9#1b5e20#e1f5fe#f0f4c3 Transformation Data Layer PostgreSQL returns 23505 violation Service Layer services/player/crud.code 'DUPLICATE_EMAIL player exists Service wraps ServiceResult data null error 'DUPLICATE_EMAIL details success false status 400 Action Layer app/actions/player/create-player-actionresult await playerService.create data error success UI Layer components/player-form error useCreatePlayer_EMAIL email registered 2.3 Transformation Strategy

Transform data shape layer boundaries Transformation Layer Tool Row `PlayerDTO Service `toPlayerDTO() View `PlayerDTO Action( Input Action `CreatePlayerInput `parseFormData() Input Service `CreatePlayerInput `PlayerCreateDTO Direct mapping adapter Player Data Transformation Pipeline\*\* Data Layer database row PlayerRow Database id email firstName lastName Service Layer Domain DTO/player/transforms export PlayerDTO export toPlayerDTO id email firstName lastName Action Layer Action response-player-action CreatePlayerResult PlayerDTO error ServiceError success boolean UI Layer View model display-player-view-modelexport interface PlayerViewModel id fullName Computed lastName emailDisplay Formatted display export function return id fullName emailDisplay.email.toLowerCase

Implementation Sequencing Strategy Recommended Approach-Up Vertical Data layer schema stability before layer Higher layers depend lower vertical slices deliver features domain Phase 1: Data Layer (1 day Write migration RLS triggers Generate typesTest schema Commit deploy remote Service Layer (2 days CRUD Business Queries Transforms Validation Integration tests 3: Action Layer Server actions Cache strategies Authorization Action tests 4: UI Layer (2 days React Query hooks Components Forms validation Real-time integration E2E tests Commit demo 6 days per domain Alternative Approach **Top-Down** UI no data rework risk Difficult test Prototyping UI/UX fake data Validating user workflows Exploratory design sessions Alternative Approach **Middle-Out**-First Service Layer (2 Define DTOs operations Data Layer Implement schema DTOs Action Layer Wire services server actions UI Layer (2 Build stable contracts Schema unstable API contracts Domain modeling iteration

Service DTOs align schema over-engineering without database constraints Rework if database different structure Current PT-2 Status (Phase 2 Assessment \*\*Implemented Player Visit RatingSlip PlayerFinancial Casino Data Service TableContext MTL Data Continue bottom-up approach domains complete vertical slices for MVP features (Player management Visit tracking Rating slip

Shared Infrastructure Reusability 4.1 Horizontal Reusability Matrix Reusable Across Domains Example Files **Operation Wrapper**/shared/operation-wrapper.ts **ServiceResult/shared **Error/shared/operation-wrapper.ts **Validation Domain-specific shared patterns `services/player/validation.ts **DTO Domain-specific `services/player/transforms.ts **Supabase layers/supabase/client/server Query hooks `lib/query-client.ts Action actions `lib-server-action-wrapper.ts **Cache Shared patterns custom domain `app/actions//invalidation-helpers.ts 4.2 Shared Infrastructure Architecture services/shared/operation-wrapperSHARED error handling result wrapping export async function<T Promise<T Promise<ServiceResult Centralized error mapping logging telemetry services/types Standard result contracts export interface ServiceResult<T data error success boolean status timestamp requestId/validation-SPECIFIC Reusable custom schemas export playerCreateSchema email firstName lastName/transforms reusable domains export id email firstNameDRY Principles Trade-offs DRY Shared infrastructure utilities Common patterns error handling Cross-cutting concerns telemetry caching Premature Abstraction Domain-specific transformations Business rules domains Validation logic-off Shared pattern domain-specific implementation createValidationSchema validation pattern playerSchema createValidationSchema firstName

casinoSchema createValidationSchema name address Over-abstraction domains interface GenericEntityDTO id string metadata unknown CasinoDTO coupling

Testing Strategy Layer-Specific Testing Approaches Type Boundaries Tools Schema Tests Constraints RLS policies Triggers Migrations SQL Supabase CLI Unit Tests CRUD operations Business logic Transformations Error handling Mock Supabase Integration Tests DB queries Transaction behavior RLS enforcement Integration Tests Service orchestration Cache invalidation Authorization servicesUnit Tests Component rendering User interactions State management React Query actions RTL E2E Tests user flows Real-time updates Form validation app DB Cypress 5.2 Testing Pyramid PT-2 E2E Tests workflows (10%) Integration Tests Service DB (30%) Action orchestration (10%) Unit Tests Service logic UI components (10%) Service layer UI components Transforms (10%) Integration Service Database Actions (10%) E2E Critical user flows Visit lifecycle Rating slip creation 5.3 Mock Boundaries Layer SERVICE LAYER TESTS Supabase Client

SERVICE LAYER INTEGRATION TESTS Supabase Test DB/player-integration.test supabase createClient_URL playerService result await playerService.create Verify data database ACTION LAYER Mock Service Layer-action createPlayerService success result await createPlayerAction 4. UI LAYER Server Actions React Query/player-form.test-action createPlayerActionsuccess mockPlayer Test UI interactions Coverage Targets Critical Paths Migrations 100% constraints policies triggers CRUD 90% error validation Business 85% Workflow transitions Queries 80% Complex joins filters Transforms 100% DTO mappings Validation 100% schema constraints Server Actions 80% Orchestration cache invalidation auth Components 70% User interactions conditional rendering User Flows 100% critical paths CRUD operations session lifecycle

Real-Time Subscription Strategy 6.1 Layer Placement Real-time subscriptions not Service Layer Real-time UI concern display Subscriptions require React lifecycle cleanup Service layer pure stateless Services manage WebSocket connections-Pattern Global real manager service layer RealtimeManager instance RealtimeManager connections Map RealtimeChannel void Global state singleton pattern breaks service purity Pattern Domain-specific hook UI layer-players-realtime usePlayersRealtime( queryClient supabase channel supabase-changes Batch invalidation scheduler pattern scheduleInvalidation queryClient.invalidateQueries.unsubscribe 6.2 Real-Time Integration Points UI Supabase DB RQ UI Hook Supabase-time event Supabase#fce4ec#880e4f#e8f5e9#1b5e20 A creates player PostgreSQL event Supabase broadcasts subscribed clients UI B receives invalidation React Query refetches data UI B re-renders new player

Implementation Guidance 7.1 Feature Development Workflow Implement Management feature Step Data Layer 1 Morning supabase/migrations_player.sql CREATE TABLE player UUID_random_uuid email NULL NULL NULL created DEFAULT ALTER TABLE player ENABLE ROW LEVEL SECURITY CREATE POLICY viewable authenticated users SELECT authenticated Commands supabase migration create_player supabase db npm gen:types Service Layer 1 Afternoon 2) services/index workflows.test npm test Action Layer 3 Morning/actions/player/create-player-action-player-action-player.test npm test Step 4: UI Layer (Day 3 Afternoon Day 4) Files-players Query-create-player-realtime sync-list-form/page.tsx Tests-list.test-management npm test Step 5 Integration Demo (Day 4 - Afternoon npm run /players Create update delete players Real-time sync tabs RLS policies Test coverage report 7.2 Cross-Layer Communication Examples Creating Player UI Layer User submits form components/player-form.tsx useCreatePlayer handleSubmit UI Hook React Query mutation-create-player.ts useCreatePlayer(invalidateQueries created Action Layer Server action orchestration async createPlayerAction supabase createServerClient playerService result await.create email firstName lastName

.success revalidatePath/players data error success Service Layer Business logic services/player/crud createPlayerCrudService async<ServiceResult executeOperation<PlayerDTO data error await supabase email firstName lastName'id email lastName.code '23505 'DUPLICATE_EMAIL exists return player Data Layer PostgreSQL execution RLS policy enforced Constraint check unique Trigger log successful Error Handling Data Layer PostgreSQL constraint violation constraint email code 23505) Service Layer domain error.code 'DUPLICATE_EMAIL player email exists error ServiceResult data null error 'DUPLICATE_EMAIL success false status 400 Action Layer Pass await playerServicecreate add action-level logging return result UI Layer User display mutate error useCreatePlayer 'DUPLICATE_EMAIL registered different.setError exists

Trade-offs Risk Assessment Architecture Trade-offs Advantages Disadvantages Mitigation-Up Stable foundation Testable layers Clear dependencies UI delivery over-engineering Vertical slicing MVP-first schema Layer Clean architecture Maintainable boilerplate Slower development Code-Layer Defense UX Security Duplicate validation Maintenance burden Shared Zod schemas Single source Consistent errors Type-safe Trackable Verbose return types Wrapper overhead Helper functions Type inference Risk Matrix Mitigation 3rd use case Review shared code boundary ESLint rules Code review checklist Architecture tests Enforce client orchestration Document anti-pattern errorShared Standard ServiceResult 4x critical paths Pyramid distribution Integration tests-time sync Scheduler batching Centralized invalidation E2E tests

9. Recommendations Next Steps Immediate Actions 1) Layer Create/LAYER_CONTRACTS.md interfaces Document DTO transformation patterns Establish ServiceResult error code catalog Service Casino Service Data Tests TableContext MTL Implement consistency Create shared cache invalidation helpers validation schema patterns Medium-Term Actions 2-4 Vertical UI Layers Player Management Actions UI E2E Visit Tracking E2E Rating Slip Creation E2E integration test database Implement Cypress E2E test suite Create test data factories/fixtures-Time hook pattern Implement invalidation scheduler Test multi-tab synchronization 9.3 Long-Term Actions (Month 2+) Extract common query patterns shared `queriesDTO transformation utilities Create business workflow templates Implement updates low-latency Add offline-first capabilities Build cross-domain aggregations coding standards layer violation tools Establish architecture review process

Success Metrics Architecture Quality Indicators Target Measurement Boundary ESLint manual code review >80% Layer Test >90% Critical business logic <60s metrics 100% TypeScript compiler \*\*ServiceResult 100% service methods Code review checklist 10.2 Development Velocity Indicators Target Domain 6 days velocity tracking Module >50% shared infrastructure analysis Execution <5min <15min Onboarding <4 hours feedback

Horizontal Vertical Data Schema Service Business logic validation Action Orchestration cache auth UI Components hooks Bottom-up Vertical slicing 6-day cadence reusability domain logic isolated Balance DRY domain autonomy 60% unit 30% integration 10% E2E boundaries critical paths UI-layer hooks Batch invalidations Clean subscription lifecycle service layers vertical slice shared infrastructure Document contracts coding standards Zero violations >80% test coverage 6-day slice cadence Developer onboarding <4 hours 1.0 2025-10-09 Architecture Team Recommended Adoption

Appendix A Layer Communication Patterns 1: Simple CRUD Operation UI Action Service Data.create.insert 2: Complex Workflow UI Action Multiple Services Data.start.create [auditLogService.log.rpc_visit_transaction 3: Real-Time Data UI change broadcast [useRealtimeHook Query invalidate re-render

Appendix B File Organization Layer pt supabase DATA LAYER migrations xxx_create_player.sql types SHARED TYPES database.types.ts Generated from schema domains player player-dto.ts services SERVICE LAYER shared operation-wrapper.ts types.ts utils.ts player index.ts crud business.ts queries transforms validation.ts app ACTION UI LAYERS actions ACTION LAYER player create-player-action.ts update-player-action.ts players UI LAYER (Pages page.tsx components player-list.tsx hooks use-players.ts-create-player-realtime TESTING services player player-service.test player-integration.test actions player create-player.test components player-list.test player-management.cy.ts of Analysis
