Wave 2 Atomicity Observability gaps 6 Review 2025-10-13

Wave 2 approach eliminates over-engineering introduces production atomicity failure recovery document lean complexity integrity user trust

Atomicity Gap Two-step saga recovery flow supabase.rpc_player_session Committed loyalty Fails Rating slip CLOSED NO points Player loses rewards recovery Revenue loss player complaints compliance risk prove points_player_session separate Supabase RPC commits Loyalty fails no rollback Solution Compensating Transaction Pattern Single Transaction Boundary operations Supabase transaction services/ratingslip async completeRatingSlip executeOperation START TRANSACTION await supabase.rpc Close rating slip session supabase_player_session_slip_id_id_taken_time (closeError throw Accrue loyalty points createLoyaltyService await.accruePointsFromSlip ratingSlipId playerId visitId averageBet durationSeconds gameSettings!loyaltyResult throw loyaltyResult.error COMMIT TRANSACTION success true ratingSlip loyalty.data ROLLBACK failure error B Recovery Path Supabase use deterministic recovery/recovery partial slip completion replay export async function recoverLoyaltyForSlip supabase slipId correlationId<AccruePointsResult>> Check if loyalty accrued data await supabase_ledgereq_slip_id_type 'GAMEPLAY.single (existingEntry recovered return result success true data pointsEarned_change ledgerEntryId

Fetch slip telemetry await supabase slipId 'CLOSED success false error_NOT_CLOSED recover loyalty open Accrue points key loyaltyService.accruePointsFromSlip ratingSlipId playerId telemetry Action export async function completeRatingSlip(slipId correlationId Attempt atomic completion completeRatingSlipAtomic slipId Log partial failure correlation ID_completion_failed correlation slip_id error recovery_needed true Return partial state UI success false error 'PARTIAL_COMPLETION closed loyalty pending recovery actionmetadata slipId correlationId Staff recovery action partial completions export async recoverSlipLoyalty(slipId correlationId return recoverLoyaltyForSlip slipId Add_before_ledger recovery verification

Idempotency Keying Problem Manual reward keys non Creates new key Staff double-award clicking unique index bypassed Staff award duplicate points Solution Deterministic Idempotency Keys Gameplay services/loyalty function accruePointsFromSlip Idempotency key rating_slip_id slip.ratingSlipId Insert loyalty_ledger await supabase player_id rating_slip_id visit_id session_id idempotencyKey transaction_type 'GAMEPLAY event_SLIP_COMPLETED points_change calculatedPoints source Handle idempotency conflict Conflict unique index processed await supabase_ledger_id idempotencyKeylogger.info_idempotency_hit session_id idempotencyKey player_id.playerId existing_points_change Return result success success true data pointsEarned_change ledgerEntryId true Flag observability proceed RPC call new entries Manual/loyalty-actions export async function manualReward playerId pointsChange reason staffId ratingSlipId Link slip recovering rewardId External reward ID promo system return_reward async Generate idempotency key.rewardId playerId staffId points.pointsChange reason.reason date Rate limit check max 10 window 60000 success false error 'RATE_LIMIT_EXCEEDED Validate audit requirements.reasonlength 10 success false error 'VALIDATION_ERROR 10 characters

Insert deterministic key loyaltyService return.createLedgerEntry player_id rating_slip recovery session_id idempotencyKey transaction.pointsChange 0_BONUS 'ADJUSTMENT event 'POINTS_UPDATE_REQUESTED points_change reason source staff_id Track issued Hash idempotency key components same inputs key retries hashIdempotencyKey payload Object.entries hash crypto.createHash return `manual Add `staff_id column `loyalty_ledger audit trail

RPC Strengthening PRIORITY RPC returns minimal data RETURNS TABLE_balance tier_before_after audit verification tier change alerts_progress UI display Row lock confirmation Solution Enhanced RPC Return/migrations_player_loyalty DROP FUNCTION increment_player_loyalty CREATE REPLACE FUNCTION_id_points RETURNS TABLE player_id balance_before_progress lifetime_points updated TIMESTAMPTZ_locked Confirms SECURITY DEFINER search_path public_balance_before_after_progress Lock row update prevents race conditions SELECT_balance_points_balance_before_lifetime player_loyaltyplayer_id UPDATE insert initial values NOT INSERT player_loyalty_id lifetime_progress p_player_id_delta_points p_delta_points > 0 'BRONZE v_balance_before 0 'BRONZE_lifetime_delta_points > 0 0 Calculate new values v_balance_after_delta_points_lifetime +\_delta_points > 0_delta_points 0 Determine tier lifetime points SELECT t.tier_tier_after loyalty.threshold_points < v_lifetime ORDER Calculate tier progress next v_tier_after 'PLATINUM 100 SELECT ROUND_lifetime NULLIF(next_tier JOIN next.threshold_points_points v_tier_after ORDER nextthreshold_points LIMIT Clamp 0-100 LEAST GREATEST COALESCE

Update player_loyalty new values current_balance_after lifetime_points tier_after_progress updated_at now pl.player_id_player_id Return result SELECT p_player_id_balance_before_after_progress_lifetime_updated_at_locked Confirms lock acquired increment_player_loyalty updates player loyalty returns before/after values audit trail Layer/loyalty async updatePlayerBalance supabase playerId deltaPoints correlationId data rpcResult error rpcError supabase.rpc_player_loyalty_player_id_delta_points_rpc_failed correlation_id player_id delta_points success false error rpcError result rpcResult Log tier changes alerts.tier_before.tier_after'loyalty_tier_upgraded correlation_id player_id tier_before_after lifetime_points Verify row lock acquired if.row_locked logger.warn'loyalty_lock_failed correlation_id player_id success true data balanceBefore balanceAfter lifetimePoints updatedAt Store `balance_before_after in `loyalty_ledger for verification

Correlation ID Structured Logging PRIORITY Problem trace request flow services ERROR Loyalty accrual failed slip abc-123 player correlation ID Solution Request Correlation Infrastructure Correlation ID Entry lib/correlation import AsyncLocalStorage correlationStorage AsyncLocalStorage generateCorrelationId.random.slice(2 11 getCorrelationId setCorrelationId void.enterWith withCorrelationId<T correlationStorage.run Server lib/server-actions-wrapper generateCorrelationId export async function withServerAction actionName handler correlationId setCorrelationId startTime Date.now supabase createServerClient logger.info_started action correlation_id user_id optionsuserId entity result await handler duration Date startTime.info_completed correlation_id duration success true success true data result duration Date startTime.error_failed correlation_id duration error success false error 'ACTION_FAILED message metadata correlationId **Propagate services/loyalty async function accruePointsFromSlip supabase AccruePointsInput correlationId getCorrelationId.info'loyalty_accrual_started correlation_id player_id rating_slip_id average_bet duration_seconds accrual.info'loyalty_accrual_completed correlation_id player_id points_earned new_balancesuccess data result catch logger.error_failed correlation_id player rating_slip error.message throw error **Canonical Log

Gameplay accrual_accrual_completed correlation timestamp ISO8601 player_id rating_slip session_id transaction_SLIP_COMPLETED points_earned balance_before_after duration Manual reward_issued timestamp ISO8601 player_id staff_id points_change reason idempotency_key balance Failure_accrual_failed timestamp ISO8601 player_id rating error_code_message stack_trace recovery_needed

Schema Additions (REQUIRED supabase/migrations/20251013_wave_2_schema_hardening Add audit columns loyalty_ledger ALTER TABLE ADD COLUMN staff_id balance_before_after_before_after correlation_id Index correlation ID lookups INDEX_loyalty_ledger_correlation NULL Index staff audit queries CREATE INDEX_loyalty_ledger_staff NULL COMMENT loyalty_ledger.staff_id member issued manual reward audit trail.balance_before balance before transaction verification_after balance after transaction.tier_before tier before transaction_after after loyalty_ledger.correlation_id 'Request correlation ID distributed tracing

Failure UX Operational Runbook UI States \*\*Slip Completion components-slip/complete-slip-dialog export function CompleteSlipDialog( slipId useState<CompletionResult async function handleComplete( setStatus'pending result completeRatingSlip(slipId);.success setResult.error 'PARTIAL_COMPLETION setStatus 'partial Closed Loyalty Rating slip closed loyalty points awarded handleRecovery(result.slipId result.correlationId Retry Award Points 'success.loyalty.pointsEarned points awarded New balance {result.loyalty.newBalance Tier.loyaltyOperational Runbook 1: Partial Slip Player reports slip closed no points Search logs Verify slip status `CLOSED Check_ledger entry_slip_id no entry run recovery action/recover_xxx Verify ledger entry player balance updated Document incident correlation ID post 2: Duplicate Manual Staff reports points balance Idempotency key matched entry Query `loyalty_ledger_id timestamp Verify entry_key Confirm player balance Inform staff processed No action 3: Rate Limiter Reset Staff >10 rewards/min rate limiter lost restart Monitor_reward frequency Alert >20 rewards/min Upgrade to Redis abuse

4: Concurrency Race Completion Final balance equal ledger entries Missed UPDATE RPC calls interleaved Query_ledger_change Compare_loyalty_balance mismatch Rebuild balance UPDATE player_loyalty current_balance SELECT_change_ledger player Investigate RPC logs missing_locked Escalate pattern lock contention

New Test Scenarios Test 1: Saga Recovery/loyalty-saga Saga Recovery completion Slip closed loyalty fails recovery succeeds await createTestScenario Mock loyalty service failure Error connection lost Attempt completion fail await completeRatingSlip.error'PARTIAL_COMPLETION Verify slip CLOSED no ledger entry closedSlip await supabase'CLOSED ledger await supabase_ledger_slip_id Run recovery key await recoverSlipLoyalty(slip.id result Verify ledger entry exists await supabase'loyalty_ledger_slip_id test'Recovery single ledger entry async createPartiallyCompletedSlip Run recovery twice recoverSlipLoyalty_123 Verify 1 ledger entry supabase_ledger_slip_id expect(ledger).toHaveLength(1) Test 2: Concurrency Control/loyalty-concurrency'Simultaneous manual reward slip completion no lost updates createTestScenario Start operations concurrently completionResult Promise manualReward playerId pointsChange 500 bonus staffId completeRatingSlip(slip expect(rewardResult(completionResult Verify final balance sum operations balance await supabase_loyalty_balance_idexpectedBalance 500 +.loyalty.pointsEarned Verify 2 ledger entries ledger await supabase_ledger\*\_id'created ascending true(ledger).toHaveLength(2)\_BONUS|GAMEPLAY lock prevents interleaved updates async player createTestScenario

Start 10 rewards promises Array length 10 manualReward playerId pointsChange 100 $ staffId-$ rewardId\_$ Unique keys results Promise succeed Final balance equal 10 \* 100 = 1000 balance supabase_loyalty_balance_id Verify RPC calls_locked TRUE logs Test 3: Idempotency Edge Cases-idempotency reward Same inputs day single ledger entry createTestScenario playerId pointsChange 250 'Birthday bonus staffId Call twice identical inputs manualReward Verify 1 ledger entry-bucketed idempotency supabase_ledger_ideq expect test reward Same inputs next day 2 ledger entries async player createTestScenario playerId pointsChange 250 'Birthday bonus staffId Day 1 await manualReward advance next day(24 60 Day 2 await manualReward Verify 2 ledger entries date buckets supabase_id(ledger).toHaveLength(2) accrual rating_slip_id deterministic async createTestScenario Complete completeRatingSlip(slip Verify single ledger entry supabase_ledger_slip_id(ledger).toHaveLength(1)(slip Deterministic

Security Posture Server-Only Actions/loyalty-actions Prevents client-side execution import hasPermission/auth/permissions export async function manualReward return withServerAction_reward async (supabase Verify staff authentication supabase.getSession false error 'UNAUTHORIZED Verify staff LOYALTY_AWARD permission_reward_unauthorized_id success false error 'FORBIDDEN Verify staff_id matches authenticated user.staffId session.user_reward_spoofing_attempt success false error 'INVALID_STAFF_ID Enforce max points per reward rule MAX_MANUAL_REWARD = 10000MAX_MANUAL_REWARD success false error 'REWARD_EXCEEDS_LIMIT points per reward proceed reward issuance RLS Policies Prevent table writes-only CREATE POLICY loyalty_ledger_insert_service_only.role role insert Players read ledger POLICY loyalty_ledger_read_own_id.uid Staff read ledgers POLICY loyalty_ledger_read_staff id auth.uid_permission'loyalty:view_all Alerts-alerts Alert abnormal manual reward frequency checkManualRewardFrequency(staffId count threshold 20 >20 rewards 1 hour suspicious alertTeam severity Manual Reward Frequency message issued rewards activity logs contact manager

Alert changes player engagement export function notifyTierUpgrade(playerId tierBefore tierAfter sendPlayerNotification playerId title reached tier message upgraded action Benefits

Implementation Checklist Critical Fixes Wave 2 Implement transactional boundary recovery path partial completions Replace.now( deterministic hashing manual rewards Update_player_loyalty before/after values Add_id_id columns Thread IDs server actions services canonical log schema loyalty operations `recoverSlipLoyalty UI recovery test concurrency test balance idempotency test reward date-bucketed keys Additions Add permission checks RLS policies direct table access prevention abnormal frequency monitoring manual rewards upgrade notifications Update operational runbook recovery procedures Add Loyalty retry button Reward Enforce business rule10,000 points manual reward timeline pressure Visualize manual reward frequency Export loyalty operations date range Verification verify_loyalty sum

Timeline Wave 4-5h Critical 6-7h hardening Atomicity Recovery Idempotency Hardening RPC Enhancement Infrastructure Schema Migration Critical Tests +1h Absorb +2h production

Risk Re-Assessment Before After Mitigation Loss Completion Recovery correlation tracing **Duplicate Manual keys date bucketing **Concurrency MEDIUM UPDATE lock audit columns **Untraceable Failures** Correlation IDs structured logs **Staff Abuse** Permission checks frequency alerts **Balance Drift** Ledger verification before/after columns Risk hardening

Wave 2 approach production Two-step data loss risk Non-deterministic keys duplicate rewards No correlation untraceable failures Minimal RPC return fixes add~2h reduce production risk Apply fixes before 2 cost fixing 10x higher post
