{
  "summary": {
    "documents_analyzed": 17,
    "pattern_categories": 5,
    "contradictions_found": 2,
    "patterns_by_category": {
      "service_implementation": {
        "description": "How services should be implemented",
        "documents_mentioning": 5,
        "required_statements": 2,
        "prohibited_statements": 8
      },
      "type_inference": {
        "description": "Type declaration patterns",
        "documents_mentioning": 8,
        "required_statements": 18,
        "prohibited_statements": 9
      },
      "supabase_client": {
        "description": "Supabase client handling",
        "documents_mentioning": 13,
        "required_statements": 14,
        "prohibited_statements": 15
      },
      "state_management": {
        "description": "State management approach",
        "documents_mentioning": 12,
        "required_statements": 52,
        "prohibited_statements": 23
      },
      "exports": {
        "description": "Module export patterns",
        "documents_mentioning": 2,
        "required_statements": 2,
        "prohibited_statements": 3
      }
    }
  },
  "contradictions": [
    {
      "category": "supabase_client",
      "description": "Supabase client handling",
      "conflicts": [
        {
          "issue": "Supabase client typing with any",
          "required_by": [
            {
              "line": 197,
              "keyword": "SupabaseClient",
              "directive": "REQUIRED",
              "statement": "// NO: createPlayerService(supabase: any) - must type as SupabaseClient<Database>",
              "context": "// NO: ServiceFactory.getInstance().getService('player')\n// NO: export type PlayerService = ReturnType<typeof createPlayerService>\n// NO: createPlayerService(supabase: any) - must type as SupabaseClient<Database>\n// NO: return { ...(service as any).hiddenMethod } - incomplete interfaces\n// NO: @deprecated class wrappers that delegate to functional services",
              "source": "system-prd/SERVICE_LAYER_ARCHITECTURE_DIAGRAM.md"
            },
            {
              "line": 197,
              "keyword": "any",
              "directive": "REQUIRED",
              "statement": "// NO: createPlayerService(supabase: any) - must type as SupabaseClient<Database>",
              "context": "// NO: ServiceFactory.getInstance().getService('player')\n// NO: export type PlayerService = ReturnType<typeof createPlayerService>\n// NO: createPlayerService(supabase: any) - must type as SupabaseClient<Database>\n// NO: return { ...(service as any).hiddenMethod } - incomplete interfaces\n// NO: @deprecated class wrappers that delegate to functional services",
              "source": "system-prd/SERVICE_LAYER_ARCHITECTURE_DIAGRAM.md"
            },
            {
              "line": 110,
              "keyword": "any",
              "directive": "REQUIRED",
              "statement": "- Any advanced offline/optimistic behaviour must sit behind domain-specific services with explicit acceptance criteria and integration tests\u2014not global managers.",
              "context": "- Mutations perform cache updates via `invalidateQueries` or targeted `setQueryData`; optimistic updates stay opt-in and encapsulated in domain helpers.\n- All React Query hooks wrap service-layer DTOs\u2014never raw Supabase rows\u2014and surface consistent loading/error contracts for UI components.\n- Any advanced offline/optimistic behaviour must sit behind domain-specific services with explicit acceptance criteria and integration tests\u2014not global managers.\n\n### 3.5 Server Actions & Data Fetching",
              "source": "system-prd/CANONICAL_BLUEPRINT_MVP_PRD.md"
            },
            {
              "line": 129,
              "keyword": "any",
              "directive": "REQUIRED",
              "statement": "- Any advanced offline/optimistic behaviour must sit behind domain-specific services with explicit acceptance criteria and integration tests\u2014not global managers.",
              "context": "- Domain hooks manage their own channel lifecycle; avoid cross-cutting singletons such as connection pools, optimistic-update managers, or offline queues under `services/real-time/*`.\n- Logging and metrics for live data stay inside dev tooling; production hooks should be silent and rely on React Query retries for resilience.\n- Any advanced offline/optimistic behaviour must sit behind domain-specific services with explicit acceptance criteria and integration tests\u2014not global managers.\n\n### 3.7 UI Composition",
              "source": "system-prd/CANONICAL_BLUEPRINT_MVP_PRD.md"
            },
            {
              "line": 183,
              "keyword": "any",
              "directive": "REQUIRED",
              "statement": "- **Forbid `as any` type casting to bypass incomplete interfaces** (violation in `services/visit/index.ts:76`). If a method exists in implementation, it MUST be declared in the interface.",
              "context": "  - Ban mixing default and named exports from service modules; use named exports exclusively for consistency and traceability.\n  - Prohibit runtime validation in service factory functions; move validation to development-only assertions or initialization-time checks.\n  - **Forbid `as any` type casting to bypass incomplete interfaces** (violation in `services/visit/index.ts:76`). If a method exists in implementation, it MUST be declared in the interface.\n  - **Remove all deprecated class wrappers** marked `@deprecated` that delegate to functional services (violation: `VisitService` class in `services/visit/index.ts`). Delete deprecated code instead of maintaining dual APIs.\n  - **Interfaces must be complete**: Every public method in the service implementation must have a corresponding type signature in the interface. No silent additions via type casting.",
              "source": "system-prd/CANONICAL_BLUEPRINT_MVP_PRD.md"
            },
            {
              "line": 14,
              "keyword": "any",
              "directive": "REQUIRED",
              "statement": "Before starting ANY service implementation, verify you will NOT:",
              "context": "## Anti-Pattern Guardrails\n\nBefore starting ANY service implementation, verify you will NOT:\n\n| \u274c Anti-Pattern | \u2705 Correct Pattern |",
              "source": "patterns/SERVICE_TEMPLATE.md"
            },
            {
              "line": 51,
              "keyword": "any",
              "directive": "REQUIRED",
              "statement": "Anything beyond this requires a trigger (\u00a76) and a Mini-ADR (\u00a77).",
              "context": "One structured log per operation with correlation_id (success/failure).\n\nAnything beyond this requires a trigger (\u00a76) and a Mini-ADR (\u00a77).\n\n## 5. Red-Flag Checklist (Stop-the-Line if any two are \"Yes\")",
              "source": "patterns/OVER_ENGINEERING_GUARDRAIL.md"
            },
            {
              "line": 182,
              "keyword": "SupabaseClient",
              "directive": "REQUIRED",
              "statement": "- \u2705 All services use `SupabaseClient<Database>` (no `any`)",
              "context": "**End-of-Phase-2 Audit**:\n- \u2705 All services have explicit interfaces (no `ReturnType`)\n- \u2705 All services use `SupabaseClient<Database>` (no `any`)\n- \u2705 Zero PRD violations (ESLint + manual review)\n- \u2705 Test coverage >80% per service",
              "source": "adr/NEXT_STEPS_REPORT.md"
            },
            {
              "line": 182,
              "keyword": "any",
              "directive": "REQUIRED",
              "statement": "- \u2705 All services use `SupabaseClient<Database>` (no `any`)",
              "context": "**End-of-Phase-2 Audit**:\n- \u2705 All services have explicit interfaces (no `ReturnType`)\n- \u2705 All services use `SupabaseClient<Database>` (no `any`)\n- \u2705 Zero PRD violations (ESLint + manual review)\n- \u2705 Test coverage >80% per service",
              "source": "adr/NEXT_STEPS_REPORT.md"
            },
            {
              "line": 594,
              "keyword": "any",
              "directive": "REQUIRED",
              "statement": "export function useSupabaseChannel<T extends RealtimePostgresChangesPayload<any>>(",
              "context": "```typescript\n// hooks/shared/use-supabase-channel.ts\nexport function useSupabaseChannel<T extends RealtimePostgresChangesPayload<any>>(\n  channelName: string,\n  config: {",
              "source": "adr/NEXT_STEPS_REPORT.md"
            },
            {
              "line": 38,
              "keyword": "any",
              "directive": "REQUIRED",
              "statement": "- **Effect Boundaries**: A shared `useRealtimeSubscription` hook wraps Supabase listeners inside `useEffect` with deterministic cleanup. It also registers a `AbortController` which is signalled on unmount to short-circuit any pending scheduler tasks.",
              "context": "\n- **Ref-counted Cleanup**: `acquireChannel` increments a counter per channel; on cleanup the counter decrements and invokes `channel.unsubscribe()` once it hits zero.\n- **Effect Boundaries**: A shared `useRealtimeSubscription` hook wraps Supabase listeners inside `useEffect` with deterministic cleanup. It also registers a `AbortController` which is signalled on unmount to short-circuit any pending scheduler tasks.\n- **Idle Detection**: The registry tracks last-activity timestamps; idle channels (no subscribers + no events for 30s) are purged from memory to avoid zombie sockets when a user navigates rapidly between tabs.\n- **Testing Hooks**: Jest tests simulate mount/unmount sequences to assert channel counts drop to zero and scheduler queues flush. Cypress smoke ensures that navigating away from realtime-heavy screens does not log Supabase warnings.",
              "source": "adr/ADR-004-real-time-strategy.md"
            },
            {
              "line": 51,
              "keyword": "any",
              "directive": "REQUIRED",
              "statement": "- **Foreground/Background Awareness**: When the document visibility changes to hidden for >2 minutes, we pause scheduler execution (queue persists). On visibility regain we flush the queue then rely on React Query\u2019s `refetchOnReconnect` to catch any missed deltas.",
              "context": "- **Supabase Status Hooks**: The registry listens to Supabase `on('system', 'status')` events. On transitions to `CONNECTED`, it replays pending scheduler tasks and triggers a selective refetch (`queryClient.invalidateQueries` for domains flagged as \u201crequires resync on reconnect\u201d).\n- **Backoff & Limits**: Let Supabase handle connection retries but impose a cap of 5 rapid reconnections before surfacing a toast via Zustand UI store prompting users to refresh. This prevents infinite reconnect loops in degraded networks.\n- **Foreground/Background Awareness**: When the document visibility changes to hidden for >2 minutes, we pause scheduler execution (queue persists). On visibility regain we flush the queue then rely on React Query\u2019s `refetchOnReconnect` to catch any missed deltas.\n- **Auth Refresh Integration**: The Supabase SSR helper already rotates session tokens; the registry exposes `refreshAuth(token)` so that when Next.js refreshes session cookies the channel client updates without tearing down listeners.\n",
              "source": "adr/ADR-004-real-time-strategy.md"
            },
            {
              "line": 59,
              "keyword": "any",
              "directive": "REQUIRED",
              "statement": "**Override Guidance**: The 5-minute/30-minute defaults serve as a baseline. Hook authors should explicitly set shorter `staleTime`/`gcTime` values for high-volatility queries such as live table availability or player status dashboards, and extend the window for infrequently accessed reports. Document any override in the corresponding domain README so cross-team consumers know the expected freshness.",
              "context": "- TypeScript-first design\n\n**Override Guidance**: The 5-minute/30-minute defaults serve as a baseline. Hook authors should explicitly set shorter `staleTime`/`gcTime` values for high-volatility queries such as live table availability or player status dashboards, and extend the window for infrequently accessed reports. Document any override in the corresponding domain README so cross-team consumers know the expected freshness.\n\n**Evidence**: `/home/diepulp/projects/pt-2/lib/query-client.ts` - 4 tests passing",
              "source": "adr/ADR-003-state-management-strategy.md"
            },
            {
              "line": 528,
              "keyword": "any",
              "directive": "REQUIRED",
              "statement": "1. \u2705 Casino Service (5 tests) - All CRUD + ListByCompany",
              "context": "\n**Services Validated**:\n1. \u2705 Casino Service (5 tests) - All CRUD + ListByCompany\n2. \u2705 Player Service (3 tests) - Create, Read, Update\n3. \u2705 Visit Service (3 tests) - Create, Read, Update",
              "source": "adr/ADR-003-state-management-strategy.md"
            }
          ],
          "prohibited_by": [
            {
              "line": 302,
              "keyword": "SupabaseClient",
              "directive": "PROHIBITED",
              "statement": "\u2705 Type `supabase` parameter as `SupabaseClient<Database>` (never `any`)",
              "context": "\u2705 Use plain functional factories for service creation\n\u2705 Declare explicit interfaces for all services with complete type signatures\n\u2705 Type `supabase` parameter as `SupabaseClient<Database>` (never `any`)\n\u2705 Export explicit types, not `ReturnType<typeof createXService>`\n\u2705 Compose services from specialized modules with typed spread",
              "source": "system-prd/SERVICE_LAYER_ARCHITECTURE_DIAGRAM.md"
            },
            {
              "line": 302,
              "keyword": "any",
              "directive": "PROHIBITED",
              "statement": "\u2705 Type `supabase` parameter as `SupabaseClient<Database>` (never `any`)",
              "context": "\u2705 Use plain functional factories for service creation\n\u2705 Declare explicit interfaces for all services with complete type signatures\n\u2705 Type `supabase` parameter as `SupabaseClient<Database>` (never `any`)\n\u2705 Export explicit types, not `ReturnType<typeof createXService>`\n\u2705 Compose services from specialized modules with typed spread",
              "source": "system-prd/SERVICE_LAYER_ARCHITECTURE_DIAGRAM.md"
            },
            {
              "line": 320,
              "keyword": "any",
              "directive": "PROHIBITED",
              "statement": "\u274c Type parameters as `any` (violations: Casino, MTL services)",
              "context": "\u274c Create duplicate/competing factory patterns (createXService + createXServices)\n\u274c Use `ReturnType<typeof createXService>` for type inference\n\u274c Type parameters as `any` (violations: Casino, MTL services)\n\u274c Use `as any` type casting to bypass incomplete interfaces (violation: Visit service)\n\u274c Create deprecated class wrappers that delegate to functional services",
              "source": "system-prd/SERVICE_LAYER_ARCHITECTURE_DIAGRAM.md"
            },
            {
              "line": 321,
              "keyword": "any",
              "directive": "PROHIBITED",
              "statement": "\u274c Use `as any` type casting to bypass incomplete interfaces (violation: Visit service)",
              "context": "\u274c Use `ReturnType<typeof createXService>` for type inference\n\u274c Type parameters as `any` (violations: Casino, MTL services)\n\u274c Use `as any` type casting to bypass incomplete interfaces (violation: Visit service)\n\u274c Create deprecated class wrappers that delegate to functional services\n\u274c Leave methods undeclared in interfaces (must be complete)",
              "source": "system-prd/SERVICE_LAYER_ARCHITECTURE_DIAGRAM.md"
            },
            {
              "line": 63,
              "keyword": "SupabaseClient",
              "directive": "PROHIBITED",
              "statement": "- **Typed Dependencies**: Factory functions MUST type the `supabase` parameter as `SupabaseClient<Database>`. Never use `any`.",
              "context": "\n- **Ban `ReturnType` Inference**: Never use `ReturnType<typeof createXService>` for exported service types. Always export the explicit interface: `export type PlayerService = IPlayerService`.\n- **Typed Dependencies**: Factory functions MUST type the `supabase` parameter as `SupabaseClient<Database>`. Never use `any`.\n- **No Object Spread Without Types**: When composing services via object spread, the factory MUST declare an explicit return type interface that describes the final shape. This prevents silent method overwrites.\n",
              "source": "system-prd/CANONICAL_BLUEPRINT_MVP_PRD.md"
            },
            {
              "line": 14,
              "keyword": "any",
              "directive": "PROHIBITED",
              "statement": "- **No Anti-Patterns**: Ban dual DB clients, React Query storming, business logic in Zustand stores, `Database = any` shims.",
              "context": "- **Security First**: RLS enabled by default, JWT claim helpers versioned with migrations, audit logging mandatory.\n- **Guardrails Upfront**: CI gates for lint, type-check, tests, schema\u2192type regeneration, Lighthouse budgets.\n- **No Anti-Patterns**: Ban dual DB clients, React Query storming, business logic in Zustand stores, `Database = any` shims.\n\n## 3. System Requirements & Patterns to Replicate",
              "source": "system-prd/CANONICAL_BLUEPRINT_MVP_PRD.md"
            },
            {
              "line": 63,
              "keyword": "any",
              "directive": "PROHIBITED",
              "statement": "- **Typed Dependencies**: Factory functions MUST type the `supabase` parameter as `SupabaseClient<Database>`. Never use `any`.",
              "context": "\n- **Ban `ReturnType` Inference**: Never use `ReturnType<typeof createXService>` for exported service types. Always export the explicit interface: `export type PlayerService = IPlayerService`.\n- **Typed Dependencies**: Factory functions MUST type the `supabase` parameter as `SupabaseClient<Database>`. Never use `any`.\n- **No Object Spread Without Types**: When composing services via object spread, the factory MUST declare an explicit return type interface that describes the final shape. This prevents silent method overwrites.\n",
              "source": "system-prd/CANONICAL_BLUEPRINT_MVP_PRD.md"
            },
            {
              "line": 26,
              "keyword": "any",
              "directive": "PROHIBITED",
              "statement": "**One-Violation Rule**: If migrating PT-1 code that breaks ANY rule above \u2192 rewrite, don't patch.",
              "context": "| `console.*` in operations | Structured logging/monitoring |\n\n**One-Violation Rule**: If migrating PT-1 code that breaks ANY rule above \u2192 rewrite, don't patch.\n\n---",
              "source": "patterns/SERVICE_TEMPLATE.md"
            },
            {
              "line": 19,
              "keyword": "any",
              "directive": "PROHIBITED",
              "statement": "**One-Violation Rule**: If PT-1 code breaks ANY rule \u2192 **rewrite**, don't patch.",
              "context": "| `console.*` | Structured logging |\n\n**One-Violation Rule**: If PT-1 code breaks ANY rule \u2192 **rewrite**, don't patch.\n\n---",
              "source": "patterns/SERVICE_TEMPLATE_QUICK.md"
            },
            {
              "line": 20,
              "keyword": "any",
              "directive": "PROHIBITED",
              "statement": "**Do not refactor or generalize any helper until you've repeated it in three slices.**",
              "context": "\n### 1. Rule of Three\n**Do not refactor or generalize any helper until you've repeated it in three slices.**\n\nExample: Don't create `services/shared/validation.ts` until 3 services need the same validation pattern.",
              "source": "patterns/controlled-hybrid-refactor-model.md"
            },
            {
              "line": 29,
              "keyword": "any",
              "directive": "PROHIBITED",
              "statement": "- \u274c `supabase: any`",
              "context": "Violations:\n- \u274c `ReturnType<typeof createXService>`\n- \u274c `supabase: any`\n- \u274c `@/types/database-rebuilt` imports\n- \u274c `services/x/types.ts` files",
              "source": "patterns/controlled-hybrid-refactor-model.md"
            },
            {
              "line": 35,
              "keyword": "any",
              "directive": "PROHIBITED",
              "statement": "Action: If PT-1 code contains ANY \u2192 **rewrite using template**, don't import.",
              "context": "- \u274c `class BaseService` abstractions\n\nAction: If PT-1 code contains ANY \u2192 **rewrite using template**, don't import.\n\n### 3. Time-Box Mining",
              "source": "patterns/controlled-hybrid-refactor-model.md"
            },
            {
              "line": 257,
              "keyword": "SupabaseClient",
              "directive": "PROHIBITED",
              "statement": "\u274c **Typed dependencies** - `supabase: SupabaseClient<Database>`, NOT `any`",
              "context": "### Never Compromise (Non-Negotiable)\n\u274c **Explicit interfaces** - `interface XService`, NOT `ReturnType`\n\u274c **Typed dependencies** - `supabase: SupabaseClient<Database>`, NOT `any`\n\u274c **ServiceResult pattern** - Consistent error handling\n\u274c **80% test coverage** - Service layer minimum",
              "source": "patterns/BALANCED_ARCHITECTURE_QUICK.md"
            },
            {
              "line": 257,
              "keyword": "any",
              "directive": "PROHIBITED",
              "statement": "\u274c **Typed dependencies** - `supabase: SupabaseClient<Database>`, NOT `any`",
              "context": "### Never Compromise (Non-Negotiable)\n\u274c **Explicit interfaces** - `interface XService`, NOT `ReturnType`\n\u274c **Typed dependencies** - `supabase: SupabaseClient<Database>`, NOT `any`\n\u274c **ServiceResult pattern** - Consistent error handling\n\u274c **80% test coverage** - Service layer minimum",
              "source": "patterns/BALANCED_ARCHITECTURE_QUICK.md"
            },
            {
              "line": 65,
              "keyword": "any",
              "directive": "PROHIBITED",
              "statement": "2. **Leak Prevention**: Ref-counted registry and effect cleanup avoid the \u201ctoo many listeners\u201d warnings witnessed in earlier spikes.",
              "context": "\n1. **Predictable Cache Updates**: Scheduler + canonical query keys minimize redundant refetches while keeping React Query aligned with live data.\n2. **Leak Prevention**: Ref-counted registry and effect cleanup avoid the \u201ctoo many listeners\u201d warnings witnessed in earlier spikes.\n3. **Domain Isolation**: Teams evolve realtime rules per bounded context without impacting others, reducing regression risk.\n4. **Resilient UX**: Automatic reconnection and selective refetch ensure operators see fresh data after transient outages.",
              "source": "adr/ADR-004-real-time-strategy.md"
            }
          ]
        }
      ]
    },
    {
      "category": "exports",
      "description": "Module export patterns",
      "conflicts": [
        {
          "issue": "Default vs named exports",
          "required_by": [
            {
              "line": 312,
              "keyword": "default export",
              "directive": "REQUIRED",
              "statement": "\u2705 Use named exports exclusively (no default exports)",
              "context": "\u2705 Enable RLS on all tables\n\u2705 Keep factories pure and stateless\n\u2705 Use named exports exclusively (no default exports)\n\n### DON'T (PT-1 Anti-Patterns):",
              "source": "system-prd/SERVICE_LAYER_ARCHITECTURE_DIAGRAM.md"
            },
            {
              "line": 312,
              "keyword": "named export",
              "directive": "REQUIRED",
              "statement": "\u2705 Use named exports exclusively (no default exports)",
              "context": "\u2705 Enable RLS on all tables\n\u2705 Keep factories pure and stateless\n\u2705 Use named exports exclusively (no default exports)\n\n### DON'T (PT-1 Anti-Patterns):",
              "source": "system-prd/SERVICE_LAYER_ARCHITECTURE_DIAGRAM.md"
            }
          ],
          "prohibited_by": [
            {
              "line": 324,
              "keyword": "named export",
              "directive": "PROHIBITED",
              "statement": "\u274c Mix default and named exports from service modules",
              "context": "\u274c Create deprecated class wrappers that delegate to functional services\n\u274c Leave methods undeclared in interfaces (must be complete)\n\u274c Mix default and named exports from service modules\n\u274c Add runtime validation in factory functions (use dev-only assertions)\n\u274c Create zero-value wrapper functions that just alias services",
              "source": "system-prd/SERVICE_LAYER_ARCHITECTURE_DIAGRAM.md"
            },
            {
              "line": 181,
              "keyword": "named export",
              "directive": "PROHIBITED",
              "statement": "- Ban mixing default and named exports from service modules; use named exports exclusively for consistency and traceability.",
              "context": "  - Ban duplicate/competing factory patterns (e.g., `createXService` + `createXServices` doing the same thing - violation in `services/compliance/index.ts`).\n  - Prohibit zero-value wrapper functions that merely alias existing service creators without adding functionality.\n  - Ban mixing default and named exports from service modules; use named exports exclusively for consistency and traceability.\n  - Prohibit runtime validation in service factory functions; move validation to development-only assertions or initialization-time checks.\n  - **Forbid `as any` type casting to bypass incomplete interfaces** (violation in `services/visit/index.ts:76`). If a method exists in implementation, it MUST be declared in the interface.",
              "source": "system-prd/CANONICAL_BLUEPRINT_MVP_PRD.md"
            },
            {
              "line": 181,
              "keyword": "named export",
              "directive": "PROHIBITED",
              "statement": "- Ban mixing default and named exports from service modules; use named exports exclusively for consistency and traceability.",
              "context": "  - Ban duplicate/competing factory patterns (e.g., `createXService` + `createXServices` doing the same thing - violation in `services/compliance/index.ts`).\n  - Prohibit zero-value wrapper functions that merely alias existing service creators without adding functionality.\n  - Ban mixing default and named exports from service modules; use named exports exclusively for consistency and traceability.\n  - Prohibit runtime validation in service factory functions; move validation to development-only assertions or initialization-time checks.\n  - **Forbid `as any` type casting to bypass incomplete interfaces** (violation in `services/visit/index.ts:76`). If a method exists in implementation, it MUST be declared in the interface.",
              "source": "system-prd/CANONICAL_BLUEPRINT_MVP_PRD.md"
            }
          ]
        }
      ]
    }
  ],
  "pattern_details": {
    "service_implementation": {
      "system-prd/SERVICE_LAYER_ARCHITECTURE_DIAGRAM.md": [
        {
          "line": 43,
          "keyword": "functional factories",
          "directive": "NEUTRAL",
          "statement": "SF[Functional Factories<br/>createXService()]",
          "context": "    %% Service Orchestration Layer\n    subgraph \"Service Orchestration\"\n        SF[Functional Factories<br/>createXService()]\n        OW[Operation Wrapper<br/>ServiceResult&lt;T&gt;]\n    end"
        },
        {
          "line": 300,
          "keyword": "functional factories",
          "directive": "REQUIRED",
          "statement": "\u2705 Use plain functional factories for service creation",
          "context": "### DO:\n\n\u2705 Use plain functional factories for service creation\n\u2705 Declare explicit interfaces for all services with complete type signatures\n\u2705 Type `supabase` parameter as `SupabaseClient<Database>` (never `any`)"
        },
        {
          "line": 28,
          "keyword": "factory function",
          "directive": "NEUTRAL",
          "statement": "- Runtime validation in factory functions",
          "context": "- Mixed default and named exports\n- Zero-value wrapper functions\n- Runtime validation in factory functions\n\n**Analysis Sources**: Player, Visit, Rating Slip, Casino, MTL, Compliance, Table Context services from PT-1"
        },
        {
          "line": 325,
          "keyword": "factory function",
          "directive": "PROHIBITED",
          "statement": "\u274c Add runtime validation in factory functions (use dev-only assertions)",
          "context": "\u274c Leave methods undeclared in interfaces (must be complete)\n\u274c Mix default and named exports from service modules\n\u274c Add runtime validation in factory functions (use dev-only assertions)\n\u274c Create zero-value wrapper functions that just alias services\n\u274c Put business logic in CRUD modules"
        },
        {
          "line": 17,
          "keyword": "class-based",
          "directive": "NEUTRAL",
          "statement": "- Class-based service abstractions (BaseService)",
          "context": "\n- Dual rating-slip implementation\n- Class-based service abstractions (BaseService)\n- Over-engineered ServiceFactory with internal caching/metrics\n- Deprecated class wrappers delegating to functional services"
        },
        {
          "line": 520,
          "keyword": "class-based",
          "directive": "PROHIBITED",
          "statement": "\u274c **NO** `services/base.service.ts` - No class-based abstractions",
          "context": "### Anti-Patterns to Avoid in Structure\n\n\u274c **NO** `services/base.service.ts` - No class-based abstractions\n\u274c **NO** `services/service.factory.ts` - No factory with caching/metrics\n\u274c **NO** `services/real-time/` - No global real-time managers"
        },
        {
          "line": 316,
          "keyword": "classes",
          "directive": "PROHIBITED",
          "statement": "\u274c Use class inheritance (BaseService, abstract classes)",
          "context": "### DON'T (PT-1 Anti-Patterns):\n\n\u274c Use class inheritance (BaseService, abstract classes)\n\u274c Create ServiceFactory with caching/metrics side effects\n\u274c Create duplicate/competing factory patterns (createXService + createXServices)"
        },
        {
          "line": 17,
          "keyword": "BaseService",
          "directive": "NEUTRAL",
          "statement": "- Class-based service abstractions (BaseService)",
          "context": "\n- Dual rating-slip implementation\n- Class-based service abstractions (BaseService)\n- Over-engineered ServiceFactory with internal caching/metrics\n- Deprecated class wrappers delegating to functional services"
        },
        {
          "line": 194,
          "keyword": "BaseService",
          "directive": "NEUTRAL",
          "statement": "// NO: class BaseService { ... }",
          "context": "\n// \u274c ANTI-PATTERNS TO AVOID (from PT-1 analysis):\n// NO: class BaseService { ... }\n// NO: ServiceFactory.getInstance().getService('player')\n// NO: export type PlayerService = ReturnType<typeof createPlayerService>"
        },
        {
          "line": 316,
          "keyword": "BaseService",
          "directive": "PROHIBITED",
          "statement": "\u274c Use class inheritance (BaseService, abstract classes)",
          "context": "### DON'T (PT-1 Anti-Patterns):\n\n\u274c Use class inheritance (BaseService, abstract classes)\n\u274c Create ServiceFactory with caching/metrics side effects\n\u274c Create duplicate/competing factory patterns (createXService + createXServices)"
        },
        {
          "line": 18,
          "keyword": "ServiceFactory",
          "directive": "NEUTRAL",
          "statement": "- Over-engineered ServiceFactory with internal caching/metrics",
          "context": "- Dual rating-slip implementation\n- Class-based service abstractions (BaseService)\n- Over-engineered ServiceFactory with internal caching/metrics\n- Deprecated class wrappers delegating to functional services\n- Duplicate/competing factory patterns"
        },
        {
          "line": 195,
          "keyword": "ServiceFactory",
          "directive": "NEUTRAL",
          "statement": "// NO: ServiceFactory.getInstance().getService('player')",
          "context": "// \u274c ANTI-PATTERNS TO AVOID (from PT-1 analysis):\n// NO: class BaseService { ... }\n// NO: ServiceFactory.getInstance().getService('player')\n// NO: export type PlayerService = ReturnType<typeof createPlayerService>\n// NO: createPlayerService(supabase: any) - must type as SupabaseClient<Database>"
        },
        {
          "line": 317,
          "keyword": "ServiceFactory",
          "directive": "PROHIBITED",
          "statement": "\u274c Create ServiceFactory with caching/metrics side effects",
          "context": "\n\u274c Use class inheritance (BaseService, abstract classes)\n\u274c Create ServiceFactory with caching/metrics side effects\n\u274c Create duplicate/competing factory patterns (createXService + createXServices)\n\u274c Use `ReturnType<typeof createXService>` for type inference"
        }
      ],
      "system-prd/CANONICAL_BLUEPRINT_MVP_PRD.md": [
        {
          "line": 45,
          "keyword": "factory function",
          "directive": "REQUIRED",
          "statement": "- **Explicit Interface Contracts**: Every service factory MUST declare an explicit interface defining all public methods with complete type signatures. Return this interface from the factory function.",
          "context": "#### Type System Standards\n\n- **Explicit Interface Contracts**: Every service factory MUST declare an explicit interface defining all public methods with complete type signatures. Return this interface from the factory function.\n\n  ```typescript"
        },
        {
          "line": 63,
          "keyword": "factory function",
          "directive": "PROHIBITED",
          "statement": "- **Typed Dependencies**: Factory functions MUST type the `supabase` parameter as `SupabaseClient<Database>`. Never use `any`.",
          "context": "\n- **Ban `ReturnType` Inference**: Never use `ReturnType<typeof createXService>` for exported service types. Always export the explicit interface: `export type PlayerService = IPlayerService`.\n- **Typed Dependencies**: Factory functions MUST type the `supabase` parameter as `SupabaseClient<Database>`. Never use `any`.\n- **No Object Spread Without Types**: When composing services via object spread, the factory MUST declare an explicit return type interface that describes the final shape. This prevents silent method overwrites.\n"
        },
        {
          "line": 86,
          "keyword": "factory function",
          "directive": "NEUTRAL",
          "statement": "- **Consistent Export Pattern**: Export both the factory function and the service type. Name them consistently: `createXService` \u2192 `XService` interface \u2192 `export type XService`.",
          "context": "  ```\n\n- **Consistent Export Pattern**: Export both the factory function and the service type. Name them consistently: `createXService` \u2192 `XService` interface \u2192 `export type XService`.\n\n#### Service Architecture"
        },
        {
          "line": 177,
          "keyword": "factory function",
          "directive": "NEUTRAL",
          "statement": "- Forbid `supabase: any` parameters in service factory functions (violations in `services/casino/index.ts`, `services/mtl/index.ts`).",
          "context": "  - Ban `ReturnType<typeof createXService>` patterns in service exports (violations in `services/table-context/index.ts`, `services/rating-slip/index.ts`, `services/compliance/index.ts`).\n  - Require explicit interface definitions for all service factories with typed return signatures.\n  - Forbid `supabase: any` parameters in service factory functions (violations in `services/casino/index.ts`, `services/mtl/index.ts`).\n  - Enforce explicit return type interfaces when using object spread composition to prevent silent method overwrites.\n  - Ban duplicate/competing factory patterns (e.g., `createXService` + `createXServices` doing the same thing - violation in `services/compliance/index.ts`)."
        },
        {
          "line": 182,
          "keyword": "factory function",
          "directive": "NEUTRAL",
          "statement": "- Prohibit runtime validation in service factory functions; move validation to development-only assertions or initialization-time checks.",
          "context": "  - Prohibit zero-value wrapper functions that merely alias existing service creators without adding functionality.\n  - Ban mixing default and named exports from service modules; use named exports exclusively for consistency and traceability.\n  - Prohibit runtime validation in service factory functions; move validation to development-only assertions or initialization-time checks.\n  - **Forbid `as any` type casting to bypass incomplete interfaces** (violation in `services/visit/index.ts:76`). If a method exists in implementation, it MUST be declared in the interface.\n  - **Remove all deprecated class wrappers** marked `@deprecated` that delegate to functional services (violation: `VisitService` class in `services/visit/index.ts`). Delete deprecated code instead of maintaining dual APIs."
        },
        {
          "line": 93,
          "keyword": "class-based",
          "directive": "NEUTRAL",
          "statement": "- Drop class-based base abstractions and the over-engineered `ServiceFactory`; V2 services are plain factories or functional modules without internal caching/metrics side effects (`services/base.service.ts`, `services/service.factory.ts`). Dependency injection stays explicit at the call site.",
          "context": "- Centralize helpers instead of re-declaring them. `ServiceResult`, `generateRequestId`, and other utilities live in `services/shared` so domain modules do not recreate their own success/error builders.\n- All domain logic must compose from canonical database types; prohibit hand-written table contracts. Use DTOs in `types/domains/*` for inputs/outputs and map them explicitly.\n- Drop class-based base abstractions and the over-engineered `ServiceFactory`; V2 services are plain factories or functional modules without internal caching/metrics side effects (`services/base.service.ts`, `services/service.factory.ts`). Dependency injection stays explicit at the call site.\n- Define a typed error catalogue per domain (for example, `enum PlayerServiceError { DuplicateEmail, NotFound, ValidationFailed }`) and return those codes inside the `ServiceResult`. Map the enum to HTTP responses and UI messaging once so consumers never parse strings.\n- Preserve layering: CRUD modules handle persistence, `business.ts` orchestrates workflows, `transforms.ts` keeps mapping logic, and `ui/*` files expose view adapters. Document when data crosses between layers and add unit tests per public function."
        },
        {
          "line": 93,
          "keyword": "ServiceFactory",
          "directive": "NEUTRAL",
          "statement": "- Drop class-based base abstractions and the over-engineered `ServiceFactory`; V2 services are plain factories or functional modules without internal caching/metrics side effects (`services/base.service.ts`, `services/service.factory.ts`). Dependency injection stays explicit at the call site.",
          "context": "- Centralize helpers instead of re-declaring them. `ServiceResult`, `generateRequestId`, and other utilities live in `services/shared` so domain modules do not recreate their own success/error builders.\n- All domain logic must compose from canonical database types; prohibit hand-written table contracts. Use DTOs in `types/domains/*` for inputs/outputs and map them explicitly.\n- Drop class-based base abstractions and the over-engineered `ServiceFactory`; V2 services are plain factories or functional modules without internal caching/metrics side effects (`services/base.service.ts`, `services/service.factory.ts`). Dependency injection stays explicit at the call site.\n- Define a typed error catalogue per domain (for example, `enum PlayerServiceError { DuplicateEmail, NotFound, ValidationFailed }`) and return those codes inside the `ServiceResult`. Map the enum to HTTP responses and UI messaging once so consumers never parse strings.\n- Preserve layering: CRUD modules handle persistence, `business.ts` orchestrates workflows, `transforms.ts` keeps mapping logic, and `ui/*` files expose view adapters. Document when data crosses between layers and add unit tests per public function."
        },
        {
          "line": 187,
          "keyword": "ServiceFactory",
          "directive": "PROHIBITED",
          "statement": "- Ban service-layer factories that cache or mutate global state (e.g., `ServiceFactory` performance caches); service creation stays pure and request-scoped.",
          "context": "  - **Interfaces must be complete**: Every public method in the service implementation must have a corresponding type signature in the interface. No silent additions via type casting.\n- Ban global real-time managers (connection pools, optimistic/offline singletons); enforce hook-scoped subscriptions with automated tests.\n- Ban service-layer factories that cache or mutate global state (e.g., `ServiceFactory` performance caches); service creation stays pure and request-scoped.\n- Ban bulk library imports (HeroUI/Lucide) and dev console logging in production paths.\n- **Schema Consistency: Enforce UUID Primary Keys Universally**:"
        }
      ],
      "patterns/SERVICE_TEMPLATE.md": [
        {
          "line": 23,
          "keyword": "functional factories",
          "directive": "NEUTRAL",
          "statement": "| `class BaseService` | Functional factories only |",
          "context": "| `services/x/types.ts` | `types/domains/x/index.ts` |\n| `@deprecated` code | Delete, don't maintain dual APIs |\n| `class BaseService` | Functional factories only |\n| `console.*` in operations | Structured logging/monitoring |\n"
        },
        {
          "line": 23,
          "keyword": "BaseService",
          "directive": "NEUTRAL",
          "statement": "| `class BaseService` | Functional factories only |",
          "context": "| `services/x/types.ts` | `types/domains/x/index.ts` |\n| `@deprecated` code | Delete, don't maintain dual APIs |\n| `class BaseService` | Functional factories only |\n| `console.*` in operations | Structured logging/monitoring |\n"
        }
      ],
      "patterns/controlled-hybrid-refactor-model.md": [
        {
          "line": 33,
          "keyword": "BaseService",
          "directive": "PROHIBITED",
          "statement": "- \u274c `class BaseService` abstractions",
          "context": "- \u274c `services/x/types.ts` files\n- \u274c `@deprecated` code\n- \u274c `class BaseService` abstractions\n\nAction: If PT-1 code contains ANY \u2192 **rewrite using template**, don't import."
        }
      ],
      "adr/ADR-005-integrity-enforcement.md": [
        {
          "line": 53,
          "keyword": "classes",
          "directive": "NEUTRAL",
          "statement": "**Defense in Depth**: Each layer catches different classes of violations:",
          "context": "### Why Four Layers?\n\n**Defense in Depth**: Each layer catches different classes of violations:\n\n1. **IDE** - Catches 80% of issues immediately during development"
        },
        {
          "line": 77,
          "keyword": "classes",
          "directive": "NEUTRAL",
          "statement": "- Prevents entire classes of bugs",
          "context": "- Immediate feedback during development\n- Documents correct schema in executable code\n- Prevents entire classes of bugs\n\n### Why Mandatory CI/CD Step?"
        }
      ]
    },
    "type_inference": {
      "system-prd/SERVICE_LAYER_ARCHITECTURE_DIAGRAM.md": [
        {
          "line": 9,
          "keyword": "ReturnType",
          "directive": "NEUTRAL",
          "statement": "- `ReturnType<typeof createXService>` inference instead of explicit interfaces",
          "context": "### Type System Anti-Patterns (Eliminated)\n\n- `ReturnType<typeof createXService>` inference instead of explicit interfaces\n- `supabase: any` parameters losing type safety\n- Incomplete interfaces requiring `as any` casting"
        },
        {
          "line": 190,
          "keyword": "ReturnType",
          "directive": "REQUIRED",
          "statement": "// \u2705 CORRECT: Export explicit type, not ReturnType inference",
          "context": "}\n\n// \u2705 CORRECT: Export explicit type, not ReturnType inference\nexport type PlayerServiceType = PlayerService;\n"
        },
        {
          "line": 196,
          "keyword": "ReturnType",
          "directive": "NEUTRAL",
          "statement": "// NO: export type PlayerService = ReturnType<typeof createPlayerService>",
          "context": "// NO: class BaseService { ... }\n// NO: ServiceFactory.getInstance().getService('player')\n// NO: export type PlayerService = ReturnType<typeof createPlayerService>\n// NO: createPlayerService(supabase: any) - must type as SupabaseClient<Database>\n// NO: return { ...(service as any).hiddenMethod } - incomplete interfaces"
        },
        {
          "line": 303,
          "keyword": "ReturnType",
          "directive": "REQUIRED",
          "statement": "\u2705 Export explicit types, not `ReturnType<typeof createXService>`",
          "context": "\u2705 Declare explicit interfaces for all services with complete type signatures\n\u2705 Type `supabase` parameter as `SupabaseClient<Database>` (never `any`)\n\u2705 Export explicit types, not `ReturnType<typeof createXService>`\n\u2705 Compose services from specialized modules with typed spread\n\u2705 Return `ServiceResult<T>` from all operations"
        },
        {
          "line": 319,
          "keyword": "ReturnType",
          "directive": "PROHIBITED",
          "statement": "\u274c Use `ReturnType<typeof createXService>` for type inference",
          "context": "\u274c Create ServiceFactory with caching/metrics side effects\n\u274c Create duplicate/competing factory patterns (createXService + createXServices)\n\u274c Use `ReturnType<typeof createXService>` for type inference\n\u274c Type parameters as `any` (violations: Casino, MTL services)\n\u274c Use `as any` type casting to bypass incomplete interfaces (violation: Visit service)"
        },
        {
          "line": 9,
          "keyword": "explicit interface",
          "directive": "NEUTRAL",
          "statement": "- `ReturnType<typeof createXService>` inference instead of explicit interfaces",
          "context": "### Type System Anti-Patterns (Eliminated)\n\n- `ReturnType<typeof createXService>` inference instead of explicit interfaces\n- `supabase: any` parameters losing type safety\n- Incomplete interfaces requiring `as any` casting"
        },
        {
          "line": 163,
          "keyword": "explicit interface",
          "directive": "NEUTRAL",
          "statement": "### 1. Functional Factory Pattern with Explicit Interfaces",
          "context": "## Key Architectural Patterns\n\n### 1. Functional Factory Pattern with Explicit Interfaces\n\n```typescript"
        },
        {
          "line": 166,
          "keyword": "explicit interface",
          "directive": "REQUIRED",
          "statement": "// \u2705 CORRECT: Explicit interface with complete type signatures",
          "context": "\n```typescript\n// \u2705 CORRECT: Explicit interface with complete type signatures\nexport interface PlayerService {\n  getById(id: string): Promise<ServiceResult<PlayerDTO>>;"
        },
        {
          "line": 174,
          "keyword": "explicit interface",
          "directive": "REQUIRED",
          "statement": "// \u2705 CORRECT: Typed factory returning explicit interface",
          "context": "}\n\n// \u2705 CORRECT: Typed factory returning explicit interface\nexport function createPlayerService(\n  supabase: SupabaseClient<Database>,"
        },
        {
          "line": 301,
          "keyword": "explicit interface",
          "directive": "REQUIRED",
          "statement": "\u2705 Declare explicit interfaces for all services with complete type signatures",
          "context": "\n\u2705 Use plain functional factories for service creation\n\u2705 Declare explicit interfaces for all services with complete type signatures\n\u2705 Type `supabase` parameter as `SupabaseClient<Database>` (never `any`)\n\u2705 Export explicit types, not `ReturnType<typeof createXService>`"
        },
        {
          "line": 452,
          "keyword": "explicit interface",
          "directive": "NEUTRAL",
          "statement": "/* explicit interface */",
          "context": "```typescript\nexport interface PlayerService {\n  /* explicit interface */\n}\nexport function createPlayerService("
        },
        {
          "line": 190,
          "keyword": "type inference",
          "directive": "REQUIRED",
          "statement": "// \u2705 CORRECT: Export explicit type, not ReturnType inference",
          "context": "}\n\n// \u2705 CORRECT: Export explicit type, not ReturnType inference\nexport type PlayerServiceType = PlayerService;\n"
        },
        {
          "line": 319,
          "keyword": "type inference",
          "directive": "PROHIBITED",
          "statement": "\u274c Use `ReturnType<typeof createXService>` for type inference",
          "context": "\u274c Create ServiceFactory with caching/metrics side effects\n\u274c Create duplicate/competing factory patterns (createXService + createXServices)\n\u274c Use `ReturnType<typeof createXService>` for type inference\n\u274c Type parameters as `any` (violations: Casino, MTL services)\n\u274c Use `as any` type casting to bypass incomplete interfaces (violation: Visit service)"
        }
      ],
      "system-prd/CANONICAL_BLUEPRINT_MVP_PRD.md": [
        {
          "line": 62,
          "keyword": "ReturnType",
          "directive": "PROHIBITED",
          "statement": "- **Ban `ReturnType` Inference**: Never use `ReturnType<typeof createXService>` for exported service types. Always export the explicit interface: `export type PlayerService = IPlayerService`.",
          "context": "  ```\n\n- **Ban `ReturnType` Inference**: Never use `ReturnType<typeof createXService>` for exported service types. Always export the explicit interface: `export type PlayerService = IPlayerService`.\n- **Typed Dependencies**: Factory functions MUST type the `supabase` parameter as `SupabaseClient<Database>`. Never use `any`.\n- **No Object Spread Without Types**: When composing services via object spread, the factory MUST declare an explicit return type interface that describes the final shape. This prevents silent method overwrites."
        },
        {
          "line": 62,
          "keyword": "ReturnType",
          "directive": "PROHIBITED",
          "statement": "- **Ban `ReturnType` Inference**: Never use `ReturnType<typeof createXService>` for exported service types. Always export the explicit interface: `export type PlayerService = IPlayerService`.",
          "context": "  ```\n\n- **Ban `ReturnType` Inference**: Never use `ReturnType<typeof createXService>` for exported service types. Always export the explicit interface: `export type PlayerService = IPlayerService`.\n- **Typed Dependencies**: Factory functions MUST type the `supabase` parameter as `SupabaseClient<Database>`. Never use `any`.\n- **No Object Spread Without Types**: When composing services via object spread, the factory MUST declare an explicit return type interface that describes the final shape. This prevents silent method overwrites."
        },
        {
          "line": 175,
          "keyword": "ReturnType",
          "directive": "PROHIBITED",
          "statement": "- Ban `ReturnType<typeof createXService>` patterns in service exports (violations in `services/table-context/index.ts`, `services/rating-slip/index.ts`, `services/compliance/index.ts`).",
          "context": "- Block `Database = any` shims, manual table redefinitions, and intersection-based schema rebuilds in type modules.\n- **Service Layer Type Enforcement**:\n  - Ban `ReturnType<typeof createXService>` patterns in service exports (violations in `services/table-context/index.ts`, `services/rating-slip/index.ts`, `services/compliance/index.ts`).\n  - Require explicit interface definitions for all service factories with typed return signatures.\n  - Forbid `supabase: any` parameters in service factory functions (violations in `services/casino/index.ts`, `services/mtl/index.ts`)."
        },
        {
          "line": 45,
          "keyword": "explicit interface",
          "directive": "REQUIRED",
          "statement": "- **Explicit Interface Contracts**: Every service factory MUST declare an explicit interface defining all public methods with complete type signatures. Return this interface from the factory function.",
          "context": "#### Type System Standards\n\n- **Explicit Interface Contracts**: Every service factory MUST declare an explicit interface defining all public methods with complete type signatures. Return this interface from the factory function.\n\n  ```typescript"
        },
        {
          "line": 45,
          "keyword": "explicit interface",
          "directive": "REQUIRED",
          "statement": "- **Explicit Interface Contracts**: Every service factory MUST declare an explicit interface defining all public methods with complete type signatures. Return this interface from the factory function.",
          "context": "#### Type System Standards\n\n- **Explicit Interface Contracts**: Every service factory MUST declare an explicit interface defining all public methods with complete type signatures. Return this interface from the factory function.\n\n  ```typescript"
        },
        {
          "line": 62,
          "keyword": "explicit interface",
          "directive": "PROHIBITED",
          "statement": "- **Ban `ReturnType` Inference**: Never use `ReturnType<typeof createXService>` for exported service types. Always export the explicit interface: `export type PlayerService = IPlayerService`.",
          "context": "  ```\n\n- **Ban `ReturnType` Inference**: Never use `ReturnType<typeof createXService>` for exported service types. Always export the explicit interface: `export type PlayerService = IPlayerService`.\n- **Typed Dependencies**: Factory functions MUST type the `supabase` parameter as `SupabaseClient<Database>`. Never use `any`.\n- **No Object Spread Without Types**: When composing services via object spread, the factory MUST declare an explicit return type interface that describes the final shape. This prevents silent method overwrites."
        },
        {
          "line": 176,
          "keyword": "explicit interface",
          "directive": "REQUIRED",
          "statement": "- Require explicit interface definitions for all service factories with typed return signatures.",
          "context": "- **Service Layer Type Enforcement**:\n  - Ban `ReturnType<typeof createXService>` patterns in service exports (violations in `services/table-context/index.ts`, `services/rating-slip/index.ts`, `services/compliance/index.ts`).\n  - Require explicit interface definitions for all service factories with typed return signatures.\n  - Forbid `supabase: any` parameters in service factory functions (violations in `services/casino/index.ts`, `services/mtl/index.ts`).\n  - Enforce explicit return type interfaces when using object spread composition to prevent silent method overwrites."
        }
      ],
      "patterns/SERVER_ACTIONS_ARCHITECTURE.md": [
        {
          "line": 192,
          "keyword": "explicit interface",
          "directive": "NEUTRAL",
          "statement": "- Explicit interfaces for all actions",
          "context": "- Full TypeScript support throughout\n- `ServiceResult<T>` standardization\n- Explicit interfaces for all actions\n\n---"
        }
      ],
      "patterns/SERVICE_TEMPLATE.md": [
        {
          "line": 18,
          "keyword": "ReturnType",
          "directive": "NEUTRAL",
          "statement": "| `ReturnType<typeof createXService>` | Explicit `interface XService` |",
          "context": "| \u274c Anti-Pattern | \u2705 Correct Pattern |\n|----------------|-------------------|\n| `ReturnType<typeof createXService>` | Explicit `interface XService` |\n| `supabase: any` | `supabase: SupabaseClient<Database>` |\n| `import from '@/types/database-rebuilt'` | `Database['public']['Tables']['x']` |"
        },
        {
          "line": 305,
          "keyword": "ReturnType",
          "directive": "REQUIRED",
          "statement": "// \u2705 STEP 1: Explicit interface - NOT ReturnType inference",
          "context": "import type { ServiceResult } from \"../shared/types\";\n\n// \u2705 STEP 1: Explicit interface - NOT ReturnType inference\nexport interface XService {\n  create(data: XCreateDTO): Promise<ServiceResult<XDTO>>;"
        },
        {
          "line": 324,
          "keyword": "ReturnType",
          "directive": "REQUIRED",
          "statement": "// \u2705 STEP 3: Export explicit type (not ReturnType)",
          "context": "}\n\n// \u2705 STEP 3: Export explicit type (not ReturnType)\nexport type XServiceType = XService;\n"
        },
        {
          "line": 353,
          "keyword": "ReturnType",
          "directive": "NEUTRAL",
          "statement": "let xService: ReturnType<typeof createXService>;",
          "context": "describe(\"X Service - CRUD Operations\", () => {\n  let supabase: SupabaseClient<Database>;\n  let xService: ReturnType<typeof createXService>;\n\n  beforeEach(() => {"
        },
        {
          "line": 542,
          "keyword": "ReturnType",
          "directive": "NEUTRAL",
          "statement": "- [ ] No `ReturnType` inference in main exports",
          "context": "### End-of-Week Audit\n\n- [ ] No `ReturnType` inference in main exports\n- [ ] No `any` typed parameters\n- [ ] No `@/types/database-rebuilt` imports"
        },
        {
          "line": 585,
          "keyword": "ReturnType",
          "directive": "NEUTRAL",
          "statement": "- `ReturnType` inferred interfaces",
          "context": "- `base.service.ts` class abstractions\n- `@/types/database-rebuilt` manual types\n- `ReturnType` inferred interfaces\n- Deprecated wrapper functions\n- Global state/singletons"
        },
        {
          "line": 40,
          "keyword": "explicit interface",
          "directive": "NEUTRAL",
          "statement": "\u251c\u2500\u2500 index.ts                    # Factory + explicit interface",
          "context": "\u2502\n\u2514\u2500\u2500 {domain}/                        # \u2705 Domain service\n    \u251c\u2500\u2500 index.ts                    # Factory + explicit interface\n    \u251c\u2500\u2500 crud.ts                     # CRUD operations module\n    \u251c\u2500\u2500 business.ts                 # Business logic (if needed)"
        },
        {
          "line": 296,
          "keyword": "explicit interface",
          "directive": "OPTIONAL",
          "statement": "* Following PT-2 canonical service architecture with explicit interfaces",
          "context": "/**\n * {Domain} Service Factory\n * Following PT-2 canonical service architecture with explicit interfaces\n */\n"
        },
        {
          "line": 305,
          "keyword": "explicit interface",
          "directive": "REQUIRED",
          "statement": "// \u2705 STEP 1: Explicit interface - NOT ReturnType inference",
          "context": "import type { ServiceResult } from \"../shared/types\";\n\n// \u2705 STEP 1: Explicit interface - NOT ReturnType inference\nexport interface XService {\n  create(data: XCreateDTO): Promise<ServiceResult<XDTO>>;"
        },
        {
          "line": 312,
          "keyword": "explicit interface",
          "directive": "REQUIRED",
          "statement": "// \u2705 STEP 2: Typed factory with explicit interface return",
          "context": "}\n\n// \u2705 STEP 2: Typed factory with explicit interface return\nexport function createXService(\n  supabase: SupabaseClient<Database>,"
        },
        {
          "line": 305,
          "keyword": "type inference",
          "directive": "REQUIRED",
          "statement": "// \u2705 STEP 1: Explicit interface - NOT ReturnType inference",
          "context": "import type { ServiceResult } from \"../shared/types\";\n\n// \u2705 STEP 1: Explicit interface - NOT ReturnType inference\nexport interface XService {\n  create(data: XCreateDTO): Promise<ServiceResult<XDTO>>;"
        }
      ],
      "patterns/SERVICE_TEMPLATE_QUICK.md": [
        {
          "line": 12,
          "keyword": "ReturnType",
          "directive": "NEUTRAL",
          "statement": "| `ReturnType<typeof createXService>` | Explicit `interface XService` |",
          "context": "| \u274c Never | \u2705 Always |\n|---------|----------|\n| `ReturnType<typeof createXService>` | Explicit `interface XService` |\n| `supabase: any` | `supabase: SupabaseClient<Database>` |\n| `@/types/database-rebuilt` | `Database['public']['Tables']['x']` |"
        },
        {
          "line": 138,
          "keyword": "ReturnType",
          "directive": "REQUIRED",
          "statement": "// \u2705 STEP 3: Export type (NOT ReturnType)",
          "context": "}\n\n// \u2705 STEP 3: Export type (NOT ReturnType)\nexport type XServiceType = XService;\nexport type { XCreateDTO, XDTO };"
        },
        {
          "line": 174,
          "keyword": "ReturnType",
          "directive": "NEUTRAL",
          "statement": "- [ ] No `ReturnType` in main exports",
          "context": "**Before committing**, check:\n\n- [ ] No `ReturnType` in main exports\n- [ ] No `any` parameters\n- [ ] No `database-rebuilt` imports"
        },
        {
          "line": 121,
          "keyword": "explicit interface",
          "directive": "NEUTRAL",
          "statement": "### 4. Create Factory with Explicit Interface",
          "context": "```\n\n### 4. Create Factory with Explicit Interface\n\n```typescript"
        }
      ],
      "patterns/controlled-hybrid-refactor-model.md": [
        {
          "line": 28,
          "keyword": "ReturnType",
          "directive": "PROHIBITED",
          "statement": "- \u274c `ReturnType<typeof createXService>`",
          "context": "\nViolations:\n- \u274c `ReturnType<typeof createXService>`\n- \u274c `supabase: any`\n- \u274c `@/types/database-rebuilt` imports"
        },
        {
          "line": 43,
          "keyword": "ReturnType",
          "directive": "NEUTRAL",
          "statement": "**After each vertical slice, run the same audit checklist to ensure you didn't re-introduce legacy imports or ReturnType inference.**",
          "context": "\n### 4. End-of-Week Audit\n**After each vertical slice, run the same audit checklist to ensure you didn't re-introduce legacy imports or ReturnType inference.**\n\nSee: [SERVICE_TEMPLATE.md \u00a7 End-of-Week Audit](./SERVICE_TEMPLATE.md#end-of-week-audit)"
        },
        {
          "line": 84,
          "keyword": "explicit interface",
          "directive": "OPTIONAL",
          "statement": "- Rewrite using canonical Database types + explicit interfaces",
          "context": "- Mine PT-1's `search.ts` (multi-word search, relevance scoring)\n- Mine PT-1's `queries.ts` (JOIN patterns, active player queries)\n- Rewrite using canonical Database types + explicit interfaces\n- Test all borrowed patterns\n"
        },
        {
          "line": 43,
          "keyword": "type inference",
          "directive": "NEUTRAL",
          "statement": "**After each vertical slice, run the same audit checklist to ensure you didn't re-introduce legacy imports or ReturnType inference.**",
          "context": "\n### 4. End-of-Week Audit\n**After each vertical slice, run the same audit checklist to ensure you didn't re-introduce legacy imports or ReturnType inference.**\n\nSee: [SERVICE_TEMPLATE.md \u00a7 End-of-Week Audit](./SERVICE_TEMPLATE.md#end-of-week-audit)"
        }
      ],
      "patterns/BALANCED_ARCHITECTURE_QUICK.md": [
        {
          "line": 256,
          "keyword": "ReturnType",
          "directive": "PROHIBITED",
          "statement": "\u274c **Explicit interfaces** - `interface XService`, NOT `ReturnType`",
          "context": "\n### Never Compromise (Non-Negotiable)\n\u274c **Explicit interfaces** - `interface XService`, NOT `ReturnType`\n\u274c **Typed dependencies** - `supabase: SupabaseClient<Database>`, NOT `any`\n\u274c **ServiceResult pattern** - Consistent error handling"
        },
        {
          "line": 256,
          "keyword": "explicit interface",
          "directive": "PROHIBITED",
          "statement": "\u274c **Explicit interfaces** - `interface XService`, NOT `ReturnType`",
          "context": "\n### Never Compromise (Non-Negotiable)\n\u274c **Explicit interfaces** - `interface XService`, NOT `ReturnType`\n\u274c **Typed dependencies** - `supabase: SupabaseClient<Database>`, NOT `any`\n\u274c **ServiceResult pattern** - Consistent error handling"
        },
        {
          "line": 384,
          "keyword": "explicit interface",
          "directive": "NEUTRAL",
          "statement": "- [ ] No PRD violations (explicit interfaces, typed params)",
          "context": "- [ ] Tests written alongside code (TDD)\n- [ ] Following SERVICE_TEMPLATE_QUICK patterns\n- [ ] No PRD violations (explicit interfaces, typed params)\n- [ ] Coverage >80% maintained\n"
        }
      ],
      "adr/NEXT_STEPS_REPORT.md": [
        {
          "line": 181,
          "keyword": "ReturnType",
          "directive": "REQUIRED",
          "statement": "- \u2705 All services have explicit interfaces (no `ReturnType`)",
          "context": "\n**End-of-Phase-2 Audit**:\n- \u2705 All services have explicit interfaces (no `ReturnType`)\n- \u2705 All services use `SupabaseClient<Database>` (no `any`)\n- \u2705 Zero PRD violations (ESLint + manual review)"
        },
        {
          "line": 181,
          "keyword": "explicit interface",
          "directive": "REQUIRED",
          "statement": "- \u2705 All services have explicit interfaces (no `ReturnType`)",
          "context": "\n**End-of-Phase-2 Audit**:\n- \u2705 All services have explicit interfaces (no `ReturnType`)\n- \u2705 All services use `SupabaseClient<Database>` (no `any`)\n- \u2705 Zero PRD violations (ESLint + manual review)"
        },
        {
          "line": 216,
          "keyword": "explicit interface",
          "directive": "REQUIRED",
          "statement": "\u2705 Service layer complete with explicit interfaces (7/8 services, 87.5%)",
          "context": "\n### Critical Blockers Resolved by Phase 2\n\u2705 Service layer complete with explicit interfaces (7/8 services, 87.5%)\n\u2705 ServiceResult pattern for error handling\n\u2705 Typed Supabase clients"
        },
        {
          "line": 760,
          "keyword": "explicit interface",
          "directive": "NEUTRAL",
          "statement": "- [ ] Create `services/mtl/index.ts` with explicit interface",
          "context": "\n### Day 1 (Today): MTL Service CRUD\n- [ ] Create `services/mtl/index.ts` with explicit interface\n- [ ] Implement `services/mtl/crud.ts` (create, getById, update, delete)\n- [ ] Create `__tests__/services/mtl/mtl-service.test.ts`"
        }
      ]
    },
    "supabase_client": {
      "system-prd/SERVICE_LAYER_ARCHITECTURE_DIAGRAM.md": [
        {
          "line": 176,
          "keyword": "SupabaseClient",
          "directive": "NEUTRAL",
          "statement": "supabase: SupabaseClient<Database>,",
          "context": "// \u2705 CORRECT: Typed factory returning explicit interface\nexport function createPlayerService(\n  supabase: SupabaseClient<Database>,\n): PlayerService {\n  const crudService = createPlayerCrudService(supabase);"
        },
        {
          "line": 197,
          "keyword": "SupabaseClient",
          "directive": "REQUIRED",
          "statement": "// NO: createPlayerService(supabase: any) - must type as SupabaseClient<Database>",
          "context": "// NO: ServiceFactory.getInstance().getService('player')\n// NO: export type PlayerService = ReturnType<typeof createPlayerService>\n// NO: createPlayerService(supabase: any) - must type as SupabaseClient<Database>\n// NO: return { ...(service as any).hiddenMethod } - incomplete interfaces\n// NO: @deprecated class wrappers that delegate to functional services"
        },
        {
          "line": 302,
          "keyword": "SupabaseClient",
          "directive": "PROHIBITED",
          "statement": "\u2705 Type `supabase` parameter as `SupabaseClient<Database>` (never `any`)",
          "context": "\u2705 Use plain functional factories for service creation\n\u2705 Declare explicit interfaces for all services with complete type signatures\n\u2705 Type `supabase` parameter as `SupabaseClient<Database>` (never `any`)\n\u2705 Export explicit types, not `ReturnType<typeof createXService>`\n\u2705 Compose services from specialized modules with typed spread"
        },
        {
          "line": 455,
          "keyword": "SupabaseClient",
          "directive": "NEUTRAL",
          "statement": "supabase: SupabaseClient<Database>,",
          "context": "}\nexport function createPlayerService(\n  supabase: SupabaseClient<Database>,\n): PlayerService;\nexport type PlayerServiceType = PlayerService;"
        },
        {
          "line": 463,
          "keyword": "SupabaseClient",
          "directive": "NEUTRAL",
          "statement": "export function createPlayerCrudService(supabase: SupabaseClient<Database>) {",
          "context": "\n```typescript\nexport function createPlayerCrudService(supabase: SupabaseClient<Database>) {\n  return {\n    getById: async (id: string) => executeOperation(...),"
        },
        {
          "line": 476,
          "keyword": "SupabaseClient",
          "directive": "NEUTRAL",
          "statement": "export function createPlayerBusinessService(supabase: SupabaseClient<Database>) {",
          "context": "\n```typescript\nexport function createPlayerBusinessService(supabase: SupabaseClient<Database>) {\n  return {\n    activatePlayer: async (id: string) => executeOperation(...),"
        },
        {
          "line": 488,
          "keyword": "SupabaseClient",
          "directive": "NEUTRAL",
          "statement": "export function createPlayerQueriesService(supabase: SupabaseClient<Database>) {",
          "context": "\n```typescript\nexport function createPlayerQueriesService(supabase: SupabaseClient<Database>) {\n  return {\n    searchPlayers: async (query: string) => executeOperation(...),"
        },
        {
          "line": 10,
          "keyword": "any",
          "directive": "NEUTRAL",
          "statement": "- `supabase: any` parameters losing type safety",
          "context": "\n- `ReturnType<typeof createXService>` inference instead of explicit interfaces\n- `supabase: any` parameters losing type safety\n- Incomplete interfaces requiring `as any` casting\n- Object spread composition without type guards"
        },
        {
          "line": 11,
          "keyword": "any",
          "directive": "NEUTRAL",
          "statement": "- Incomplete interfaces requiring `as any` casting",
          "context": "- `ReturnType<typeof createXService>` inference instead of explicit interfaces\n- `supabase: any` parameters losing type safety\n- Incomplete interfaces requiring `as any` casting\n- Object spread composition without type guards\n"
        },
        {
          "line": 197,
          "keyword": "any",
          "directive": "REQUIRED",
          "statement": "// NO: createPlayerService(supabase: any) - must type as SupabaseClient<Database>",
          "context": "// NO: ServiceFactory.getInstance().getService('player')\n// NO: export type PlayerService = ReturnType<typeof createPlayerService>\n// NO: createPlayerService(supabase: any) - must type as SupabaseClient<Database>\n// NO: return { ...(service as any).hiddenMethod } - incomplete interfaces\n// NO: @deprecated class wrappers that delegate to functional services"
        },
        {
          "line": 198,
          "keyword": "any",
          "directive": "NEUTRAL",
          "statement": "// NO: return { ...(service as any).hiddenMethod } - incomplete interfaces",
          "context": "// NO: export type PlayerService = ReturnType<typeof createPlayerService>\n// NO: createPlayerService(supabase: any) - must type as SupabaseClient<Database>\n// NO: return { ...(service as any).hiddenMethod } - incomplete interfaces\n// NO: @deprecated class wrappers that delegate to functional services\n// NO: default exports mixed with named exports"
        },
        {
          "line": 209,
          "keyword": "any",
          "directive": "NEUTRAL",
          "statement": "operation: () => Promise<any>,",
          "context": "export async function executeOperation<T>(\n  label: string,\n  operation: () => Promise<any>,\n  options?: OperationOptions,\n): Promise<ServiceResult<T>>;"
        },
        {
          "line": 302,
          "keyword": "any",
          "directive": "PROHIBITED",
          "statement": "\u2705 Type `supabase` parameter as `SupabaseClient<Database>` (never `any`)",
          "context": "\u2705 Use plain functional factories for service creation\n\u2705 Declare explicit interfaces for all services with complete type signatures\n\u2705 Type `supabase` parameter as `SupabaseClient<Database>` (never `any`)\n\u2705 Export explicit types, not `ReturnType<typeof createXService>`\n\u2705 Compose services from specialized modules with typed spread"
        },
        {
          "line": 320,
          "keyword": "any",
          "directive": "PROHIBITED",
          "statement": "\u274c Type parameters as `any` (violations: Casino, MTL services)",
          "context": "\u274c Create duplicate/competing factory patterns (createXService + createXServices)\n\u274c Use `ReturnType<typeof createXService>` for type inference\n\u274c Type parameters as `any` (violations: Casino, MTL services)\n\u274c Use `as any` type casting to bypass incomplete interfaces (violation: Visit service)\n\u274c Create deprecated class wrappers that delegate to functional services"
        },
        {
          "line": 321,
          "keyword": "any",
          "directive": "PROHIBITED",
          "statement": "\u274c Use `as any` type casting to bypass incomplete interfaces (violation: Visit service)",
          "context": "\u274c Use `ReturnType<typeof createXService>` for type inference\n\u274c Type parameters as `any` (violations: Casino, MTL services)\n\u274c Use `as any` type casting to bypass incomplete interfaces (violation: Visit service)\n\u274c Create deprecated class wrappers that delegate to functional services\n\u274c Leave methods undeclared in interfaces (must be complete)"
        }
      ],
      "system-prd/CANONICAL_BLUEPRINT_MVP_PRD.md": [
        {
          "line": 54,
          "keyword": "SupabaseClient",
          "directive": "NEUTRAL",
          "statement": "supabase: SupabaseClient<Database>,",
          "context": "\n  export function createPlayerService(\n    supabase: SupabaseClient<Database>,\n  ): PlayerService {\n    return {"
        },
        {
          "line": 63,
          "keyword": "SupabaseClient",
          "directive": "PROHIBITED",
          "statement": "- **Typed Dependencies**: Factory functions MUST type the `supabase` parameter as `SupabaseClient<Database>`. Never use `any`.",
          "context": "\n- **Ban `ReturnType` Inference**: Never use `ReturnType<typeof createXService>` for exported service types. Always export the explicit interface: `export type PlayerService = IPlayerService`.\n- **Typed Dependencies**: Factory functions MUST type the `supabase` parameter as `SupabaseClient<Database>`. Never use `any`.\n- **No Object Spread Without Types**: When composing services via object spread, the factory MUST declare an explicit return type interface that describes the final shape. This prevents silent method overwrites.\n"
        },
        {
          "line": 75,
          "keyword": "SupabaseClient",
          "directive": "NEUTRAL",
          "statement": "supabase: SupabaseClient<Database>,",
          "context": "\n  export function createCasinoService(\n    supabase: SupabaseClient<Database>,\n  ): CasinoService {\n    return { ...crud, ...tables };"
        },
        {
          "line": 114,
          "keyword": "createClient",
          "directive": "NEUTRAL",
          "statement": "- All mutations and privileged reads run through server actions wrapped by `withServerActionWrapper`; actions call Supabase via `createClient()` and return DTOs mapped in the service layer.",
          "context": "### 3.5 Server Actions & Data Fetching\n\n- All mutations and privileged reads run through server actions wrapped by `withServerActionWrapper`; actions call Supabase via `createClient()` and return DTOs mapped in the service layer.\n- Server actions emit structured telemetry (shared logger/instrumentation helpers only\u2014no `console.*` in production) with duration, request ID, and normalized error codes from the `ServiceResult` utilities.\n- Default page data loads in Server Components; React Query hooks hydrate from server-provided DTOs or call server actions via fetcher utilities instead of instantiating Supabase clients in the browser."
        },
        {
          "line": 14,
          "keyword": "any",
          "directive": "PROHIBITED",
          "statement": "- **No Anti-Patterns**: Ban dual DB clients, React Query storming, business logic in Zustand stores, `Database = any` shims.",
          "context": "- **Security First**: RLS enabled by default, JWT claim helpers versioned with migrations, audit logging mandatory.\n- **Guardrails Upfront**: CI gates for lint, type-check, tests, schema\u2192type regeneration, Lighthouse budgets.\n- **No Anti-Patterns**: Ban dual DB clients, React Query storming, business logic in Zustand stores, `Database = any` shims.\n\n## 3. System Requirements & Patterns to Replicate"
        },
        {
          "line": 35,
          "keyword": "any",
          "directive": "NEUTRAL",
          "statement": "- Any schema correction = new migration + new generated types (no in-place manual edits).",
          "context": "- Schema rebuilds regenerate the canonical file in place\u2014no parallel type graphs or \"rebuilt\" directories may be introduced.\n- Forward-only SQL migrations \u2192 regenerate types \u2192 commit diff \u2192 typecheck.\n- Any schema correction = new migration + new generated types (no in-place manual edits).\n  **Acceptance Criteria**\n- Single database.types.ts in repo."
        },
        {
          "line": 63,
          "keyword": "any",
          "directive": "PROHIBITED",
          "statement": "- **Typed Dependencies**: Factory functions MUST type the `supabase` parameter as `SupabaseClient<Database>`. Never use `any`.",
          "context": "\n- **Ban `ReturnType` Inference**: Never use `ReturnType<typeof createXService>` for exported service types. Always export the explicit interface: `export type PlayerService = IPlayerService`.\n- **Typed Dependencies**: Factory functions MUST type the `supabase` parameter as `SupabaseClient<Database>`. Never use `any`.\n- **No Object Spread Without Types**: When composing services via object spread, the factory MUST declare an explicit return type interface that describes the final shape. This prevents silent method overwrites.\n"
        },
        {
          "line": 81,
          "keyword": "any",
          "directive": "NEUTRAL",
          "statement": "export function createCasinoService(supabase: any) {",
          "context": "\n  // \u2717 Wrong - untyped spread\n  export function createCasinoService(supabase: any) {\n    return { ...crud, ...tables };\n  }"
        },
        {
          "line": 110,
          "keyword": "any",
          "directive": "REQUIRED",
          "statement": "- Any advanced offline/optimistic behaviour must sit behind domain-specific services with explicit acceptance criteria and integration tests\u2014not global managers.",
          "context": "- Mutations perform cache updates via `invalidateQueries` or targeted `setQueryData`; optimistic updates stay opt-in and encapsulated in domain helpers.\n- All React Query hooks wrap service-layer DTOs\u2014never raw Supabase rows\u2014and surface consistent loading/error contracts for UI components.\n- Any advanced offline/optimistic behaviour must sit behind domain-specific services with explicit acceptance criteria and integration tests\u2014not global managers.\n\n### 3.5 Server Actions & Data Fetching"
        },
        {
          "line": 129,
          "keyword": "any",
          "directive": "REQUIRED",
          "statement": "- Any advanced offline/optimistic behaviour must sit behind domain-specific services with explicit acceptance criteria and integration tests\u2014not global managers.",
          "context": "- Domain hooks manage their own channel lifecycle; avoid cross-cutting singletons such as connection pools, optimistic-update managers, or offline queues under `services/real-time/*`.\n- Logging and metrics for live data stay inside dev tooling; production hooks should be silent and rely on React Query retries for resilience.\n- Any advanced offline/optimistic behaviour must sit behind domain-specific services with explicit acceptance criteria and integration tests\u2014not global managers.\n\n### 3.7 UI Composition"
        },
        {
          "line": 173,
          "keyword": "any",
          "directive": "NEUTRAL",
          "statement": "- Block `Database = any` shims, manual table redefinitions, and intersection-based schema rebuilds in type modules.",
          "context": "- ESLint rule: forbid Supabase client creation in Zustand stores/components (legacy issue in `store/casino-store.ts`).\n- Lint: prohibit `staleTime: 0` unless file opted into real-time policy (violations previously in `hooks/rating-slip/useActiveRatingSlipsByTable.ts`, `components/ui/table/casino-table-ui-v2.tsx`, `components/ui/table/table-seat.tsx`).\n- Block `Database = any` shims, manual table redefinitions, and intersection-based schema rebuilds in type modules.\n- **Service Layer Type Enforcement**:\n  - Ban `ReturnType<typeof createXService>` patterns in service exports (violations in `services/table-context/index.ts`, `services/rating-slip/index.ts`, `services/compliance/index.ts`)."
        },
        {
          "line": 177,
          "keyword": "any",
          "directive": "NEUTRAL",
          "statement": "- Forbid `supabase: any` parameters in service factory functions (violations in `services/casino/index.ts`, `services/mtl/index.ts`).",
          "context": "  - Ban `ReturnType<typeof createXService>` patterns in service exports (violations in `services/table-context/index.ts`, `services/rating-slip/index.ts`, `services/compliance/index.ts`).\n  - Require explicit interface definitions for all service factories with typed return signatures.\n  - Forbid `supabase: any` parameters in service factory functions (violations in `services/casino/index.ts`, `services/mtl/index.ts`).\n  - Enforce explicit return type interfaces when using object spread composition to prevent silent method overwrites.\n  - Ban duplicate/competing factory patterns (e.g., `createXService` + `createXServices` doing the same thing - violation in `services/compliance/index.ts`)."
        },
        {
          "line": 183,
          "keyword": "any",
          "directive": "REQUIRED",
          "statement": "- **Forbid `as any` type casting to bypass incomplete interfaces** (violation in `services/visit/index.ts:76`). If a method exists in implementation, it MUST be declared in the interface.",
          "context": "  - Ban mixing default and named exports from service modules; use named exports exclusively for consistency and traceability.\n  - Prohibit runtime validation in service factory functions; move validation to development-only assertions or initialization-time checks.\n  - **Forbid `as any` type casting to bypass incomplete interfaces** (violation in `services/visit/index.ts:76`). If a method exists in implementation, it MUST be declared in the interface.\n  - **Remove all deprecated class wrappers** marked `@deprecated` that delegate to functional services (violation: `VisitService` class in `services/visit/index.ts`). Delete deprecated code instead of maintaining dual APIs.\n  - **Interfaces must be complete**: Every public method in the service implementation must have a corresponding type signature in the interface. No silent additions via type casting."
        },
        {
          "line": 22,
          "keyword": "client instantiation",
          "directive": "NEUTRAL",
          "statement": "- Provide shared Supabase client factories for browser/server usage (`lib/supabase/client.ts`, `lib/supabase/server.ts`). No client instantiation inside UI or stores.",
          "context": "- Seed the new project with the sanitized baseline migration (`supabase/migrations/20250828011313_init_corrected.sql`).\n- Enforce forward-only migrations with timestamped filenames; migrations must run through CI validation.\n- Provide shared Supabase client factories for browser/server usage (`lib/supabase/client.ts`, `lib/supabase/server.ts`). No client instantiation inside UI or stores.\n- Enable RLS on core tables (player, ratingslip, visit, mtl_entry, casino, gamingtable) using policy templates from `mtl-comprehensive-rls-policies.sql`.\n- Configure audit logging triggers mirroring the `AuditLog` pattern in the baseline migration."
        }
      ],
      "patterns/SERVER_ACTIONS_ARCHITECTURE.md": [
        {
          "line": 109,
          "keyword": "SupabaseClient",
          "directive": "NEUTRAL",
          "statement": "supabase: SupabaseClient<Database>,",
          "context": "export async function withServerAction<T>(\n  action: () => Promise<ServiceResult<T>>,\n  supabase: SupabaseClient<Database>,\n  context: ServerActionContext\n): Promise<ServiceResult<T>> {"
        },
        {
          "line": 65,
          "keyword": "createClient",
          "directive": "NEUTRAL",
          "statement": "import { createClient } from \"@/lib/supabase/server\";",
          "context": "\"use server\";\n\nimport { createClient } from \"@/lib/supabase/server\";\nimport { withServerAction } from \"@/lib/server-actions/with-server-action-wrapper\";\nimport { createPlayerService } from \"@/services/player\";"
        },
        {
          "line": 70,
          "keyword": "createClient",
          "directive": "NEUTRAL",
          "statement": "const supabase = await createClient();",
          "context": "\nexport async function createPlayerAction(input: CreatePlayerInput) {\n  const supabase = await createClient();\n  const { data: { session } } = await supabase.auth.getSession();\n"
        },
        {
          "line": 140,
          "keyword": "createClient",
          "directive": "NEUTRAL",
          "statement": "import { createClient } from \"@/lib/supabase/server\";",
          "context": "\"use server\";\n\nimport { createClient } from \"@/lib/supabase/server\";\nimport { withServerAction } from \"@/lib/server-actions/with-server-action-wrapper\";\nimport { create{Domain}Service } from \"@/services/{domain}\";"
        },
        {
          "line": 146,
          "keyword": "createClient",
          "directive": "NEUTRAL",
          "statement": "const supabase = await createClient();",
          "context": "\nexport async function {action}Action(input: {Action}Input): Promise<ServiceResult<{Result}>> {\n  const supabase = await createClient();\n  const { data: { session } } = await supabase.auth.getSession();\n"
        },
        {
          "line": 290,
          "keyword": "createClient",
          "directive": "NEUTRAL",
          "statement": "const supabase = await createClient();",
          "context": "```typescript\nexport async function createPlayerAction(input: CreatePlayerInput) {\n  const supabase = await createClient();\n  const service = createPlayerService(supabase);\n  const result = await service.create(input);"
        },
        {
          "line": 305,
          "keyword": "createClient",
          "directive": "NEUTRAL",
          "statement": "const supabase = await createClient();",
          "context": "```typescript\nexport async function createPlayerAction(input: CreatePlayerInput) {\n  const supabase = await createClient();\n  const { data: { session } } = await supabase.auth.getSession();\n"
        }
      ],
      "patterns/SERVICE_TEMPLATE.md": [
        {
          "line": 19,
          "keyword": "SupabaseClient",
          "directive": "NEUTRAL",
          "statement": "| `supabase: any` | `supabase: SupabaseClient<Database>` |",
          "context": "|----------------|-------------------|\n| `ReturnType<typeof createXService>` | Explicit `interface XService` |\n| `supabase: any` | `supabase: SupabaseClient<Database>` |\n| `import from '@/types/database-rebuilt'` | `Database['public']['Tables']['x']` |\n| `services/x/types.ts` | `types/domains/x/index.ts` |"
        },
        {
          "line": 184,
          "keyword": "SupabaseClient",
          "directive": "NEUTRAL",
          "statement": "import type { SupabaseClient } from \"@supabase/supabase-js\";",
          "context": " */\n\nimport type { SupabaseClient } from \"@supabase/supabase-js\";\nimport type { Database } from \"@/types/database.types\";\nimport { executeOperation } from \"../shared/operation-wrapper\";"
        },
        {
          "line": 201,
          "keyword": "SupabaseClient",
          "directive": "NEUTRAL",
          "statement": "export function createXCrudService(supabase: SupabaseClient<Database>) {",
          "context": "\n// \u2705 Functional factory with explicit typing\nexport function createXCrudService(supabase: SupabaseClient<Database>) {\n  return {\n    /**"
        },
        {
          "line": 299,
          "keyword": "SupabaseClient",
          "directive": "NEUTRAL",
          "statement": "import type { SupabaseClient } from \"@supabase/supabase-js\";",
          "context": " */\n\nimport type { SupabaseClient } from \"@supabase/supabase-js\";\nimport type { Database } from \"@/types/database.types\";\nimport { createXCrudService } from \"./crud\";"
        },
        {
          "line": 314,
          "keyword": "SupabaseClient",
          "directive": "NEUTRAL",
          "statement": "supabase: SupabaseClient<Database>,",
          "context": "// \u2705 STEP 2: Typed factory with explicit interface return\nexport function createXService(\n  supabase: SupabaseClient<Database>,\n): XService {\n  const crudService = createXCrudService(supabase);"
        },
        {
          "line": 344,
          "keyword": "SupabaseClient",
          "directive": "NEUTRAL",
          "statement": "import { createClient, type SupabaseClient } from \"@supabase/supabase-js\";",
          "context": "\nimport { describe, it, expect, beforeEach } from \"@jest/globals\";\nimport { createClient, type SupabaseClient } from \"@supabase/supabase-js\";\nimport type { Database } from \"@/types/database.types\";\nimport { createXService } from \"@/services/x\";"
        },
        {
          "line": 352,
          "keyword": "SupabaseClient",
          "directive": "NEUTRAL",
          "statement": "let supabase: SupabaseClient<Database>;",
          "context": "\ndescribe(\"X Service - CRUD Operations\", () => {\n  let supabase: SupabaseClient<Database>;\n  let xService: ReturnType<typeof createXService>;\n"
        },
        {
          "line": 344,
          "keyword": "createClient",
          "directive": "NEUTRAL",
          "statement": "import { createClient, type SupabaseClient } from \"@supabase/supabase-js\";",
          "context": "\nimport { describe, it, expect, beforeEach } from \"@jest/globals\";\nimport { createClient, type SupabaseClient } from \"@supabase/supabase-js\";\nimport type { Database } from \"@/types/database.types\";\nimport { createXService } from \"@/services/x\";"
        },
        {
          "line": 356,
          "keyword": "createClient",
          "directive": "NEUTRAL",
          "statement": "supabase = createClient<Database>(supabaseUrl, supabaseAnonKey);",
          "context": "\n  beforeEach(() => {\n    supabase = createClient<Database>(supabaseUrl, supabaseAnonKey);\n    xService = createXService(supabase);\n  });"
        },
        {
          "line": 428,
          "keyword": "createClient",
          "directive": "NEUTRAL",
          "statement": "import { createClient } from \"@/lib/supabase/server\";",
          "context": " */\n\nimport { createClient } from \"@/lib/supabase/server\";\nimport { createXService, type XCreateDTO } from \"@/services/x\";\nimport type { ServiceResult } from \"@/services/shared/types\";"
        },
        {
          "line": 448,
          "keyword": "createClient",
          "directive": "NEUTRAL",
          "statement": "const supabase = await createClient();",
          "context": "  input: CreateXInput,\n): Promise<CreateXResult> {\n  const supabase = await createClient();\n  const xService = createXService(supabase);\n"
        },
        {
          "line": 14,
          "keyword": "any",
          "directive": "REQUIRED",
          "statement": "Before starting ANY service implementation, verify you will NOT:",
          "context": "## Anti-Pattern Guardrails\n\nBefore starting ANY service implementation, verify you will NOT:\n\n| \u274c Anti-Pattern | \u2705 Correct Pattern |"
        },
        {
          "line": 19,
          "keyword": "any",
          "directive": "NEUTRAL",
          "statement": "| `supabase: any` | `supabase: SupabaseClient<Database>` |",
          "context": "|----------------|-------------------|\n| `ReturnType<typeof createXService>` | Explicit `interface XService` |\n| `supabase: any` | `supabase: SupabaseClient<Database>` |\n| `import from '@/types/database-rebuilt'` | `Database['public']['Tables']['x']` |\n| `services/x/types.ts` | `types/domains/x/index.ts` |"
        },
        {
          "line": 26,
          "keyword": "any",
          "directive": "PROHIBITED",
          "statement": "**One-Violation Rule**: If migrating PT-1 code that breaks ANY rule above \u2192 rewrite, don't patch.",
          "context": "| `console.*` in operations | Structured logging/monitoring |\n\n**One-Violation Rule**: If migrating PT-1 code that breaks ANY rule above \u2192 rewrite, don't patch.\n\n---"
        },
        {
          "line": 116,
          "keyword": "any",
          "directive": "NEUTRAL",
          "statement": "operation: () => Promise<any>,",
          "context": "export async function executeOperation<T>(\n  label: string,\n  operation: () => Promise<any>,\n  options?: OperationOptions,\n): Promise<ServiceResult<T>> {"
        },
        {
          "line": 143,
          "keyword": "any",
          "directive": "NEUTRAL",
          "statement": "code: (err as any).code,",
          "context": "        data: null,\n        error: {\n          code: (err as any).code,\n          message: (err as any).message,\n          details: (err as any).details,"
        },
        {
          "line": 144,
          "keyword": "any",
          "directive": "NEUTRAL",
          "statement": "message: (err as any).message,",
          "context": "        error: {\n          code: (err as any).code,\n          message: (err as any).message,\n          details: (err as any).details,\n        },"
        },
        {
          "line": 145,
          "keyword": "any",
          "directive": "NEUTRAL",
          "statement": "details: (err as any).details,",
          "context": "          code: (err as any).code,\n          message: (err as any).message,\n          details: (err as any).details,\n        },\n        success: false,"
        },
        {
          "line": 536,
          "keyword": "any",
          "directive": "NEUTRAL",
          "statement": "- [ ] **One-Violation Rule**: Rewrite PT-1 code with ANY violation",
          "context": "\n- [ ] **Rule of Three**: Don't extract helpers until 3rd use\n- [ ] **One-Violation Rule**: Rewrite PT-1 code with ANY violation\n- [ ] **Time-Box Mining**: Cap PT-1 exploration to \u22644h per module\n- [ ] **JSDoc First**: Document as you code, not after"
        },
        {
          "line": 543,
          "keyword": "any",
          "directive": "NEUTRAL",
          "statement": "- [ ] No `any` typed parameters",
          "context": "\n- [ ] No `ReturnType` inference in main exports\n- [ ] No `any` typed parameters\n- [ ] No `@/types/database-rebuilt` imports\n- [ ] No `services/x/types.ts` files"
        },
        {
          "line": 649,
          "keyword": "any",
          "directive": "NEUTRAL",
          "statement": "**Update Process**: PR with justification for any pattern changes",
          "context": "**Review Frequency**: After each domain service completion\n**Owner**: Architecture team\n**Update Process**: PR with justification for any pattern changes\n"
        }
      ],
      "patterns/OVER_ENGINEERING_GUARDRAIL.md": [
        {
          "line": 19,
          "keyword": "any",
          "directive": "NEUTRAL",
          "statement": "**Symptoms** (any two = violation):",
          "context": "\"Generic, reusable infrastructure introduced before a second concrete consumer exists.\"\n\n**Symptoms** (any two = violation):\n\n- Abstract \"dispatcher/bus\" or \"event store\" created with one consumer"
        },
        {
          "line": 51,
          "keyword": "any",
          "directive": "REQUIRED",
          "statement": "Anything beyond this requires a trigger (\u00a76) and a Mini-ADR (\u00a77).",
          "context": "One structured log per operation with correlation_id (success/failure).\n\nAnything beyond this requires a trigger (\u00a76) and a Mini-ADR (\u00a77).\n\n## 5. Red-Flag Checklist (Stop-the-Line if any two are \"Yes\")"
        },
        {
          "line": 53,
          "keyword": "any",
          "directive": "NEUTRAL",
          "statement": "## 5. Red-Flag Checklist (Stop-the-Line if any two are \"Yes\")",
          "context": "Anything beyond this requires a trigger (\u00a76) and a Mini-ADR (\u00a77).\n\n## 5. Red-Flag Checklist (Stop-the-Line if any two are \"Yes\")\n\n- [ ] Are you adding an abstraction layer (bus/dispatcher) with one consumer?"
        },
        {
          "line": 66,
          "keyword": "any",
          "directive": "OPTIONAL",
          "statement": "You may add infra/abstractions when any one is true and recorded:",
          "context": "## 6. Allowable Triggers for Added Complexity\n\nYou may add infra/abstractions when any one is true and recorded:\n\n**Second Concrete Consumer**"
        }
      ],
      "patterns/SERVICE_TEMPLATE_QUICK.md": [
        {
          "line": 13,
          "keyword": "SupabaseClient",
          "directive": "NEUTRAL",
          "statement": "| `supabase: any` | `supabase: SupabaseClient<Database>` |",
          "context": "|---------|----------|\n| `ReturnType<typeof createXService>` | Explicit `interface XService` |\n| `supabase: any` | `supabase: SupabaseClient<Database>` |\n| `@/types/database-rebuilt` | `Database['public']['Tables']['x']` |\n| `services/x/types.ts` | `types/domains/x/` |"
        },
        {
          "line": 97,
          "keyword": "SupabaseClient",
          "directive": "NEUTRAL",
          "statement": "export function createXCrudService(supabase: SupabaseClient<Database>) {",
          "context": "import { executeOperation } from \"../shared/operation-wrapper\";\n\nexport function createXCrudService(supabase: SupabaseClient<Database>) {\n  return {\n    create: async (data: XCreateDTO): Promise<ServiceResult<XDTO>> => {"
        },
        {
          "line": 132,
          "keyword": "SupabaseClient",
          "directive": "NEUTRAL",
          "statement": "supabase: SupabaseClient<Database>",
          "context": "// \u2705 STEP 2: Typed factory\nexport function createXService(\n  supabase: SupabaseClient<Database>\n): XService {\n  const crudService = createXCrudService(supabase);"
        },
        {
          "line": 58,
          "keyword": "createClient",
          "directive": "NEUTRAL",
          "statement": "const supabase = createClient<Database>(url, key);",
          "context": "\n  beforeEach(() => {\n    const supabase = createClient<Database>(url, key);\n    xService = createXService(supabase);\n  });"
        },
        {
          "line": 8,
          "keyword": "any",
          "directive": "NEUTRAL",
          "statement": "Before writing ANY service code:",
          "context": "## Pre-Flight Checklist\n\nBefore writing ANY service code:\n\n| \u274c Never | \u2705 Always |"
        },
        {
          "line": 13,
          "keyword": "any",
          "directive": "NEUTRAL",
          "statement": "| `supabase: any` | `supabase: SupabaseClient<Database>` |",
          "context": "|---------|----------|\n| `ReturnType<typeof createXService>` | Explicit `interface XService` |\n| `supabase: any` | `supabase: SupabaseClient<Database>` |\n| `@/types/database-rebuilt` | `Database['public']['Tables']['x']` |\n| `services/x/types.ts` | `types/domains/x/` |"
        },
        {
          "line": 19,
          "keyword": "any",
          "directive": "PROHIBITED",
          "statement": "**One-Violation Rule**: If PT-1 code breaks ANY rule \u2192 **rewrite**, don't patch.",
          "context": "| `console.*` | Structured logging |\n\n**One-Violation Rule**: If PT-1 code breaks ANY rule \u2192 **rewrite**, don't patch.\n\n---"
        },
        {
          "line": 175,
          "keyword": "any",
          "directive": "NEUTRAL",
          "statement": "- [ ] No `any` parameters",
          "context": "\n- [ ] No `ReturnType` in main exports\n- [ ] No `any` parameters\n- [ ] No `database-rebuilt` imports\n- [ ] No `services/x/types.ts` file"
        },
        {
          "line": 182,
          "keyword": "any",
          "directive": "NEUTRAL",
          "statement": "**If ANY fail** \u2192 fix before PR",
          "context": "- [ ] `npx tsc --noEmit` clean\n\n**If ANY fail** \u2192 fix before PR\n\n---"
        }
      ],
      "patterns/controlled-hybrid-refactor-model.md": [
        {
          "line": 20,
          "keyword": "any",
          "directive": "PROHIBITED",
          "statement": "**Do not refactor or generalize any helper until you've repeated it in three slices.**",
          "context": "\n### 1. Rule of Three\n**Do not refactor or generalize any helper until you've repeated it in three slices.**\n\nExample: Don't create `services/shared/validation.ts` until 3 services need the same validation pattern."
        },
        {
          "line": 29,
          "keyword": "any",
          "directive": "PROHIBITED",
          "statement": "- \u274c `supabase: any`",
          "context": "Violations:\n- \u274c `ReturnType<typeof createXService>`\n- \u274c `supabase: any`\n- \u274c `@/types/database-rebuilt` imports\n- \u274c `services/x/types.ts` files"
        },
        {
          "line": 35,
          "keyword": "any",
          "directive": "PROHIBITED",
          "statement": "Action: If PT-1 code contains ANY \u2192 **rewrite using template**, don't import.",
          "context": "- \u274c `class BaseService` abstractions\n\nAction: If PT-1 code contains ANY \u2192 **rewrite using template**, don't import.\n\n### 3. Time-Box Mining"
        },
        {
          "line": 38,
          "keyword": "any",
          "directive": "NEUTRAL",
          "statement": "**Cap PT-1 exploration to \u22644 hours per module; anything longer means rebuild.**",
          "context": "\n### 3. Time-Box Mining\n**Cap PT-1 exploration to \u22644 hours per module; anything longer means rebuild.**\n\nReasoning: If understanding PT-1 code takes longer than rewriting it, you're debugging legacy debt instead of building new features."
        }
      ],
      "patterns/SERVICE_RESPONSIBILITY_MATRIX.md": [
        {
          "line": 486,
          "keyword": "SupabaseClient",
          "directive": "NEUTRAL",
          "statement": "supabase: SupabaseClient<Database>,",
          "context": " */\nexport async function calculateAndAssignPoints(\n  supabase: SupabaseClient<Database>,\n  input: {\n    ratingSlipId: string;"
        },
        {
          "line": 663,
          "keyword": "any",
          "directive": "NEUTRAL",
          "statement": "Before adding ANY field or logic to a service, verify:",
          "context": "## Updated Bounded Context Validation Checklist\n\nBefore adding ANY field or logic to a service, verify:\n\n- [ ] **Single Responsibility**: Does this belong to this domain's core responsibility?"
        }
      ],
      "patterns/BALANCED_ARCHITECTURE_QUICK.md": [
        {
          "line": 257,
          "keyword": "SupabaseClient",
          "directive": "PROHIBITED",
          "statement": "\u274c **Typed dependencies** - `supabase: SupabaseClient<Database>`, NOT `any`",
          "context": "### Never Compromise (Non-Negotiable)\n\u274c **Explicit interfaces** - `interface XService`, NOT `ReturnType`\n\u274c **Typed dependencies** - `supabase: SupabaseClient<Database>`, NOT `any`\n\u274c **ServiceResult pattern** - Consistent error handling\n\u274c **80% test coverage** - Service layer minimum"
        },
        {
          "line": 257,
          "keyword": "any",
          "directive": "PROHIBITED",
          "statement": "\u274c **Typed dependencies** - `supabase: SupabaseClient<Database>`, NOT `any`",
          "context": "### Never Compromise (Non-Negotiable)\n\u274c **Explicit interfaces** - `interface XService`, NOT `ReturnType`\n\u274c **Typed dependencies** - `supabase: SupabaseClient<Database>`, NOT `any`\n\u274c **ServiceResult pattern** - Consistent error handling\n\u274c **80% test coverage** - Service layer minimum"
        },
        {
          "line": 399,
          "keyword": "any",
          "directive": "NEUTRAL",
          "statement": "1. **\"How many services does this touch?\"**",
          "context": "**Confused about approach?** Ask these 3 questions:\n\n1. **\"How many services does this touch?\"**\n   - 1 service \u2192 VERTICAL\n   - ALL services \u2192 HORIZONTAL"
        }
      ],
      "patterns/MTL_DOMAIN_CLASSIFICATION.md": [
        {
          "line": 144,
          "keyword": "any",
          "directive": "NEUTRAL",
          "statement": "- **Archival:** Nightly backup and secure WORM (Write-Once-Read-Many) storage.",
          "context": "- **Mutable fields:** Only `notes` via `addAuditNote()`.  \n- **Retention:** \u2265 5 years (regulatory minimum).  \n- **Archival:** Nightly backup and secure WORM (Write-Once-Read-Many) storage.\n\n---"
        }
      ],
      "adr/NEXT_STEPS_REPORT.md": [
        {
          "line": 182,
          "keyword": "SupabaseClient",
          "directive": "REQUIRED",
          "statement": "- \u2705 All services use `SupabaseClient<Database>` (no `any`)",
          "context": "**End-of-Phase-2 Audit**:\n- \u2705 All services have explicit interfaces (no `ReturnType`)\n- \u2705 All services use `SupabaseClient<Database>` (no `any`)\n- \u2705 Zero PRD violations (ESLint + manual review)\n- \u2705 Test coverage >80% per service"
        },
        {
          "line": 292,
          "keyword": "createClient",
          "directive": "NEUTRAL",
          "statement": "const supabase = createClient();",
          "context": "// hooks/player/use-player-queries.ts\nexport function usePlayer(id: string) {\n  const supabase = createClient();\n  const playerService = createPlayerService(supabase);\n"
        },
        {
          "line": 302,
          "keyword": "createClient",
          "directive": "NEUTRAL",
          "statement": "const supabase = createClient();",
          "context": "\nexport function usePlayers() {\n  const supabase = createClient();\n  const playerService = createPlayerService(supabase);\n"
        },
        {
          "line": 312,
          "keyword": "createClient",
          "directive": "NEUTRAL",
          "statement": "const supabase = createClient();",
          "context": "\nexport function usePlayerSearch(query: string) {\n  const supabase = createClient();\n  const playerService = createPlayerService(supabase);\n"
        },
        {
          "line": 328,
          "keyword": "createClient",
          "directive": "NEUTRAL",
          "statement": "const supabase = createClient();",
          "context": "export function useCreatePlayer() {\n  const queryClient = useQueryClient();\n  const supabase = createClient();\n  const playerService = createPlayerService(supabase);\n"
        },
        {
          "line": 342,
          "keyword": "createClient",
          "directive": "NEUTRAL",
          "statement": "const supabase = createClient();",
          "context": "export function useUpdatePlayer() {\n  const queryClient = useQueryClient();\n  const supabase = createClient();\n  const playerService = createPlayerService(supabase);\n"
        },
        {
          "line": 419,
          "keyword": "createClient",
          "directive": "NEUTRAL",
          "statement": "const supabase = createClient();",
          "context": "\nexport async function createPlayerAction(data: PlayerCreateDTO) {\n  const supabase = createClient();\n  const playerService = createPlayerService(supabase);\n"
        },
        {
          "line": 484,
          "keyword": "createClient",
          "directive": "NEUTRAL",
          "statement": "const supabase = createClient();",
          "context": "// Server Component - fetches data\nexport default async function PlayerList() {\n  const supabase = createClient();\n  const playerService = createPlayerService(supabase);\n"
        },
        {
          "line": 604,
          "keyword": "createClient",
          "directive": "NEUTRAL",
          "statement": "const supabase = createClient();",
          "context": "  callback: (payload: T) => void\n) {\n  const supabase = createClient();\n\n  useEffect(() => {"
        },
        {
          "line": 182,
          "keyword": "any",
          "directive": "REQUIRED",
          "statement": "- \u2705 All services use `SupabaseClient<Database>` (no `any`)",
          "context": "**End-of-Phase-2 Audit**:\n- \u2705 All services have explicit interfaces (no `ReturnType`)\n- \u2705 All services use `SupabaseClient<Database>` (no `any`)\n- \u2705 Zero PRD violations (ESLint + manual review)\n- \u2705 Test coverage >80% per service"
        },
        {
          "line": 594,
          "keyword": "any",
          "directive": "REQUIRED",
          "statement": "export function useSupabaseChannel<T extends RealtimePostgresChangesPayload<any>>(",
          "context": "```typescript\n// hooks/shared/use-supabase-channel.ts\nexport function useSupabaseChannel<T extends RealtimePostgresChangesPayload<any>>(\n  channelName: string,\n  config: {"
        }
      ],
      "adr/ADR-004-real-time-strategy.md": [
        {
          "line": 38,
          "keyword": "any",
          "directive": "REQUIRED",
          "statement": "- **Effect Boundaries**: A shared `useRealtimeSubscription` hook wraps Supabase listeners inside `useEffect` with deterministic cleanup. It also registers a `AbortController` which is signalled on unmount to short-circuit any pending scheduler tasks.",
          "context": "\n- **Ref-counted Cleanup**: `acquireChannel` increments a counter per channel; on cleanup the counter decrements and invokes `channel.unsubscribe()` once it hits zero.\n- **Effect Boundaries**: A shared `useRealtimeSubscription` hook wraps Supabase listeners inside `useEffect` with deterministic cleanup. It also registers a `AbortController` which is signalled on unmount to short-circuit any pending scheduler tasks.\n- **Idle Detection**: The registry tracks last-activity timestamps; idle channels (no subscribers + no events for 30s) are purged from memory to avoid zombie sockets when a user navigates rapidly between tabs.\n- **Testing Hooks**: Jest tests simulate mount/unmount sequences to assert channel counts drop to zero and scheduler queues flush. Cypress smoke ensures that navigating away from realtime-heavy screens does not log Supabase warnings."
        },
        {
          "line": 51,
          "keyword": "any",
          "directive": "REQUIRED",
          "statement": "- **Foreground/Background Awareness**: When the document visibility changes to hidden for >2 minutes, we pause scheduler execution (queue persists). On visibility regain we flush the queue then rely on React Query\u2019s `refetchOnReconnect` to catch any missed deltas.",
          "context": "- **Supabase Status Hooks**: The registry listens to Supabase `on('system', 'status')` events. On transitions to `CONNECTED`, it replays pending scheduler tasks and triggers a selective refetch (`queryClient.invalidateQueries` for domains flagged as \u201crequires resync on reconnect\u201d).\n- **Backoff & Limits**: Let Supabase handle connection retries but impose a cap of 5 rapid reconnections before surfacing a toast via Zustand UI store prompting users to refresh. This prevents infinite reconnect loops in degraded networks.\n- **Foreground/Background Awareness**: When the document visibility changes to hidden for >2 minutes, we pause scheduler execution (queue persists). On visibility regain we flush the queue then rely on React Query\u2019s `refetchOnReconnect` to catch any missed deltas.\n- **Auth Refresh Integration**: The Supabase SSR helper already rotates session tokens; the registry exposes `refreshAuth(token)` so that when Next.js refreshes session cookies the channel client updates without tearing down listeners.\n"
        },
        {
          "line": 65,
          "keyword": "any",
          "directive": "PROHIBITED",
          "statement": "2. **Leak Prevention**: Ref-counted registry and effect cleanup avoid the \u201ctoo many listeners\u201d warnings witnessed in earlier spikes.",
          "context": "\n1. **Predictable Cache Updates**: Scheduler + canonical query keys minimize redundant refetches while keeping React Query aligned with live data.\n2. **Leak Prevention**: Ref-counted registry and effect cleanup avoid the \u201ctoo many listeners\u201d warnings witnessed in earlier spikes.\n3. **Domain Isolation**: Teams evolve realtime rules per bounded context without impacting others, reducing regression risk.\n4. **Resilient UX**: Automatic reconnection and selective refetch ensure operators see fresh data after transient outages."
        }
      ],
      "adr/ADR-003-state-management-strategy.md": [
        {
          "line": 59,
          "keyword": "any",
          "directive": "REQUIRED",
          "statement": "**Override Guidance**: The 5-minute/30-minute defaults serve as a baseline. Hook authors should explicitly set shorter `staleTime`/`gcTime` values for high-volatility queries such as live table availability or player status dashboards, and extend the window for infrequently accessed reports. Document any override in the corresponding domain README so cross-team consumers know the expected freshness.",
          "context": "- TypeScript-first design\n\n**Override Guidance**: The 5-minute/30-minute defaults serve as a baseline. Hook authors should explicitly set shorter `staleTime`/`gcTime` values for high-volatility queries such as live table availability or player status dashboards, and extend the window for infrequently accessed reports. Document any override in the corresponding domain README so cross-team consumers know the expected freshness.\n\n**Evidence**: `/home/diepulp/projects/pt-2/lib/query-client.ts` - 4 tests passing"
        },
        {
          "line": 78,
          "keyword": "any",
          "directive": "NEUTRAL",
          "statement": "['casino', 'by-company', companyId]",
          "context": "['casino', 'list']\n['casino', 'detail', casinoId]\n['casino', 'by-company', companyId]\n\n// Player Domain"
        },
        {
          "line": 78,
          "keyword": "any",
          "directive": "NEUTRAL",
          "statement": "['casino', 'by-company', companyId]",
          "context": "['casino', 'list']\n['casino', 'detail', casinoId]\n['casino', 'by-company', companyId]\n\n// Player Domain"
        },
        {
          "line": 528,
          "keyword": "any",
          "directive": "REQUIRED",
          "statement": "1. \u2705 Casino Service (5 tests) - All CRUD + ListByCompany",
          "context": "\n**Services Validated**:\n1. \u2705 Casino Service (5 tests) - All CRUD + ListByCompany\n2. \u2705 Player Service (3 tests) - Create, Read, Update\n3. \u2705 Visit Service (3 tests) - Create, Read, Update"
        }
      ]
    },
    "state_management": {
      "system-prd/SERVICE_LAYER_ARCHITECTURE_DIAGRAM.md": [
        {
          "line": 37,
          "keyword": "React Query",
          "directive": "NEUTRAL",
          "statement": "Hooks[React Query Hooks]",
          "context": "    subgraph \"Client Layer\"\n        UI[UI Components]\n        Hooks[React Query Hooks]\n        Actions[Server Actions]\n    end"
        },
        {
          "line": 330,
          "keyword": "React Query",
          "directive": "PROHIBITED",
          "statement": "\u274c Use `staleTime: 0` in React Query without justification",
          "context": "\u274c Access Supabase directly from UI\n\u274c Store server data in Zustand\n\u274c Use `staleTime: 0` in React Query without justification\n\u274c Create global real-time managers (connection pools, offline managers)\n\u274c Mix service and type responsibilities"
        },
        {
          "line": 347,
          "keyword": "React Query",
          "directive": "NEUTRAL",
          "statement": "- Batch React Query invalidations",
          "context": "- Use `executeTrackedOperation` for performance monitoring\n- Implement proper cleanup for real-time subscriptions\n- Batch React Query invalidations\n- Use dynamic imports for heavy components\n- Keep initial bundle under 250KB"
        },
        {
          "line": 329,
          "keyword": "Zustand",
          "directive": "PROHIBITED",
          "statement": "\u274c Store server data in Zustand",
          "context": "\u274c Put business logic in CRUD modules\n\u274c Access Supabase directly from UI\n\u274c Store server data in Zustand\n\u274c Use `staleTime: 0` in React Query without justification\n\u274c Create global real-time managers (connection pools, offline managers)"
        },
        {
          "line": 330,
          "keyword": "staleTime",
          "directive": "PROHIBITED",
          "statement": "\u274c Use `staleTime: 0` in React Query without justification",
          "context": "\u274c Access Supabase directly from UI\n\u274c Store server data in Zustand\n\u274c Use `staleTime: 0` in React Query without justification\n\u274c Create global real-time managers (connection pools, offline managers)\n\u274c Mix service and type responsibilities"
        },
        {
          "line": 21,
          "keyword": "global state",
          "directive": "NEUTRAL",
          "statement": "- Global state management in services",
          "context": "- Deprecated class wrappers delegating to functional services\n- Duplicate/competing factory patterns\n- Global state management in services\n- Global real-time managers (connection pools, offline managers)\n"
        },
        {
          "line": 22,
          "keyword": "real-time",
          "directive": "NEUTRAL",
          "statement": "- Global real-time managers (connection pools, offline managers)",
          "context": "- Duplicate/competing factory patterns\n- Global state management in services\n- Global real-time managers (connection pools, offline managers)\n\n### Export/Module Anti-Patterns (Eliminated)"
        },
        {
          "line": 81,
          "keyword": "real-time",
          "directive": "NEUTRAL",
          "statement": "RT[Real-time<br/>Subscriptions]",
          "context": "        SB[Supabase Client]\n        DB[(PostgreSQL<br/>RLS Enabled)]\n        RT[Real-time<br/>Subscriptions]\n    end\n"
        },
        {
          "line": 331,
          "keyword": "real-time",
          "directive": "PROHIBITED",
          "statement": "\u274c Create global real-time managers (connection pools, offline managers)",
          "context": "\u274c Store server data in Zustand\n\u274c Use `staleTime: 0` in React Query without justification\n\u274c Create global real-time managers (connection pools, offline managers)\n\u274c Mix service and type responsibilities\n\u274c Cache service instances or add internal state"
        },
        {
          "line": 346,
          "keyword": "real-time",
          "directive": "REQUIRED",
          "statement": "- Implement proper cleanup for real-time subscriptions",
          "context": "\n- Use `executeTrackedOperation` for performance monitoring\n- Implement proper cleanup for real-time subscriptions\n- Batch React Query invalidations\n- Use dynamic imports for heavy components"
        },
        {
          "line": 522,
          "keyword": "real-time",
          "directive": "PROHIBITED",
          "statement": "\u274c **NO** `services/real-time/` - No global real-time managers",
          "context": "\u274c **NO** `services/base.service.ts` - No class-based abstractions\n\u274c **NO** `services/service.factory.ts` - No factory with caching/metrics\n\u274c **NO** `services/real-time/` - No global real-time managers\n\u274c **NO** `services/player/lightweight-player-service.ts` - No duplicate implementations\n\u274c **NO** `services/player/types.ts` - Types belong in `types/domains/player/`"
        },
        {
          "line": 522,
          "keyword": "real-time",
          "directive": "PROHIBITED",
          "statement": "\u274c **NO** `services/real-time/` - No global real-time managers",
          "context": "\u274c **NO** `services/base.service.ts` - No class-based abstractions\n\u274c **NO** `services/service.factory.ts` - No factory with caching/metrics\n\u274c **NO** `services/real-time/` - No global real-time managers\n\u274c **NO** `services/player/lightweight-player-service.ts` - No duplicate implementations\n\u274c **NO** `services/player/types.ts` - Types belong in `types/domains/player/`"
        },
        {
          "line": 333,
          "keyword": "cache",
          "directive": "PROHIBITED",
          "statement": "\u274c Cache service instances or add internal state",
          "context": "\u274c Create global real-time managers (connection pools, offline managers)\n\u274c Mix service and type responsibilities\n\u274c Cache service instances or add internal state\n\n## Migration Priorities"
        }
      ],
      "system-prd/CANONICAL_BLUEPRINT_MVP_PRD.md": [
        {
          "line": 14,
          "keyword": "React Query",
          "directive": "PROHIBITED",
          "statement": "- **No Anti-Patterns**: Ban dual DB clients, React Query storming, business logic in Zustand stores, `Database = any` shims.",
          "context": "- **Security First**: RLS enabled by default, JWT claim helpers versioned with migrations, audit logging mandatory.\n- **Guardrails Upfront**: CI gates for lint, type-check, tests, schema\u2192type regeneration, Lighthouse budgets.\n- **No Anti-Patterns**: Ban dual DB clients, React Query storming, business logic in Zustand stores, `Database = any` shims.\n\n## 3. System Requirements & Patterns to Replicate"
        },
        {
          "line": 103,
          "keyword": "React Query",
          "directive": "NEUTRAL",
          "statement": "- React Query is the sole remote data cache; defaults derive from `lib/query-client.ts` (non-zero `staleTime`, `refetchOnWindowFocus: false`).",
          "context": "### 3.4 State Management\n\n- React Query is the sole remote data cache; defaults derive from `lib/query-client.ts` (non-zero `staleTime`, `refetchOnWindowFocus: false`).\n- Zustand restricted to ephemeral UI state (selection, modal visibility) as demonstrated in `store/player-store.ts`, **ref is available upon request**.\n- React Query hooks (`hooks/service-layer/use-service-query.ts`) become templates for entity/list/mutation operations; overrides for `staleTime: 0` require explicit approval."
        },
        {
          "line": 105,
          "keyword": "React Query",
          "directive": "REQUIRED",
          "statement": "- React Query hooks (`hooks/service-layer/use-service-query.ts`) become templates for entity/list/mutation operations; overrides for `staleTime: 0` require explicit approval.",
          "context": "- React Query is the sole remote data cache; defaults derive from `lib/query-client.ts` (non-zero `staleTime`, `refetchOnWindowFocus: false`).\n- Zustand restricted to ephemeral UI state (selection, modal visibility) as demonstrated in `store/player-store.ts`, **ref is available upon request**.\n- React Query hooks (`hooks/service-layer/use-service-query.ts`) become templates for entity/list/mutation operations; overrides for `staleTime: 0` require explicit approval.\n- Queries declare sane `staleTime`/`gcTime` per domain; zero-stale configs require explicit real-time justification and documented invalidation strategy.\n- Query keys follow the `[domain-scope, entity, identifier]` pattern (`['visit', 'list', casinoId]`) to keep invalidation predictable; helper modules expose canonical keys per domain."
        },
        {
          "line": 109,
          "keyword": "React Query",
          "directive": "PROHIBITED",
          "statement": "- All React Query hooks wrap service-layer DTOs\u2014never raw Supabase rows\u2014and surface consistent loading/error contracts for UI components.",
          "context": "- Query keys follow the `[domain-scope, entity, identifier]` pattern (`['visit', 'list', casinoId]`) to keep invalidation predictable; helper modules expose canonical keys per domain.\n- Mutations perform cache updates via `invalidateQueries` or targeted `setQueryData`; optimistic updates stay opt-in and encapsulated in domain helpers.\n- All React Query hooks wrap service-layer DTOs\u2014never raw Supabase rows\u2014and surface consistent loading/error contracts for UI components.\n- Any advanced offline/optimistic behaviour must sit behind domain-specific services with explicit acceptance criteria and integration tests\u2014not global managers.\n"
        },
        {
          "line": 116,
          "keyword": "React Query",
          "directive": "NEUTRAL",
          "statement": "- Default page data loads in Server Components; React Query hooks hydrate from server-provided DTOs or call server actions via fetcher utilities instead of instantiating Supabase clients in the browser.",
          "context": "- All mutations and privileged reads run through server actions wrapped by `withServerActionWrapper`; actions call Supabase via `createClient()` and return DTOs mapped in the service layer.\n- Server actions emit structured telemetry (shared logger/instrumentation helpers only\u2014no `console.*` in production) with duration, request ID, and normalized error codes from the `ServiceResult` utilities.\n- Default page data loads in Server Components; React Query hooks hydrate from server-provided DTOs or call server actions via fetcher utilities instead of instantiating Supabase clients in the browser.\n- Client-side Supabase access (`createBrowserComponentClient`) is reserved for real-time subscriptions or short-lived optimistic flows; wrap usage in documented helpers (`useSupabaseChannel`, scheduler utilities) and never expose raw table queries from the browser.\n- Mutating server actions document their cache strategy and invoke `revalidatePath`/`revalidateTag` accordingly, with integration tests asserting invalidation behaviour."
        },
        {
          "line": 120,
          "keyword": "React Query",
          "directive": "PROHIBITED",
          "statement": "- Domain React Query hooks do not new up Supabase clients; they consume server actions or Server Component props.",
          "context": "- Mutating server actions document their cache strategy and invoke `revalidatePath`/`revalidateTag` accordingly, with integration tests asserting invalidation behaviour.\n  **Acceptance Criteria**\n- Domain React Query hooks do not new up Supabase clients; they consume server actions or Server Component props.\n- Server action logs appear in structured telemetry pipelines with no stray `console` output.\n"
        },
        {
          "line": 126,
          "keyword": "React Query",
          "directive": "REQUIRED",
          "statement": "- Real-time hooks batch React Query invalidations using the scheduler pattern from `hooks/table-context/useTableContextRealtime.ts`; every subscription must register cleanup on unmount.",
          "context": "\n- Provide a lightweight `useSupabaseChannel` (or equivalent) helper that wraps `createBrowserComponentClient().channel`, handles subscribe/unsubscribe, and exposes typed payloads derived from `Database`.\n- Real-time hooks batch React Query invalidations using the scheduler pattern from `hooks/table-context/useTableContextRealtime.ts`; every subscription must register cleanup on unmount.\n- Domain hooks manage their own channel lifecycle; avoid cross-cutting singletons such as connection pools, optimistic-update managers, or offline queues under `services/real-time/*`.\n- Logging and metrics for live data stay inside dev tooling; production hooks should be silent and rely on React Query retries for resilience."
        },
        {
          "line": 128,
          "keyword": "React Query",
          "directive": "REQUIRED",
          "statement": "- Logging and metrics for live data stay inside dev tooling; production hooks should be silent and rely on React Query retries for resilience.",
          "context": "- Real-time hooks batch React Query invalidations using the scheduler pattern from `hooks/table-context/useTableContextRealtime.ts`; every subscription must register cleanup on unmount.\n- Domain hooks manage their own channel lifecycle; avoid cross-cutting singletons such as connection pools, optimistic-update managers, or offline queues under `services/real-time/*`.\n- Logging and metrics for live data stay inside dev tooling; production hooks should be silent and rely on React Query retries for resilience.\n- Any advanced offline/optimistic behaviour must sit behind domain-specific services with explicit acceptance criteria and integration tests\u2014not global managers.\n"
        },
        {
          "line": 218,
          "keyword": "React Query",
          "directive": "NEUTRAL",
          "statement": "- React Query manages all remote data; Zustand limited to UI-only concerns.",
          "context": "- `database.types.ts` regenerated automatically; builds fail on stale types.\n- Service layer adheres to `ServiceResult` contracts with centralized error handling.\n- React Query manages all remote data; Zustand limited to UI-only concerns.\n- Real-time updates flow through shared scheduler utilities with clean cleanup semantics.\n- Production builds meet Lighthouse budgets and pass all CI gates."
        },
        {
          "line": 14,
          "keyword": "Zustand",
          "directive": "PROHIBITED",
          "statement": "- **No Anti-Patterns**: Ban dual DB clients, React Query storming, business logic in Zustand stores, `Database = any` shims.",
          "context": "- **Security First**: RLS enabled by default, JWT claim helpers versioned with migrations, audit logging mandatory.\n- **Guardrails Upfront**: CI gates for lint, type-check, tests, schema\u2192type regeneration, Lighthouse budgets.\n- **No Anti-Patterns**: Ban dual DB clients, React Query storming, business logic in Zustand stores, `Database = any` shims.\n\n## 3. System Requirements & Patterns to Replicate"
        },
        {
          "line": 104,
          "keyword": "Zustand",
          "directive": "NEUTRAL",
          "statement": "- Zustand restricted to ephemeral UI state (selection, modal visibility) as demonstrated in `store/player-store.ts`, **ref is available upon request**.",
          "context": "\n- React Query is the sole remote data cache; defaults derive from `lib/query-client.ts` (non-zero `staleTime`, `refetchOnWindowFocus: false`).\n- Zustand restricted to ephemeral UI state (selection, modal visibility) as demonstrated in `store/player-store.ts`, **ref is available upon request**.\n- React Query hooks (`hooks/service-layer/use-service-query.ts`) become templates for entity/list/mutation operations; overrides for `staleTime: 0` require explicit approval.\n- Queries declare sane `staleTime`/`gcTime` per domain; zero-stale configs require explicit real-time justification and documented invalidation strategy."
        },
        {
          "line": 171,
          "keyword": "Zustand",
          "directive": "NEUTRAL",
          "statement": "- ESLint rule: forbid Supabase client creation in Zustand stores/components (legacy issue in `store/casino-store.ts`).",
          "context": "## 4. Anti-Pattern Guardrails\n\n- ESLint rule: forbid Supabase client creation in Zustand stores/components (legacy issue in `store/casino-store.ts`).\n- Lint: prohibit `staleTime: 0` unless file opted into real-time policy (violations previously in `hooks/rating-slip/useActiveRatingSlipsByTable.ts`, `components/ui/table/casino-table-ui-v2.tsx`, `components/ui/table/table-seat.tsx`).\n- Block `Database = any` shims, manual table redefinitions, and intersection-based schema rebuilds in type modules."
        },
        {
          "line": 218,
          "keyword": "Zustand",
          "directive": "NEUTRAL",
          "statement": "- React Query manages all remote data; Zustand limited to UI-only concerns.",
          "context": "- `database.types.ts` regenerated automatically; builds fail on stale types.\n- Service layer adheres to `ServiceResult` contracts with centralized error handling.\n- React Query manages all remote data; Zustand limited to UI-only concerns.\n- Real-time updates flow through shared scheduler utilities with clean cleanup semantics.\n- Production builds meet Lighthouse budgets and pass all CI gates."
        },
        {
          "line": 103,
          "keyword": "staleTime",
          "directive": "NEUTRAL",
          "statement": "- React Query is the sole remote data cache; defaults derive from `lib/query-client.ts` (non-zero `staleTime`, `refetchOnWindowFocus: false`).",
          "context": "### 3.4 State Management\n\n- React Query is the sole remote data cache; defaults derive from `lib/query-client.ts` (non-zero `staleTime`, `refetchOnWindowFocus: false`).\n- Zustand restricted to ephemeral UI state (selection, modal visibility) as demonstrated in `store/player-store.ts`, **ref is available upon request**.\n- React Query hooks (`hooks/service-layer/use-service-query.ts`) become templates for entity/list/mutation operations; overrides for `staleTime: 0` require explicit approval."
        },
        {
          "line": 105,
          "keyword": "staleTime",
          "directive": "REQUIRED",
          "statement": "- React Query hooks (`hooks/service-layer/use-service-query.ts`) become templates for entity/list/mutation operations; overrides for `staleTime: 0` require explicit approval.",
          "context": "- React Query is the sole remote data cache; defaults derive from `lib/query-client.ts` (non-zero `staleTime`, `refetchOnWindowFocus: false`).\n- Zustand restricted to ephemeral UI state (selection, modal visibility) as demonstrated in `store/player-store.ts`, **ref is available upon request**.\n- React Query hooks (`hooks/service-layer/use-service-query.ts`) become templates for entity/list/mutation operations; overrides for `staleTime: 0` require explicit approval.\n- Queries declare sane `staleTime`/`gcTime` per domain; zero-stale configs require explicit real-time justification and documented invalidation strategy.\n- Query keys follow the `[domain-scope, entity, identifier]` pattern (`['visit', 'list', casinoId]`) to keep invalidation predictable; helper modules expose canonical keys per domain."
        },
        {
          "line": 106,
          "keyword": "staleTime",
          "directive": "REQUIRED",
          "statement": "- Queries declare sane `staleTime`/`gcTime` per domain; zero-stale configs require explicit real-time justification and documented invalidation strategy.",
          "context": "- Zustand restricted to ephemeral UI state (selection, modal visibility) as demonstrated in `store/player-store.ts`, **ref is available upon request**.\n- React Query hooks (`hooks/service-layer/use-service-query.ts`) become templates for entity/list/mutation operations; overrides for `staleTime: 0` require explicit approval.\n- Queries declare sane `staleTime`/`gcTime` per domain; zero-stale configs require explicit real-time justification and documented invalidation strategy.\n- Query keys follow the `[domain-scope, entity, identifier]` pattern (`['visit', 'list', casinoId]`) to keep invalidation predictable; helper modules expose canonical keys per domain.\n- Mutations perform cache updates via `invalidateQueries` or targeted `setQueryData`; optimistic updates stay opt-in and encapsulated in domain helpers."
        },
        {
          "line": 172,
          "keyword": "staleTime",
          "directive": "REQUIRED",
          "statement": "- Lint: prohibit `staleTime: 0` unless file opted into real-time policy (violations previously in `hooks/rating-slip/useActiveRatingSlipsByTable.ts`, `components/ui/table/casino-table-ui-v2.tsx`, `components/ui/table/table-seat.tsx`).",
          "context": "\n- ESLint rule: forbid Supabase client creation in Zustand stores/components (legacy issue in `store/casino-store.ts`).\n- Lint: prohibit `staleTime: 0` unless file opted into real-time policy (violations previously in `hooks/rating-slip/useActiveRatingSlipsByTable.ts`, `components/ui/table/casino-table-ui-v2.tsx`, `components/ui/table/table-seat.tsx`).\n- Block `Database = any` shims, manual table redefinitions, and intersection-based schema rebuilds in type modules.\n- **Service Layer Type Enforcement**:"
        },
        {
          "line": 187,
          "keyword": "global state",
          "directive": "PROHIBITED",
          "statement": "- Ban service-layer factories that cache or mutate global state (e.g., `ServiceFactory` performance caches); service creation stays pure and request-scoped.",
          "context": "  - **Interfaces must be complete**: Every public method in the service implementation must have a corresponding type signature in the interface. No silent additions via type casting.\n- Ban global real-time managers (connection pools, optimistic/offline singletons); enforce hook-scoped subscriptions with automated tests.\n- Ban service-layer factories that cache or mutate global state (e.g., `ServiceFactory` performance caches); service creation stays pure and request-scoped.\n- Ban bulk library imports (HeroUI/Lucide) and dev console logging in production paths.\n- **Schema Consistency: Enforce UUID Primary Keys Universally**:"
        },
        {
          "line": 106,
          "keyword": "real-time",
          "directive": "REQUIRED",
          "statement": "- Queries declare sane `staleTime`/`gcTime` per domain; zero-stale configs require explicit real-time justification and documented invalidation strategy.",
          "context": "- Zustand restricted to ephemeral UI state (selection, modal visibility) as demonstrated in `store/player-store.ts`, **ref is available upon request**.\n- React Query hooks (`hooks/service-layer/use-service-query.ts`) become templates for entity/list/mutation operations; overrides for `staleTime: 0` require explicit approval.\n- Queries declare sane `staleTime`/`gcTime` per domain; zero-stale configs require explicit real-time justification and documented invalidation strategy.\n- Query keys follow the `[domain-scope, entity, identifier]` pattern (`['visit', 'list', casinoId]`) to keep invalidation predictable; helper modules expose canonical keys per domain.\n- Mutations perform cache updates via `invalidateQueries` or targeted `setQueryData`; optimistic updates stay opt-in and encapsulated in domain helpers."
        },
        {
          "line": 117,
          "keyword": "real-time",
          "directive": "PROHIBITED",
          "statement": "- Client-side Supabase access (`createBrowserComponentClient`) is reserved for real-time subscriptions or short-lived optimistic flows; wrap usage in documented helpers (`useSupabaseChannel`, scheduler utilities) and never expose raw table queries from the browser.",
          "context": "- Server actions emit structured telemetry (shared logger/instrumentation helpers only\u2014no `console.*` in production) with duration, request ID, and normalized error codes from the `ServiceResult` utilities.\n- Default page data loads in Server Components; React Query hooks hydrate from server-provided DTOs or call server actions via fetcher utilities instead of instantiating Supabase clients in the browser.\n- Client-side Supabase access (`createBrowserComponentClient`) is reserved for real-time subscriptions or short-lived optimistic flows; wrap usage in documented helpers (`useSupabaseChannel`, scheduler utilities) and never expose raw table queries from the browser.\n- Mutating server actions document their cache strategy and invoke `revalidatePath`/`revalidateTag` accordingly, with integration tests asserting invalidation behaviour.\n  **Acceptance Criteria**"
        },
        {
          "line": 123,
          "keyword": "real-time",
          "directive": "NEUTRAL",
          "statement": "### 3.6 Real-Time & Invalidations",
          "context": "- Server action logs appear in structured telemetry pipelines with no stray `console` output.\n\n### 3.6 Real-Time & Invalidations\n\n- Provide a lightweight `useSupabaseChannel` (or equivalent) helper that wraps `createBrowserComponentClient().channel`, handles subscribe/unsubscribe, and exposes typed payloads derived from `Database`."
        },
        {
          "line": 126,
          "keyword": "real-time",
          "directive": "REQUIRED",
          "statement": "- Real-time hooks batch React Query invalidations using the scheduler pattern from `hooks/table-context/useTableContextRealtime.ts`; every subscription must register cleanup on unmount.",
          "context": "\n- Provide a lightweight `useSupabaseChannel` (or equivalent) helper that wraps `createBrowserComponentClient().channel`, handles subscribe/unsubscribe, and exposes typed payloads derived from `Database`.\n- Real-time hooks batch React Query invalidations using the scheduler pattern from `hooks/table-context/useTableContextRealtime.ts`; every subscription must register cleanup on unmount.\n- Domain hooks manage their own channel lifecycle; avoid cross-cutting singletons such as connection pools, optimistic-update managers, or offline queues under `services/real-time/*`.\n- Logging and metrics for live data stay inside dev tooling; production hooks should be silent and rely on React Query retries for resilience."
        },
        {
          "line": 127,
          "keyword": "real-time",
          "directive": "PROHIBITED",
          "statement": "- Domain hooks manage their own channel lifecycle; avoid cross-cutting singletons such as connection pools, optimistic-update managers, or offline queues under `services/real-time/*`.",
          "context": "- Provide a lightweight `useSupabaseChannel` (or equivalent) helper that wraps `createBrowserComponentClient().channel`, handles subscribe/unsubscribe, and exposes typed payloads derived from `Database`.\n- Real-time hooks batch React Query invalidations using the scheduler pattern from `hooks/table-context/useTableContextRealtime.ts`; every subscription must register cleanup on unmount.\n- Domain hooks manage their own channel lifecycle; avoid cross-cutting singletons such as connection pools, optimistic-update managers, or offline queues under `services/real-time/*`.\n- Logging and metrics for live data stay inside dev tooling; production hooks should be silent and rely on React Query retries for resilience.\n- Any advanced offline/optimistic behaviour must sit behind domain-specific services with explicit acceptance criteria and integration tests\u2014not global managers."
        },
        {
          "line": 172,
          "keyword": "real-time",
          "directive": "REQUIRED",
          "statement": "- Lint: prohibit `staleTime: 0` unless file opted into real-time policy (violations previously in `hooks/rating-slip/useActiveRatingSlipsByTable.ts`, `components/ui/table/casino-table-ui-v2.tsx`, `components/ui/table/table-seat.tsx`).",
          "context": "\n- ESLint rule: forbid Supabase client creation in Zustand stores/components (legacy issue in `store/casino-store.ts`).\n- Lint: prohibit `staleTime: 0` unless file opted into real-time policy (violations previously in `hooks/rating-slip/useActiveRatingSlipsByTable.ts`, `components/ui/table/casino-table-ui-v2.tsx`, `components/ui/table/table-seat.tsx`).\n- Block `Database = any` shims, manual table redefinitions, and intersection-based schema rebuilds in type modules.\n- **Service Layer Type Enforcement**:"
        },
        {
          "line": 186,
          "keyword": "real-time",
          "directive": "PROHIBITED",
          "statement": "- Ban global real-time managers (connection pools, optimistic/offline singletons); enforce hook-scoped subscriptions with automated tests.",
          "context": "  - **Remove all deprecated class wrappers** marked `@deprecated` that delegate to functional services (violation: `VisitService` class in `services/visit/index.ts`). Delete deprecated code instead of maintaining dual APIs.\n  - **Interfaces must be complete**: Every public method in the service implementation must have a corresponding type signature in the interface. No silent additions via type casting.\n- Ban global real-time managers (connection pools, optimistic/offline singletons); enforce hook-scoped subscriptions with automated tests.\n- Ban service-layer factories that cache or mutate global state (e.g., `ServiceFactory` performance caches); service creation stays pure and request-scoped.\n- Ban bulk library imports (HeroUI/Lucide) and dev console logging in production paths."
        },
        {
          "line": 210,
          "keyword": "real-time",
          "directive": "REQUIRED",
          "statement": "- **Phase 3 (Performance Hardening)** \u2013 Apply bundle optimizations, real-time scheduler integration, enforce budgets in CI.",
          "context": "- **Phase 1 (Security Week)** \u2013 RLS + JWT helpers, audit logging, compliance tables.\n- **Phase 2 (Core Domains)** \u2013 Deliver Player \u2192 Visit \u2192 Rating Slip \u2192 Table Context vertical slices with tests.\n- **Phase 3 (Performance Hardening)** \u2013 Apply bundle optimizations, real-time scheduler integration, enforce budgets in CI.\n- **Phase 4 (Compliance & Reporting)** \u2013 Implement MTL workflows, CTR exports, staff tooling.\n"
        },
        {
          "line": 219,
          "keyword": "real-time",
          "directive": "NEUTRAL",
          "statement": "- Real-time updates flow through shared scheduler utilities with clean cleanup semantics.",
          "context": "- Service layer adheres to `ServiceResult` contracts with centralized error handling.\n- React Query manages all remote data; Zustand limited to UI-only concerns.\n- Real-time updates flow through shared scheduler utilities with clean cleanup semantics.\n- Production builds meet Lighthouse budgets and pass all CI gates.\n- Rating-slip domain delivered through the four-week decoupling plan and documented via ADR."
        },
        {
          "line": 103,
          "keyword": "cache",
          "directive": "NEUTRAL",
          "statement": "- React Query is the sole remote data cache; defaults derive from `lib/query-client.ts` (non-zero `staleTime`, `refetchOnWindowFocus: false`).",
          "context": "### 3.4 State Management\n\n- React Query is the sole remote data cache; defaults derive from `lib/query-client.ts` (non-zero `staleTime`, `refetchOnWindowFocus: false`).\n- Zustand restricted to ephemeral UI state (selection, modal visibility) as demonstrated in `store/player-store.ts`, **ref is available upon request**.\n- React Query hooks (`hooks/service-layer/use-service-query.ts`) become templates for entity/list/mutation operations; overrides for `staleTime: 0` require explicit approval."
        },
        {
          "line": 108,
          "keyword": "cache",
          "directive": "NEUTRAL",
          "statement": "- Mutations perform cache updates via `invalidateQueries` or targeted `setQueryData`; optimistic updates stay opt-in and encapsulated in domain helpers.",
          "context": "- Queries declare sane `staleTime`/`gcTime` per domain; zero-stale configs require explicit real-time justification and documented invalidation strategy.\n- Query keys follow the `[domain-scope, entity, identifier]` pattern (`['visit', 'list', casinoId]`) to keep invalidation predictable; helper modules expose canonical keys per domain.\n- Mutations perform cache updates via `invalidateQueries` or targeted `setQueryData`; optimistic updates stay opt-in and encapsulated in domain helpers.\n- All React Query hooks wrap service-layer DTOs\u2014never raw Supabase rows\u2014and surface consistent loading/error contracts for UI components.\n- Any advanced offline/optimistic behaviour must sit behind domain-specific services with explicit acceptance criteria and integration tests\u2014not global managers."
        },
        {
          "line": 118,
          "keyword": "cache",
          "directive": "NEUTRAL",
          "statement": "- Mutating server actions document their cache strategy and invoke `revalidatePath`/`revalidateTag` accordingly, with integration tests asserting invalidation behaviour.",
          "context": "- Default page data loads in Server Components; React Query hooks hydrate from server-provided DTOs or call server actions via fetcher utilities instead of instantiating Supabase clients in the browser.\n- Client-side Supabase access (`createBrowserComponentClient`) is reserved for real-time subscriptions or short-lived optimistic flows; wrap usage in documented helpers (`useSupabaseChannel`, scheduler utilities) and never expose raw table queries from the browser.\n- Mutating server actions document their cache strategy and invoke `revalidatePath`/`revalidateTag` accordingly, with integration tests asserting invalidation behaviour.\n  **Acceptance Criteria**\n- Domain React Query hooks do not new up Supabase clients; they consume server actions or Server Component props."
        },
        {
          "line": 187,
          "keyword": "cache",
          "directive": "PROHIBITED",
          "statement": "- Ban service-layer factories that cache or mutate global state (e.g., `ServiceFactory` performance caches); service creation stays pure and request-scoped.",
          "context": "  - **Interfaces must be complete**: Every public method in the service implementation must have a corresponding type signature in the interface. No silent additions via type casting.\n- Ban global real-time managers (connection pools, optimistic/offline singletons); enforce hook-scoped subscriptions with automated tests.\n- Ban service-layer factories that cache or mutate global state (e.g., `ServiceFactory` performance caches); service creation stays pure and request-scoped.\n- Ban bulk library imports (HeroUI/Lucide) and dev console logging in production paths.\n- **Schema Consistency: Enforce UUID Primary Keys Universally**:"
        },
        {
          "line": 187,
          "keyword": "cache",
          "directive": "PROHIBITED",
          "statement": "- Ban service-layer factories that cache or mutate global state (e.g., `ServiceFactory` performance caches); service creation stays pure and request-scoped.",
          "context": "  - **Interfaces must be complete**: Every public method in the service implementation must have a corresponding type signature in the interface. No silent additions via type casting.\n- Ban global real-time managers (connection pools, optimistic/offline singletons); enforce hook-scoped subscriptions with automated tests.\n- Ban service-layer factories that cache or mutate global state (e.g., `ServiceFactory` performance caches); service creation stays pure and request-scoped.\n- Ban bulk library imports (HeroUI/Lucide) and dev console logging in production paths.\n- **Schema Consistency: Enforce UUID Primary Keys Universally**:"
        },
        {
          "line": 203,
          "keyword": "cache",
          "directive": "NEUTRAL",
          "statement": "- Rollback plan: keep the previous build artifact and migration revert scripts ready; publish a playbook describing how to restore the last known good schema, redeploy, and invalidate caches.",
          "context": "- Feature flags: wrap risky features with kill switches; store flag metadata in Supabase or LaunchDarkly and document rollout/rollback steps.\n- API compatibility: version DTOs when breaking changes occur and document deprecation timelines so downstream teams can migrate safely.\n- Rollback plan: keep the previous build artifact and migration revert scripts ready; publish a playbook describing how to restore the last known good schema, redeploy, and invalidate caches.\n\n## 6. Implementation Roadmap"
        }
      ],
      "patterns/SERVER_ACTIONS_ARCHITECTURE.md": [
        {
          "line": 279,
          "keyword": "React Query",
          "directive": "PROHIBITED",
          "statement": "- **DON'T** use server actions for queries (use React Query hooks instead)",
          "context": "- **DON'T** include sensitive data in audit metadata\n- **DON'T** call server actions from other server actions (call services directly)\n- **DON'T** use server actions for queries (use React Query hooks instead)\n\n---"
        },
        {
          "line": 253,
          "keyword": "real-time",
          "directive": "NEUTRAL",
          "statement": "\u2502  RLS Policies \u2192 Database Operations \u2192 Real-time Updates    \u2502",
          "context": "\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                  Supabase / PostgreSQL                      \u2502\n\u2502  RLS Policies \u2192 Database Operations \u2192 Real-time Updates    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n```"
        }
      ],
      "patterns/SERVICE_TEMPLATE.md": [
        {
          "line": 587,
          "keyword": "global state",
          "directive": "NEUTRAL",
          "statement": "- Global state/singletons",
          "context": "- `ReturnType` inferred interfaces\n- Deprecated wrapper functions\n- Global state/singletons\n\n### Mining Process"
        }
      ],
      "patterns/SERVICE_RESPONSIBILITY_MATRIX.md": [
        {
          "line": 379,
          "keyword": "React Query",
          "directive": "NEUTRAL",
          "statement": "// 4. Invalidate React Query caches",
          "context": "    });\n\n    // 4. Invalidate React Query caches\n    // (handled by withServerAction telemetry)\n"
        },
        {
          "line": 83,
          "keyword": "cache",
          "directive": "NEUTRAL",
          "statement": "\u2502         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25b6 Updates RatingSlip.points (denormalized cache)       \u2502",
          "context": "\u2502         \u2502  \u2022 Updates tier progression       \u2502  \u2022 Immutable audit trail   \u2502\n\u2502         \u2502                                    \u2502                            \u2502\n\u2502         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25b6 Updates RatingSlip.points (denormalized cache)       \u2502\n\u2502                                                                            \u2502\n\u2502         Both services read from Session/Telemetry context (read-only)     \u2502"
        },
        {
          "line": 100,
          "keyword": "cache",
          "directive": "NEUTRAL",
          "statement": "| **Telemetry** | `RatingSlipService` | \u2022 Average bet<br>\u2022 Time played<br>\u2022 Game settings<br>\u2022 Seat number<br>\u2022 **points** (cache) | \u2022 Player (FK)<br>\u2022 Visit (FK)<br>\u2022 Gaming Table (FK) | \u2013 | **Gameplay measurement** |",
          "context": "| **Location** | `CasinoService` | \u2022 Casino details<br>\u2022 Tables<br>\u2022 Game configs<br>\u2022 **Casino settings**<br>\u2022 Gaming day config | \u2013 | \u2022 Visits<br>\u2022 RatingSlips<br>\u2022 MTL entries | Venue management & configuration |\n| **Session** | `VisitService` | \u2022 Visit sessions<br>\u2022 Check-in/out<br>\u2022 Visit status | \u2022 Player (FK)<br>\u2022 Casino (FK) | \u2022 RatingSlips<br>\u2022 Financials<br>\u2022 MTL entries | Session lifecycle |\n| **Telemetry** | `RatingSlipService` | \u2022 Average bet<br>\u2022 Time played<br>\u2022 Game settings<br>\u2022 Seat number<br>\u2022 **points** (cache) | \u2022 Player (FK)<br>\u2022 Visit (FK)<br>\u2022 Gaming Table (FK) | \u2013 | **Gameplay measurement** |\n| **Reward** \ud83c\udd95 | `LoyaltyService` | \u2022 **Points calculation logic**<br>\u2022 Loyalty ledger<br>\u2022 Tier status<br>\u2022 Tier rules<br>\u2022 Preferences | \u2022 Player (FK)<br>\u2022 RatingSlip (FK)<br>\u2022 Visit (FK) | \u2022 Points history<br>\u2022 Tier progression | **Reward policy & assignment** |\n| **Finance** | `PlayerFinancialService` | \u2022 Cash in/out<br>\u2022 Chips tracking<br>\u2022 Reconciliation | \u2022 Player (FK)<br>\u2022 Visit (FK)<br>\u2022 RatingSlip (FK) | \u2013 | Financial tracking |"
        },
        {
          "line": 333,
          "keyword": "cache",
          "directive": "NEUTRAL",
          "statement": "- `points` - **Denormalized cache from Loyalty** (for query performance)",
          "context": "\n**STORES BUT DOESN'T OWN:**\n- `points` - **Denormalized cache from Loyalty** (for query performance)\n- Source of truth: `loyalty_ledger.points_earned`\n"
        },
        {
          "line": 338,
          "keyword": "cache",
          "directive": "NEUTRAL",
          "statement": "**Key Change**: RatingSlip.points becomes a **read-optimized cache**, NOT the source of truth.",
          "context": "**BOUNDED CONTEXT**: \"What gameplay activity occurred?\"\n\n**Key Change**: RatingSlip.points becomes a **read-optimized cache**, NOT the source of truth.\n\n---"
        },
        {
          "line": 374,
          "keyword": "cache",
          "directive": "NEUTRAL",
          "statement": "// 3. Update RatingSlip with calculated points (denormalized cache)",
          "context": "    }\n\n    // 3. Update RatingSlip with calculated points (denormalized cache)\n    await ratingSlipService.update(id, {\n      points: loyaltyResult.data.pointsEarned"
        },
        {
          "line": 379,
          "keyword": "cache",
          "directive": "NEUTRAL",
          "statement": "// 4. Invalidate React Query caches",
          "context": "    });\n\n    // 4. Invalidate React Query caches\n    // (handled by withServerAction telemetry)\n"
        },
        {
          "line": 397,
          "keyword": "cache",
          "directive": "NEUTRAL",
          "statement": "3. **RatingSlip caches result** - points field for fast queries",
          "context": "1. **Client orchestrates** - Server action coordinates both services\n2. **Loyalty owns calculation** - Business logic in Loyalty.calculatePoints()\n3. **RatingSlip caches result** - points field for fast queries\n4. **LoyaltyLedger is source of truth** - Audit trail preserved\n"
        },
        {
          "line": 594,
          "keyword": "cache",
          "directive": "NEUTRAL",
          "statement": "\u2502   points: calculated   \u2502 \u2190 Denormalized cache",
          "context": "         \u2502 RatingSlipService      \u2502\n         \u2502 .update(id, {          \u2502\n         \u2502   points: calculated   \u2502 \u2190 Denormalized cache\n         \u2502 })                     \u2502\n         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518"
        },
        {
          "line": 721,
          "keyword": "cache",
          "directive": "NEUTRAL",
          "statement": "// 3. Cache result in RatingSlip (optimization)",
          "context": "  });\n\n  // 3. Cache result in RatingSlip (optimization)\n  await ratingSlipService.update(id, {\n    points: loyalty.data.pointsEarned"
        }
      ],
      "patterns/BALANCED_ARCHITECTURE_QUICK.md": [
        {
          "line": 83,
          "keyword": "React Query",
          "directive": "NEUTRAL",
          "statement": "// 4. HOOK: React Query",
          "context": "}\n\n// 4. HOOK: React Query\n// hooks/player/use-create-player.ts\nexport function useCreatePlayer() {"
        },
        {
          "line": 434,
          "keyword": "React Query",
          "directive": "NEUTRAL",
          "statement": "UIH[UI Hooks - React Query]",
          "context": "    subgraph \"UI Layer (Client Components)\"\n        UI[Components]\n        UIH[UI Hooks - React Query]\n        UIState[UI State - Zustand]\n    end"
        },
        {
          "line": 435,
          "keyword": "Zustand",
          "directive": "NEUTRAL",
          "statement": "UIState[UI State - Zustand]",
          "context": "        UI[Components]\n        UIH[UI Hooks - React Query]\n        UIState[UI State - Zustand]\n    end\n"
        },
        {
          "line": 218,
          "keyword": "real-time",
          "directive": "NEUTRAL",
          "statement": "- Real-time for specific domains",
          "context": "### \ud83c\udfaf Examples\n- Visit start (Player + Casino + Visit)\n- Real-time for specific domains\n- Search across Player + Visit\n"
        },
        {
          "line": 236,
          "keyword": "real-time",
          "directive": "NEUTRAL",
          "statement": "| **Add real-time to Player** | VERTICAL | Domain-specific | 1 week |",
          "context": "| **Upgrade Supabase client** | HORIZONTAL | ALL services affected | 2 days |\n| **Visit start flow** | HYBRID | 3 services, orchestration | 3 days |\n| **Add real-time to Player** | VERTICAL | Domain-specific | 1 week |\n| **Create error catalog** | HORIZONTAL (defer) | Not urgent | Future |\n| **Split PlayerService (>500 lines)** | HORIZONTAL | Refactoring | 2 hours |"
        },
        {
          "line": 249,
          "keyword": "real-time",
          "directive": "REQUIRED",
          "statement": "\u2705 **Manual refresh** - No real-time for MVP (Week 7 enhancement)",
          "context": "\u2705 **Consolidated files** - 1 file/service until >500 lines (defer split)\n\u2705 **Inline validation** - No separate `validation.ts` until 3+ reuses\n\u2705 **Manual refresh** - No real-time for MVP (Week 7 enhancement)\n\u2705 **Basic lists** - No pagination until >100 records\n\u2705 **Simple errors** - String messages, not catalogs"
        },
        {
          "line": 349,
          "keyword": "real-time",
          "directive": "NEUTRAL",
          "statement": "### Week 7: Real-Time Infrastructure (HORIZONTAL)",
          "context": "---\n\n### Week 7: Real-Time Infrastructure (HORIZONTAL)\n```\n\u2705 useSupabaseChannel wrapper (infrastructure)"
        },
        {
          "line": 353,
          "keyword": "real-time",
          "directive": "REQUIRED",
          "statement": "\u2705 Domain real-time hooks (Player, Visit, RatingSlip)",
          "context": "\u2705 useSupabaseChannel wrapper (infrastructure)\n\u2705 Batch invalidation scheduler\n\u2705 Domain real-time hooks (Player, Visit, RatingSlip)\n\u2705 Memory leak prevention\n```"
        },
        {
          "line": 357,
          "keyword": "real-time",
          "directive": "NEUTRAL",
          "statement": "**Deliverable**: Real-time synchronization across domains",
          "context": "```\n\n**Deliverable**: Real-time synchronization across domains\n\n---"
        },
        {
          "line": 456,
          "keyword": "real-time",
          "directive": "NEUTRAL",
          "statement": "RT[Real-time]",
          "context": "        DB[(PostgreSQL)]\n        RLS[RLS Policies]\n        RT[Real-time]\n    end\n"
        },
        {
          "line": 160,
          "keyword": "cache",
          "directive": "NEUTRAL",
          "statement": "- Batch cache invalidation",
          "context": "### \ud83c\udfaf Examples\n- `executeOperation` wrapper (affects all services)\n- Batch cache invalidation\n- Supabase client upgrade\n- Structured logging"
        },
        {
          "line": 441,
          "keyword": "cache",
          "directive": "NEUTRAL",
          "statement": "Cache[Cache Strategies]",
          "context": "        SA[Server Actions]\n        Middleware[Middleware]\n        Cache[Cache Strategies]\n    end\n"
        },
        {
          "line": 441,
          "keyword": "cache",
          "directive": "NEUTRAL",
          "statement": "Cache[Cache Strategies]",
          "context": "        SA[Server Actions]\n        Middleware[Middleware]\n        Cache[Cache Strategies]\n    end\n"
        },
        {
          "line": 477,
          "keyword": "cache",
          "directive": "NEUTRAL",
          "statement": "class SA,Middleware,Cache actionLayer",
          "context": "\n    class UI,UIH,UIState uiLayer\n    class SA,Middleware,Cache actionLayer\n    class CRUD,Business,Queries,Transforms,Validation serviceLayer\n    class Supabase,DB,RLS,RT dataLayer"
        }
      ],
      "patterns/MTL_DOMAIN_CLASSIFICATION.md": [
        {
          "line": 135,
          "keyword": "React Query",
          "directive": "NEUTRAL",
          "statement": "| **UI / API** | Record form, threshold dashboard, report downloads. | Lean React Query + Next.js app |",
          "context": "| **Infrastructure** | Persist to PostgreSQL via Prisma; expose aggregation views; compute gaming day via trigger. | Minimal adapters only |\n| **Integration** | Read-only enrichment from Loyalty and RatingSlip; exports to CSV. | No bidirectional coupling |\n| **UI / API** | Record form, threshold dashboard, report downloads. | Lean React Query + Next.js app |\n\n---"
        },
        {
          "line": 152,
          "keyword": "React Query",
          "directive": "NEUTRAL",
          "statement": "- React Query caching covers all real-time needs.",
          "context": "- ~1 k transactions/day \u2192 no need for CQRS, caching, or background jobs.  \n- Postgres views deliver sub-500 ms aggregation queries.  \n- React Query caching covers all real-time needs.\n\n---"
        },
        {
          "line": 152,
          "keyword": "real-time",
          "directive": "NEUTRAL",
          "statement": "- React Query caching covers all real-time needs.",
          "context": "- ~1 k transactions/day \u2192 no need for CQRS, caching, or background jobs.  \n- Postgres views deliver sub-500 ms aggregation queries.  \n- React Query caching covers all real-time needs.\n\n---"
        }
      ],
      "adr/NEXT_STEPS_REPORT.md": [
        {
          "line": 20,
          "keyword": "React Query",
          "directive": "NEUTRAL",
          "statement": "- **Week 3 (HORIZONTAL)**: React Query + Zustand for ALL domains \u2192 enables vertical UI",
          "context": "**Hybrid Pattern**:\n- **Week 2 (HORIZONTAL)**: Complete ALL service infrastructure \u2192 enables Phase 3\n- **Week 3 (HORIZONTAL)**: React Query + Zustand for ALL domains \u2192 enables vertical UI\n- **Weeks 4-5 (VERTICAL)**: Player \u2192 Visit \u2192 RatingSlip UI (one domain at a time)\n- **Weeks 6-8 (HORIZONTAL)**: Performance, security, deployment across ALL domains"
        },
        {
          "line": 234,
          "keyword": "React Query",
          "directive": "NEUTRAL",
          "statement": "**React Query Configuration** - **Affects ALL domains**:",
          "context": "#### Days 1-2: HORIZONTAL Infrastructure Setup\n\n**React Query Configuration** - **Affects ALL domains**:\n```\nlib/"
        },
        {
          "line": 237,
          "keyword": "React Query",
          "directive": "NEUTRAL",
          "statement": "\u2514\u2500\u2500 query-client.ts              # React Query configuration",
          "context": "```\nlib/\n\u2514\u2500\u2500 query-client.ts              # React Query configuration\n\nConfiguration:"
        },
        {
          "line": 246,
          "keyword": "React Query",
          "directive": "NEUTRAL",
          "statement": "**Key Decision**: React Query for ALL remote state (server data), Zustand ONLY for ephemeral UI state.",
          "context": "```\n\n**Key Decision**: React Query for ALL remote state (server data), Zustand ONLY for ephemeral UI state.\n\n**Server Action Wrapper** - **Affects ALL actions**:"
        },
        {
          "line": 286,
          "keyword": "React Query",
          "directive": "NEUTRAL",
          "statement": "**Pattern**: Wrap ServiceResult \u2192 throw on error \u2192 React Query error boundary",
          "context": "```\n\n**Pattern**: Wrap ServiceResult \u2192 throw on error \u2192 React Query error boundary\n\n#### Vertical Slice 3: Domain Query Hooks (Player Example)"
        },
        {
          "line": 578,
          "keyword": "React Query",
          "directive": "NEUTRAL",
          "statement": "- React Query + Zustand infrastructure \u2192 ALL domains benefit",
          "context": "\n**HORIZONTAL Week** (Week 3):\n- React Query + Zustand infrastructure \u2192 ALL domains benefit\n\n**VERTICAL Weeks** (Weeks 4-5):"
        },
        {
          "line": 653,
          "keyword": "React Query",
          "directive": "NEUTRAL",
          "statement": "**Pattern**: Batch invalidations to prevent React Query thrashing on rapid updates.",
          "context": "```\n\n**Pattern**: Batch invalidations to prevent React Query thrashing on rapid updates.\n\n#### Vertical Slice 13: Domain Real-Time Hooks (Player Example)"
        },
        {
          "line": 696,
          "keyword": "React Query",
          "directive": "REQUIRED",
          "statement": "- \u2705 React Query managing 100% of server data",
          "context": "## Phase 3 Success Criteria\n\n- \u2705 React Query managing 100% of server data\n- \u2705 Zustand stores contain ZERO server data (UI state only)\n- \u2705 All domain UIs functional (Player, Visit, RatingSlip)"
        },
        {
          "line": 808,
          "keyword": "React Query",
          "directive": "REQUIRED",
          "statement": "| React Query learning curve | Low | Medium | Use proven patterns from documentation, simple wrapper first |",
          "context": "| MTL regulatory logic complexity | Medium | High | Reference PlayerFinancial patterns, time-box at 8h |\n| Search pattern rewrite overruns | Medium | Medium | Time-box PT-1 mining at 4h per module, rewrite if needed |\n| React Query learning curve | Low | Medium | Use proven patterns from documentation, simple wrapper first |\n| Real-time memory leaks | Medium | High | Strict cleanup testing, useEffect dependency audits |\n| Performance budget miss | Low | High | Weekly Lighthouse checks starting Week 4 |"
        },
        {
          "line": 825,
          "keyword": "React Query",
          "directive": "REQUIRED",
          "statement": "- \u2705 React Query managing all remote state",
          "context": "### Phase 3 (Week 6 Target)\n- \u2705 Player, Visit, RatingSlip UIs complete\n- \u2705 React Query managing all remote state\n- \u2705 Real-time updates <1s latency\n- \u2705 Zero Zustand state pollution"
        },
        {
          "line": 20,
          "keyword": "Zustand",
          "directive": "NEUTRAL",
          "statement": "- **Week 3 (HORIZONTAL)**: React Query + Zustand for ALL domains \u2192 enables vertical UI",
          "context": "**Hybrid Pattern**:\n- **Week 2 (HORIZONTAL)**: Complete ALL service infrastructure \u2192 enables Phase 3\n- **Week 3 (HORIZONTAL)**: React Query + Zustand for ALL domains \u2192 enables vertical UI\n- **Weeks 4-5 (VERTICAL)**: Player \u2192 Visit \u2192 RatingSlip UI (one domain at a time)\n- **Weeks 6-8 (HORIZONTAL)**: Performance, security, deployment across ALL domains"
        },
        {
          "line": 246,
          "keyword": "Zustand",
          "directive": "NEUTRAL",
          "statement": "**Key Decision**: React Query for ALL remote state (server data), Zustand ONLY for ephemeral UI state.",
          "context": "```\n\n**Key Decision**: React Query for ALL remote state (server data), Zustand ONLY for ephemeral UI state.\n\n**Server Action Wrapper** - **Affects ALL actions**:"
        },
        {
          "line": 250,
          "keyword": "Zustand",
          "directive": "NEUTRAL",
          "statement": "**Zustand UI Store Pattern** - **Affects ALL UI state**:",
          "context": "**Server Action Wrapper** - **Affects ALL actions**:\n\n**Zustand UI Store Pattern** - **Affects ALL UI state**:\n- Modal/dialog visibility\n- Selected IDs (ephemeral)"
        },
        {
          "line": 435,
          "keyword": "Zustand",
          "directive": "NEUTRAL",
          "statement": "#### Vertical Slice 7: Zustand UI Store (Minimal)",
          "context": "```\n\n#### Vertical Slice 7: Zustand UI Store (Minimal)\n```typescript\n// store/ui-store.ts"
        },
        {
          "line": 457,
          "keyword": "Zustand",
          "directive": "PROHIBITED",
          "statement": "**IMPORTANT**: Zustand stores NEVER contain server data (players, visits, etc.). Only ephemeral UI state (modal visibility, selected IDs, navigation state).",
          "context": "```\n\n**IMPORTANT**: Zustand stores NEVER contain server data (players, visits, etc.). Only ephemeral UI state (modal visibility, selected IDs, navigation state).\n\n---"
        },
        {
          "line": 578,
          "keyword": "Zustand",
          "directive": "NEUTRAL",
          "statement": "- React Query + Zustand infrastructure \u2192 ALL domains benefit",
          "context": "\n**HORIZONTAL Week** (Week 3):\n- React Query + Zustand infrastructure \u2192 ALL domains benefit\n\n**VERTICAL Weeks** (Weeks 4-5):"
        },
        {
          "line": 697,
          "keyword": "Zustand",
          "directive": "REQUIRED",
          "statement": "- \u2705 Zustand stores contain ZERO server data (UI state only)",
          "context": "\n- \u2705 React Query managing 100% of server data\n- \u2705 Zustand stores contain ZERO server data (UI state only)\n- \u2705 All domain UIs functional (Player, Visit, RatingSlip)\n- \u2705 Real-time updates <1s latency"
        },
        {
          "line": 827,
          "keyword": "Zustand",
          "directive": "REQUIRED",
          "statement": "- \u2705 Zero Zustand state pollution",
          "context": "- \u2705 React Query managing all remote state\n- \u2705 Real-time updates <1s latency\n- \u2705 Zero Zustand state pollution\n\n### Phase 4 (Week 8 Target)"
        },
        {
          "line": 240,
          "keyword": "staleTime",
          "directive": "NEUTRAL",
          "statement": "- staleTime: 5 * 60 * 1000 (5 minutes)",
          "context": "\nConfiguration:\n- staleTime: 5 * 60 * 1000 (5 minutes)\n- gcTime: 10 * 60 * 1000 (10 minutes)\n- refetchOnWindowFocus: false"
        },
        {
          "line": 213,
          "keyword": "real-time",
          "directive": "NEUTRAL",
          "statement": "> **Hybrid Strategy Applied**: Week 1 HORIZONTAL \u2192 Weeks 2-3 VERTICAL \u2192 Integrated real-time",
          "context": "## Phase 3: UI Layer & State Management (Weeks 3-5)\n\n> **Hybrid Strategy Applied**: Week 1 HORIZONTAL \u2192 Weeks 2-3 VERTICAL \u2192 Integrated real-time\n\n### Critical Blockers Resolved by Phase 2"
        },
        {
          "line": 535,
          "keyword": "real-time",
          "directive": "NEUTRAL",
          "statement": "- Working Player Management UI (search, CRUD, real-time)",
          "context": "\n**Deliverables**:\n- Working Player Management UI (search, CRUD, real-time)\n- Independently testable and deployable feature\n"
        },
        {
          "line": 551,
          "keyword": "real-time",
          "directive": "NEUTRAL",
          "statement": "- Real-time visit updates",
          "context": "- visit-detail.tsx (lifecycle actions)\n- visit-status-badge.tsx (status display)\n- Real-time visit updates\n\n**Estimated Effort**: 2 days"
        },
        {
          "line": 560,
          "keyword": "real-time",
          "directive": "NEUTRAL",
          "statement": "- Real-time rating updates",
          "context": "- rating-detail.tsx (rating details)\n- point-display.tsx (point calculations)\n- Real-time rating updates\n\n**Estimated Effort**: 2 days"
        },
        {
          "line": 570,
          "keyword": "real-time",
          "directive": "NEUTRAL",
          "statement": "- Working Visit Tracking UI (lifecycle, real-time)",
          "context": "\n**Deliverables**:\n- Working Visit Tracking UI (lifecycle, real-time)\n- Working RatingSlip UI (rating, points, real-time)\n"
        },
        {
          "line": 571,
          "keyword": "real-time",
          "directive": "NEUTRAL",
          "statement": "- Working RatingSlip UI (rating, points, real-time)",
          "context": "**Deliverables**:\n- Working Visit Tracking UI (lifecycle, real-time)\n- Working RatingSlip UI (rating, points, real-time)\n\n---"
        },
        {
          "line": 585,
          "keyword": "real-time",
          "directive": "NEUTRAL",
          "statement": "**Real-Time**: Integrated per domain (not separate HORIZONTAL phase)",
          "context": "- RatingSlip feature \u2192 Complete, user-facing\n\n**Real-Time**: Integrated per domain (not separate HORIZONTAL phase)\n\n---"
        },
        {
          "line": 589,
          "keyword": "real-time",
          "directive": "NEUTRAL",
          "statement": "**Week 6: Real-Time Infrastructure** (DEFERRED - integrated in Weeks 4-5)",
          "context": "---\n\n**Week 6: Real-Time Infrastructure** (DEFERRED - integrated in Weeks 4-5)\n\n#### Vertical Slice 11: Real-Time Channel Wrapper"
        },
        {
          "line": 591,
          "keyword": "real-time",
          "directive": "NEUTRAL",
          "statement": "#### Vertical Slice 11: Real-Time Channel Wrapper",
          "context": "**Week 6: Real-Time Infrastructure** (DEFERRED - integrated in Weeks 4-5)\n\n#### Vertical Slice 11: Real-Time Channel Wrapper\n```typescript\n// hooks/shared/use-supabase-channel.ts"
        },
        {
          "line": 655,
          "keyword": "real-time",
          "directive": "NEUTRAL",
          "statement": "#### Vertical Slice 13: Domain Real-Time Hooks (Player Example)",
          "context": "**Pattern**: Batch invalidations to prevent React Query thrashing on rapid updates.\n\n#### Vertical Slice 13: Domain Real-Time Hooks (Player Example)\n```typescript\n// hooks/player/use-player-realtime.ts"
        },
        {
          "line": 684,
          "keyword": "real-time",
          "directive": "NEUTRAL",
          "statement": "#### Vertical Slice 14: Real-Time Testing",
          "context": "**Estimated Effort**: 2 days (foundation + 3 domain hooks)\n\n#### Vertical Slice 14: Real-Time Testing\n- Mock Supabase channels\n- Verify cleanup on unmount"
        },
        {
          "line": 699,
          "keyword": "real-time",
          "directive": "REQUIRED",
          "statement": "- \u2705 Real-time updates <1s latency",
          "context": "- \u2705 Zustand stores contain ZERO server data (UI state only)\n- \u2705 All domain UIs functional (Player, Visit, RatingSlip)\n- \u2705 Real-time updates <1s latency\n- \u2705 Zero memory leaks (cleanup verified)\n- \u2705 Server actions with structured telemetry"
        },
        {
          "line": 809,
          "keyword": "real-time",
          "directive": "REQUIRED",
          "statement": "| Real-time memory leaks | Medium | High | Strict cleanup testing, useEffect dependency audits |",
          "context": "| Search pattern rewrite overruns | Medium | Medium | Time-box PT-1 mining at 4h per module, rewrite if needed |\n| React Query learning curve | Low | Medium | Use proven patterns from documentation, simple wrapper first |\n| Real-time memory leaks | Medium | High | Strict cleanup testing, useEffect dependency audits |\n| Performance budget miss | Low | High | Weekly Lighthouse checks starting Week 4 |\n"
        },
        {
          "line": 826,
          "keyword": "real-time",
          "directive": "REQUIRED",
          "statement": "- \u2705 Real-time updates <1s latency",
          "context": "- \u2705 Player, Visit, RatingSlip UIs complete\n- \u2705 React Query managing all remote state\n- \u2705 Real-time updates <1s latency\n- \u2705 Zero Zustand state pollution\n"
        }
      ],
      "adr/ADR-004-real-time-strategy.md": [
        {
          "line": 10,
          "keyword": "React Query",
          "directive": "PROHIBITED",
          "statement": "PT-2 enters Week 6 with server state, mutations, and invalidation patterns established (ADR-003). Casino operations require timely awareness of table availability, player status, rating slip lifecycle, and compliance signals. Supabase provides Postgres change feeds via Realtime channels. We must standardize how client code consumes those feeds, keeps the React Query cache current, and avoids resource leaks while maintaining predictable developer ergonomics.",
          "context": "## Context\n\nPT-2 enters Week 6 with server state, mutations, and invalidation patterns established (ADR-003). Casino operations require timely awareness of table availability, player status, rating slip lifecycle, and compliance signals. Supabase provides Postgres change feeds via Realtime channels. We must standardize how client code consumes those feeds, keeps the React Query cache current, and avoids resource leaks while maintaining predictable developer ergonomics.\n\nQuestions to resolve:"
        },
        {
          "line": 25,
          "keyword": "React Query",
          "directive": "REQUIRED",
          "statement": "- **Typed Payload Contracts**: Channel factories accept generic payload mappers that enforce typed DTOs before they hit React Query callbacks. This keeps server data contracts consistent with existing service DTOs.",
          "context": "- **Domain-Scoped Channels**: Each bounded context (casino, player, visit, rating-slip, table-context, table, mtl) owns a Supabase channel namespace: `rt.<domain>.<scope>` (e.g. `rt.player.detail`, `rt.table.available`). Channels subscribe to Postgres changes filtered by table, schema, and optionally row-level `ids` using Supabase `postgres_changes` filters.\n- **Channel Registry**: A lightweight registry (`lib/realtime/channel-registry.ts`) memoizes Supabase channels by name and reuse parameters to avoid duplicate sockets. Hooks call `acquireChannel(config)` and receive a ref-counted subscription object; `releaseChannel()` runs during cleanup.\n- **Typed Payload Contracts**: Channel factories accept generic payload mappers that enforce typed DTOs before they hit React Query callbacks. This keeps server data contracts consistent with existing service DTOs.\n\n### 2. Event Processing & Cache Updates"
        },
        {
          "line": 44,
          "keyword": "React Query",
          "directive": "REQUIRED",
          "statement": "- **Domain-Specific by Default**: Each domain exposes its own hook (e.g. `usePlayerRealtime`, `useTableAvailabilityRealtime`) that encapsulates filters, payload transforms, and cache wiring. This keeps concerns isolated and matches React Query\u2019s domain-based query keys.",
          "context": "### 4. Domain-Specific vs Shared Channels\n\n- **Domain-Specific by Default**: Each domain exposes its own hook (e.g. `usePlayerRealtime`, `useTableAvailabilityRealtime`) that encapsulates filters, payload transforms, and cache wiring. This keeps concerns isolated and matches React Query\u2019s domain-based query keys.\n- **Shared Utility Channels**: Cross-domain workflows (e.g. visit ending triggers rating slip invalidation) listen on the originating domain and schedule invalidations for dependents using the scheduler\u2019s `fanOut()` helper. We avoid a global \u201ceverything\u201d channel to reduce payload volume and guard against over-fetching data that components do not need.\n"
        },
        {
          "line": 51,
          "keyword": "React Query",
          "directive": "REQUIRED",
          "statement": "- **Foreground/Background Awareness**: When the document visibility changes to hidden for >2 minutes, we pause scheduler execution (queue persists). On visibility regain we flush the queue then rely on React Query\u2019s `refetchOnReconnect` to catch any missed deltas.",
          "context": "- **Supabase Status Hooks**: The registry listens to Supabase `on('system', 'status')` events. On transitions to `CONNECTED`, it replays pending scheduler tasks and triggers a selective refetch (`queryClient.invalidateQueries` for domains flagged as \u201crequires resync on reconnect\u201d).\n- **Backoff & Limits**: Let Supabase handle connection retries but impose a cap of 5 rapid reconnections before surfacing a toast via Zustand UI store prompting users to refresh. This prevents infinite reconnect loops in degraded networks.\n- **Foreground/Background Awareness**: When the document visibility changes to hidden for >2 minutes, we pause scheduler execution (queue persists). On visibility regain we flush the queue then rely on React Query\u2019s `refetchOnReconnect` to catch any missed deltas.\n- **Auth Refresh Integration**: The Supabase SSR helper already rotates session tokens; the registry exposes `refreshAuth(token)` so that when Next.js refreshes session cookies the channel client updates without tearing down listeners.\n"
        },
        {
          "line": 64,
          "keyword": "React Query",
          "directive": "OPTIONAL",
          "statement": "1. **Predictable Cache Updates**: Scheduler + canonical query keys minimize redundant refetches while keeping React Query aligned with live data.",
          "context": "### Positive\n\n1. **Predictable Cache Updates**: Scheduler + canonical query keys minimize redundant refetches while keeping React Query aligned with live data.\n2. **Leak Prevention**: Ref-counted registry and effect cleanup avoid the \u201ctoo many listeners\u201d warnings witnessed in earlier spikes.\n3. **Domain Isolation**: Teams evolve realtime rules per bounded context without impacting others, reducing regression risk."
        },
        {
          "line": 80,
          "keyword": "React Query",
          "directive": "NEUTRAL",
          "statement": "- **Cons**: Burst events hammer React Query and Supabase with redundant refetches; observed in Table Context prototype. Rejected in favor of scheduler.",
          "context": "\n- **Pros**: Simpler mental model; fewer abstractions.\n- **Cons**: Burst events hammer React Query and Supabase with redundant refetches; observed in Table Context prototype. Rejected in favor of scheduler.\n\n### B. Single Global Channel"
        },
        {
          "line": 102,
          "keyword": "React Query",
          "directive": "NEUTRAL",
          "statement": "- Integrate status listener with React Query `refetchOnReconnect` and UI toast on repeated failures.",
          "context": "   - Implement `useTableAvailabilityRealtime` and `usePlayerStatusRealtime` with unit tests covering mount/unmount, scheduler batching, and cache updates via jest-mock Supabase client.\n4. **Reconnection Handling**\n   - Integrate status listener with React Query `refetchOnReconnect` and UI toast on repeated failures.\n5. **Documentation & Training**\n   - Update relevant domain READMEs with channel naming, overrides, and testing recipes."
        },
        {
          "line": 50,
          "keyword": "Zustand",
          "directive": "REQUIRED",
          "statement": "- **Backoff & Limits**: Let Supabase handle connection retries but impose a cap of 5 rapid reconnections before surfacing a toast via Zustand UI store prompting users to refresh. This prevents infinite reconnect loops in degraded networks.",
          "context": "\n- **Supabase Status Hooks**: The registry listens to Supabase `on('system', 'status')` events. On transitions to `CONNECTED`, it replays pending scheduler tasks and triggers a selective refetch (`queryClient.invalidateQueries` for domains flagged as \u201crequires resync on reconnect\u201d).\n- **Backoff & Limits**: Let Supabase handle connection retries but impose a cap of 5 rapid reconnections before surfacing a toast via Zustand UI store prompting users to refresh. This prevents infinite reconnect loops in degraded networks.\n- **Foreground/Background Awareness**: When the document visibility changes to hidden for >2 minutes, we pause scheduler execution (queue persists). On visibility regain we flush the queue then rely on React Query\u2019s `refetchOnReconnect` to catch any missed deltas.\n- **Auth Refresh Integration**: The Supabase SSR helper already rotates session tokens; the registry exposes `refreshAuth(token)` so that when Next.js refreshes session cookies the channel client updates without tearing down listeners."
        },
        {
          "line": 1,
          "keyword": "real-time",
          "directive": "NEUTRAL",
          "statement": "# ADR-004: Real-Time Strategy",
          "context": "# ADR-004: Real-Time Strategy\n\n**Status**: PROPOSED"
        },
        {
          "line": 29,
          "keyword": "real-time",
          "directive": "NEUTRAL",
          "statement": "- **Scheduler Default**: Real-time hooks enqueue cache work into a micro-batched scheduler (`lib/realtime/invalidation-scheduler.ts`). The scheduler coalesces multiple events within a configurable debounce window (default 50ms) and executes a single invalidation/update batch on the next animation frame.",
          "context": "### 2. Event Processing & Cache Updates\n\n- **Scheduler Default**: Real-time hooks enqueue cache work into a micro-batched scheduler (`lib/realtime/invalidation-scheduler.ts`). The scheduler coalesces multiple events within a configurable debounce window (default 50ms) and executes a single invalidation/update batch on the next animation frame.\n- **Hybrid Cache Strategy**:\n  - For payloads that contain complete entity snapshots, hooks call `queryClient.setQueryData` using the patterns defined in ADR-003 \u00a7Cache Invalidation (Strategy 4). The scheduler exposes helpers for `setDetail` and `mergeList` operations."
        },
        {
          "line": 90,
          "keyword": "real-time",
          "directive": "REQUIRED",
          "statement": "- **Cons**: Requires comprehensive conflict resolution and rollback logic not available in Wave 3. Real-time feeds remain necessary for authoritative state. Rejected.",
          "context": "\n- **Pros**: Minimal server chatter, fastest UI.\n- **Cons**: Requires comprehensive conflict resolution and rollback logic not available in Wave 3. Real-time feeds remain necessary for authoritative state. Rejected.\n\n## Implementation Plan (Week 6)"
        },
        {
          "line": 112,
          "keyword": "real-time",
          "directive": "OPTIONAL",
          "statement": "- Canonical Blueprint MVP PRD (`docs/system-prd/CANONICAL_BLUEPRINT_MVP_PRD.md`) \u2013 \u00a73.6 Real-Time & Invalidations",
          "context": "- Supabase Realtime docs: https://supabase.com/docs/guides/realtime\n- ADR-003: State Management Strategy (`docs/adr/ADR-003-state-management-strategy.md`)\n- Canonical Blueprint MVP PRD (`docs/system-prd/CANONICAL_BLUEPRINT_MVP_PRD.md`) \u2013 \u00a73.6 Real-Time & Invalidations\n- Balanced Architecture Quick Reference (`docs/patterns/BALANCED_ARCHITECTURE_QUICK.md`) \u2013 Real-time deliverables\n"
        },
        {
          "line": 113,
          "keyword": "real-time",
          "directive": "NEUTRAL",
          "statement": "- Balanced Architecture Quick Reference (`docs/patterns/BALANCED_ARCHITECTURE_QUICK.md`) \u2013 Real-time deliverables",
          "context": "- ADR-003: State Management Strategy (`docs/adr/ADR-003-state-management-strategy.md`)\n- Canonical Blueprint MVP PRD (`docs/system-prd/CANONICAL_BLUEPRINT_MVP_PRD.md`) \u2013 \u00a73.6 Real-Time & Invalidations\n- Balanced Architecture Quick Reference (`docs/patterns/BALANCED_ARCHITECTURE_QUICK.md`) \u2013 Real-time deliverables\n\n## Revision History"
        },
        {
          "line": 10,
          "keyword": "cache",
          "directive": "PROHIBITED",
          "statement": "PT-2 enters Week 6 with server state, mutations, and invalidation patterns established (ADR-003). Casino operations require timely awareness of table availability, player status, rating slip lifecycle, and compliance signals. Supabase provides Postgres change feeds via Realtime channels. We must standardize how client code consumes those feeds, keeps the React Query cache current, and avoids resource leaks while maintaining predictable developer ergonomics.",
          "context": "## Context\n\nPT-2 enters Week 6 with server state, mutations, and invalidation patterns established (ADR-003). Casino operations require timely awareness of table availability, player status, rating slip lifecycle, and compliance signals. Supabase provides Postgres change feeds via Realtime channels. We must standardize how client code consumes those feeds, keeps the React Query cache current, and avoids resource leaks while maintaining predictable developer ergonomics.\n\nQuestions to resolve:"
        },
        {
          "line": 27,
          "keyword": "cache",
          "directive": "NEUTRAL",
          "statement": "### 2. Event Processing & Cache Updates",
          "context": "- **Typed Payload Contracts**: Channel factories accept generic payload mappers that enforce typed DTOs before they hit React Query callbacks. This keeps server data contracts consistent with existing service DTOs.\n\n### 2. Event Processing & Cache Updates\n\n- **Scheduler Default**: Real-time hooks enqueue cache work into a micro-batched scheduler (`lib/realtime/invalidation-scheduler.ts`). The scheduler coalesces multiple events within a configurable debounce window (default 50ms) and executes a single invalidation/update batch on the next animation frame."
        },
        {
          "line": 29,
          "keyword": "cache",
          "directive": "NEUTRAL",
          "statement": "- **Scheduler Default**: Real-time hooks enqueue cache work into a micro-batched scheduler (`lib/realtime/invalidation-scheduler.ts`). The scheduler coalesces multiple events within a configurable debounce window (default 50ms) and executes a single invalidation/update batch on the next animation frame.",
          "context": "### 2. Event Processing & Cache Updates\n\n- **Scheduler Default**: Real-time hooks enqueue cache work into a micro-batched scheduler (`lib/realtime/invalidation-scheduler.ts`). The scheduler coalesces multiple events within a configurable debounce window (default 50ms) and executes a single invalidation/update batch on the next animation frame.\n- **Hybrid Cache Strategy**:\n  - For payloads that contain complete entity snapshots, hooks call `queryClient.setQueryData` using the patterns defined in ADR-003 \u00a7Cache Invalidation (Strategy 4). The scheduler exposes helpers for `setDetail` and `mergeList` operations."
        },
        {
          "line": 30,
          "keyword": "cache",
          "directive": "NEUTRAL",
          "statement": "- **Hybrid Cache Strategy**:",
          "context": "\n- **Scheduler Default**: Real-time hooks enqueue cache work into a micro-batched scheduler (`lib/realtime/invalidation-scheduler.ts`). The scheduler coalesces multiple events within a configurable debounce window (default 50ms) and executes a single invalidation/update batch on the next animation frame.\n- **Hybrid Cache Strategy**:\n  - For payloads that contain complete entity snapshots, hooks call `queryClient.setQueryData` using the patterns defined in ADR-003 \u00a7Cache Invalidation (Strategy 4). The scheduler exposes helpers for `setDetail` and `mergeList` operations.\n  - When payloads are partial or the scope is ambiguous, hooks schedule targeted `invalidateQueries` calls (`['player', 'list']`, `['table', 'available', casinoId]` etc.). Domain helpers map Supabase topics to canonical query keys so developers never hard-code strings."
        },
        {
          "line": 31,
          "keyword": "cache",
          "directive": "NEUTRAL",
          "statement": "- For payloads that contain complete entity snapshots, hooks call `queryClient.setQueryData` using the patterns defined in ADR-003 \u00a7Cache Invalidation (Strategy 4). The scheduler exposes helpers for `setDetail` and `mergeList` operations.",
          "context": "- **Scheduler Default**: Real-time hooks enqueue cache work into a micro-batched scheduler (`lib/realtime/invalidation-scheduler.ts`). The scheduler coalesces multiple events within a configurable debounce window (default 50ms) and executes a single invalidation/update batch on the next animation frame.\n- **Hybrid Cache Strategy**:\n  - For payloads that contain complete entity snapshots, hooks call `queryClient.setQueryData` using the patterns defined in ADR-003 \u00a7Cache Invalidation (Strategy 4). The scheduler exposes helpers for `setDetail` and `mergeList` operations.\n  - When payloads are partial or the scope is ambiguous, hooks schedule targeted `invalidateQueries` calls (`['player', 'list']`, `['table', 'available', casinoId]` etc.). Domain helpers map Supabase topics to canonical query keys so developers never hard-code strings.\n- **Direct Invalidations Only When Needed**: Hooks may bypass the scheduler for low-frequency events (\u22641 per second) by setting `mode: 'immediate'`. The default remains batched to prevent thrashing during bursts (e.g. table-seat churn)."
        },
        {
          "line": 44,
          "keyword": "cache",
          "directive": "REQUIRED",
          "statement": "- **Domain-Specific by Default**: Each domain exposes its own hook (e.g. `usePlayerRealtime`, `useTableAvailabilityRealtime`) that encapsulates filters, payload transforms, and cache wiring. This keeps concerns isolated and matches React Query\u2019s domain-based query keys.",
          "context": "### 4. Domain-Specific vs Shared Channels\n\n- **Domain-Specific by Default**: Each domain exposes its own hook (e.g. `usePlayerRealtime`, `useTableAvailabilityRealtime`) that encapsulates filters, payload transforms, and cache wiring. This keeps concerns isolated and matches React Query\u2019s domain-based query keys.\n- **Shared Utility Channels**: Cross-domain workflows (e.g. visit ending triggers rating slip invalidation) listen on the originating domain and schedule invalidations for dependents using the scheduler\u2019s `fanOut()` helper. We avoid a global \u201ceverything\u201d channel to reduce payload volume and guard against over-fetching data that components do not need.\n"
        },
        {
          "line": 57,
          "keyword": "cache",
          "directive": "REQUIRED",
          "statement": "- **Documentation Alignment**: Domain READMEs must list realtime hooks, channel names, and cache impact so other teams understand downstream invalidations. ADR-003 overrides guide when to favor `setQueryData` vs invalidation.",
          "context": "\n- **Hook Template**: `hooks/shared/use-realtime-channel.ts` exports a template consumed by each domain. It accepts `channel`, `eventFilter`, `mapPayload`, and `handleEvent` callbacks. Domain folders document expected query keys and scheduler operations.\n- **Documentation Alignment**: Domain READMEs must list realtime hooks, channel names, and cache impact so other teams understand downstream invalidations. ADR-003 overrides guide when to favor `setQueryData` vs invalidation.\n- **Instrumentation**: Dev builds log channel lifecycle events when `process.env.NEXT_PUBLIC_DEBUG_REALTIME === 'true'`. Production builds default to silent logging with optional metrics emitted via custom events for later observability work.\n"
        },
        {
          "line": 64,
          "keyword": "cache",
          "directive": "OPTIONAL",
          "statement": "1. **Predictable Cache Updates**: Scheduler + canonical query keys minimize redundant refetches while keeping React Query aligned with live data.",
          "context": "### Positive\n\n1. **Predictable Cache Updates**: Scheduler + canonical query keys minimize redundant refetches while keeping React Query aligned with live data.\n2. **Leak Prevention**: Ref-counted registry and effect cleanup avoid the \u201ctoo many listeners\u201d warnings witnessed in earlier spikes.\n3. **Domain Isolation**: Teams evolve realtime rules per bounded context without impacting others, reducing regression risk."
        },
        {
          "line": 100,
          "keyword": "cache",
          "directive": "REQUIRED",
          "statement": "- Implement `useTableAvailabilityRealtime` and `usePlayerStatusRealtime` with unit tests covering mount/unmount, scheduler batching, and cache updates via jest-mock Supabase client.",
          "context": "   - `hooks/shared/use-realtime-channel.ts` encapsulating Supabase subscription lifecycle and scheduler integration.\n3. **Pilot Domains**\n   - Implement `useTableAvailabilityRealtime` and `usePlayerStatusRealtime` with unit tests covering mount/unmount, scheduler batching, and cache updates via jest-mock Supabase client.\n4. **Reconnection Handling**\n   - Integrate status listener with React Query `refetchOnReconnect` and UI toast on repeated failures."
        },
        {
          "line": 106,
          "keyword": "cache",
          "directive": "NEUTRAL",
          "statement": "- Add integration tests (Cypress or Jest) simulating rapid updates and reconnection to confirm cache and UI consistency.",
          "context": "   - Update relevant domain READMEs with channel naming, overrides, and testing recipes.\n6. **Validation**\n   - Add integration tests (Cypress or Jest) simulating rapid updates and reconnection to confirm cache and UI consistency.\n\n## References"
        }
      ],
      "adr/ADR-005-integrity-enforcement.md": [
        {
          "line": 27,
          "keyword": "real-time",
          "directive": "NEUTRAL",
          "statement": "### Layer 1: IDE & Editor (Real-time)",
          "context": "We will implement a **four-layer integrity enforcement framework** with automated guardrails at every stage of the development lifecycle:\n\n### Layer 1: IDE & Editor (Real-time)\n- TypeScript Language Server for immediate type checking\n- ESLint for bounded context rule enforcement"
        }
      ],
      "adr/ADR-003-state-management-strategy.md": [
        {
          "line": 26,
          "keyword": "React Query",
          "directive": "NEUTRAL",
          "statement": "### React Query for Server State",
          "context": "## Decision\n\n### React Query for Server State\n\n**Scope**: ALL data fetched from Supabase database"
        },
        {
          "line": 264,
          "keyword": "React Query",
          "directive": "REQUIRED",
          "statement": "- Server data (players, visits, rating slips) \u2192 Use React Query",
          "context": "\n**Excludes**:\n- Server data (players, visits, rating slips) \u2192 Use React Query\n- Fetched data \u2192 Use React Query\n- Persistent state \u2192 Use database"
        },
        {
          "line": 265,
          "keyword": "React Query",
          "directive": "REQUIRED",
          "statement": "- Fetched data \u2192 Use React Query",
          "context": "**Excludes**:\n- Server data (players, visits, rating slips) \u2192 Use React Query\n- Fetched data \u2192 Use React Query\n- Persistent state \u2192 Use database\n- User session \u2192 Use Next.js auth"
        },
        {
          "line": 271,
          "keyword": "React Query",
          "directive": "REQUIRED",
          "statement": "- Filters that drive React Query queries must surface through selector hooks that derive query keys directly from the Zustand state to prevent divergence. Each consuming component should",
          "context": "\n**Synchronization Guidance**:\n- Filters that drive React Query queries must surface through selector hooks that derive query keys directly from the Zustand state to prevent divergence. Each consuming component should \n  - read filters via `usePlayerFilters()` (or domain equivalent), and\n  - pass those values into the relevant service query hook so cache keys stay aligned."
        },
        {
          "line": 275,
          "keyword": "React Query",
          "directive": "NEUTRAL",
          "statement": "- React Query remains the single source of truth for server data; Zustand holds only the transient filter inputs and view configuration.",
          "context": "  - pass those values into the relevant service query hook so cache keys stay aligned.\n- When filters need to be shareable (deep links, collaborative workflows), promote them to URL params with Next.js router helpers and hydrate the Zustand store from the route in layout loaders. The ADR assumes \u201cUI state only\u201d filters during Wave 3, but teams should graduate filters to URL state whenever cross-session persistence or copy/paste links are required.\n- React Query remains the single source of truth for server data; Zustand holds only the transient filter inputs and view configuration.\n\n**Implemented Stores**:"
        },
        {
          "line": 334,
          "keyword": "React Query",
          "directive": "NEUTRAL",
          "statement": "**Planned Pattern**: Real-time hooks update React Query cache",
          "context": "**Status**: Deferred to feature implementation (Weeks 4-6)\n\n**Planned Pattern**: Real-time hooks update React Query cache\n\n**Proposed Implementation** (aligned with existing architecture standards):"
        },
        {
          "line": 351,
          "keyword": "React Query",
          "directive": "REQUIRED",
          "statement": "3. **Reconnection handling**: Use React Query's automatic refetch on reconnect",
          "context": "1. **setQueryData vs invalidateQueries**: Choose based on event payload completeness\n2. **Selective subscriptions**: Subscribe only to relevant entities per component\n3. **Reconnection handling**: Use React Query's automatic refetch on reconnect\n4. **Performance impact**: Measure and optimize based on actual real-time load\n"
        },
        {
          "line": 355,
          "keyword": "React Query",
          "directive": "NEUTRAL",
          "statement": "- Single source of truth (React Query cache)",
          "context": "\n**Rationale**:\n- Single source of truth (React Query cache)\n- Real-time updates flow through established patterns\n- No separate real-time state management needed"
        },
        {
          "line": 367,
          "keyword": "React Query",
          "directive": "NEUTRAL",
          "statement": "- Server state: React Query (all 6 services tested)",
          "context": "\n1. **Clear Separation of Concerns** \u2705 Validated\n   - Server state: React Query (all 6 services tested)\n   - UI state: Zustand (20 tests passing)\n   - Real-time: Updates React Query cache (pattern documented)"
        },
        {
          "line": 369,
          "keyword": "React Query",
          "directive": "NEUTRAL",
          "statement": "- Real-time: Updates React Query cache (pattern documented)",
          "context": "   - Server state: React Query (all 6 services tested)\n   - UI state: Zustand (20 tests passing)\n   - Real-time: Updates React Query cache (pattern documented)\n   - No overlap or confusion\n"
        },
        {
          "line": 376,
          "keyword": "React Query",
          "directive": "NEUTRAL",
          "statement": "- Request deduplication (React Query default behavior)",
          "context": "   - Stale-while-revalidate pattern (validated in Wave 3)\n   - Memory management (no leaks observed)\n   - Request deduplication (React Query default behavior)\n\n3. **TypeScript Type Safety** \u2705 Validated"
        },
        {
          "line": 399,
          "keyword": "React Query",
          "directive": "REQUIRED",
          "statement": "- Team must learn React Query patterns",
          "context": "\n1. **Learning Curve** \u26a0\ufe0f Mitigated\n   - Team must learn React Query patterns\n   - **Mitigation**: Comprehensive hook templates and documentation provided\n   - Query key strategy requires discipline"
        },
        {
          "line": 413,
          "keyword": "React Query",
          "directive": "NEUTRAL",
          "statement": "- React Query: ~40kb gzipped",
          "context": "\n3. **Additional Dependencies** \u2705 Acceptable\n   - React Query: ~40kb gzipped\n   - Zustand: ~1kb gzipped\n   - Total: ~41kb added to bundle"
        },
        {
          "line": 419,
          "keyword": "React Query",
          "directive": "REQUIRED",
          "statement": "- Must mock React Query in tests",
          "context": "\n4. **Testing Complexity** \u26a0\ufe0f Mitigated\n   - Must mock React Query in tests\n   - **Mitigation**: Wave 3 integration tests demonstrate testing patterns\n   - Integration tests need QueryClient setup"
        },
        {
          "line": 451,
          "keyword": "React Query",
          "directive": "NEUTRAL",
          "statement": "- More boilerplate than React Query",
          "context": "\n**Cons**:\n- More boilerplate than React Query\n- Steeper learning curve\n- Heavier bundle size (~50kb vs 40kb)"
        },
        {
          "line": 466,
          "keyword": "React Query",
          "directive": "NEUTRAL",
          "statement": "- Less TypeScript support than React Query",
          "context": "\n**Cons**:\n- Less TypeScript support than React Query\n- Smaller ecosystem\n- Fewer features (no mutations, devtools limited)"
        },
        {
          "line": 492,
          "keyword": "React Query",
          "directive": "REQUIRED",
          "statement": "- \u2705 React Query configured (`lib/query-client.ts`) - 4 tests passing",
          "context": "\n**Deliverables**:\n- \u2705 React Query configured (`lib/query-client.ts`) - 4 tests passing\n- \u2705 Server action wrapper (`lib/actions/with-server-action-wrapper.ts`) - 13 tests passing\n- \u2705 Zustand stores created (`store/ui-store.ts`, `store/player-store.ts`) - 20 tests passing"
        },
        {
          "line": 545,
          "keyword": "React Query",
          "directive": "REQUIRED",
          "statement": "### 1. React Query Defaults \u2705 RESOLVED",
          "context": "## Resolved Questions\n\n### 1. React Query Defaults \u2705 RESOLVED\n**Question**: What `staleTime` balances freshness vs performance?\n**Answer**: 5 minutes (`1000 * 60 * 5`)"
        },
        {
          "line": 593,
          "keyword": "React Query",
          "directive": "NEUTRAL",
          "statement": "- React Query v5 Docs: https://tanstack.com/query/latest/docs/framework/react/overview",
          "context": "\n### External Documentation\n- React Query v5 Docs: https://tanstack.com/query/latest/docs/framework/react/overview\n- Zustand Docs: https://docs.pmnd.rs/zustand/getting-started/introduction\n"
        },
        {
          "line": 627,
          "keyword": "React Query",
          "directive": "REQUIRED",
          "statement": "\u2705 All React Query defaults finalized with rationale",
          "context": "## Acceptance Criteria Met\n\n\u2705 All React Query defaults finalized with rationale\n\u2705 All 30 query key patterns documented across 7 domains\n\u2705 All 3 cache invalidation strategies validated"
        },
        {
          "line": 251,
          "keyword": "Zustand",
          "directive": "NEUTRAL",
          "statement": "### Zustand for UI State",
          "context": "- Wave 3 integration tests validate all patterns work correctly\n\n### Zustand for UI State\n\n**Scope**: Ephemeral UI state ONLY (validated in Wave 1)"
        },
        {
          "line": 271,
          "keyword": "Zustand",
          "directive": "REQUIRED",
          "statement": "- Filters that drive React Query queries must surface through selector hooks that derive query keys directly from the Zustand state to prevent divergence. Each consuming component should",
          "context": "\n**Synchronization Guidance**:\n- Filters that drive React Query queries must surface through selector hooks that derive query keys directly from the Zustand state to prevent divergence. Each consuming component should \n  - read filters via `usePlayerFilters()` (or domain equivalent), and\n  - pass those values into the relevant service query hook so cache keys stay aligned."
        },
        {
          "line": 274,
          "keyword": "Zustand",
          "directive": "PROHIBITED",
          "statement": "- When filters need to be shareable (deep links, collaborative workflows), promote them to URL params with Next.js router helpers and hydrate the Zustand store from the route in layout loaders. The ADR assumes \u201cUI state only\u201d filters during Wave 3, but teams should graduate filters to URL state whenever cross-session persistence or copy/paste links are required.",
          "context": "  - read filters via `usePlayerFilters()` (or domain equivalent), and\n  - pass those values into the relevant service query hook so cache keys stay aligned.\n- When filters need to be shareable (deep links, collaborative workflows), promote them to URL params with Next.js router helpers and hydrate the Zustand store from the route in layout loaders. The ADR assumes \u201cUI state only\u201d filters during Wave 3, but teams should graduate filters to URL state whenever cross-session persistence or copy/paste links are required.\n- React Query remains the single source of truth for server data; Zustand holds only the transient filter inputs and view configuration.\n"
        },
        {
          "line": 275,
          "keyword": "Zustand",
          "directive": "NEUTRAL",
          "statement": "- React Query remains the single source of truth for server data; Zustand holds only the transient filter inputs and view configuration.",
          "context": "  - pass those values into the relevant service query hook so cache keys stay aligned.\n- When filters need to be shareable (deep links, collaborative workflows), promote them to URL params with Next.js router helpers and hydrate the Zustand store from the route in layout loaders. The ADR assumes \u201cUI state only\u201d filters during Wave 3, but teams should graduate filters to URL state whenever cross-session persistence or copy/paste links are required.\n- React Query remains the single source of truth for server data; Zustand holds only the transient filter inputs and view configuration.\n\n**Implemented Stores**:"
        },
        {
          "line": 368,
          "keyword": "Zustand",
          "directive": "NEUTRAL",
          "statement": "- UI state: Zustand (20 tests passing)",
          "context": "1. **Clear Separation of Concerns** \u2705 Validated\n   - Server state: React Query (all 6 services tested)\n   - UI state: Zustand (20 tests passing)\n   - Real-time: Updates React Query cache (pattern documented)\n   - No overlap or confusion"
        },
        {
          "line": 414,
          "keyword": "Zustand",
          "directive": "NEUTRAL",
          "statement": "- Zustand: ~1kb gzipped",
          "context": "3. **Additional Dependencies** \u2705 Acceptable\n   - React Query: ~40kb gzipped\n   - Zustand: ~1kb gzipped\n   - Total: ~41kb added to bundle\n   - **Justification**: Features provided (caching, refetching, type safety) justify bundle size"
        },
        {
          "line": 472,
          "keyword": "Zustand",
          "directive": "NEUTRAL",
          "statement": "### Alternative 4: Zustand for Everything",
          "context": "**Decision**: Rejected due to inferior TypeScript support\n\n### Alternative 4: Zustand for Everything\n\n**Pros**:"
        },
        {
          "line": 494,
          "keyword": "Zustand",
          "directive": "REQUIRED",
          "statement": "- \u2705 Zustand stores created (`store/ui-store.ts`, `store/player-store.ts`) - 20 tests passing",
          "context": "- \u2705 React Query configured (`lib/query-client.ts`) - 4 tests passing\n- \u2705 Server action wrapper (`lib/actions/with-server-action-wrapper.ts`) - 13 tests passing\n- \u2705 Zustand stores created (`store/ui-store.ts`, `store/player-store.ts`) - 20 tests passing\n- \u2705 ADR-003 draft created\n"
        },
        {
          "line": 594,
          "keyword": "Zustand",
          "directive": "NEUTRAL",
          "statement": "- Zustand Docs: https://docs.pmnd.rs/zustand/getting-started/introduction",
          "context": "### External Documentation\n- React Query v5 Docs: https://tanstack.com/query/latest/docs/framework/react/overview\n- Zustand Docs: https://docs.pmnd.rs/zustand/getting-started/introduction\n\n### Project Architecture"
        },
        {
          "line": 594,
          "keyword": "Zustand",
          "directive": "NEUTRAL",
          "statement": "- Zustand Docs: https://docs.pmnd.rs/zustand/getting-started/introduction",
          "context": "### External Documentation\n- React Query v5 Docs: https://tanstack.com/query/latest/docs/framework/react/overview\n- Zustand Docs: https://docs.pmnd.rs/zustand/getting-started/introduction\n\n### Project Architecture"
        },
        {
          "line": 630,
          "keyword": "Zustand",
          "directive": "REQUIRED",
          "statement": "\u2705 Zustand scope clearly defined and boundaries enforced",
          "context": "\u2705 All 30 query key patterns documented across 7 domains\n\u2705 All 3 cache invalidation strategies validated\n\u2705 Zustand scope clearly defined and boundaries enforced\n\u2705 32 integration tests passing (100% pass rate)\n\u2705 Performance baselines established (<1s single ops, <3s workflows)"
        },
        {
          "line": 35,
          "keyword": "staleTime",
          "directive": "NEUTRAL",
          "statement": "staleTime: 1000 * 60 * 5,    // 5 minutes",
          "context": "  defaultOptions: {\n    queries: {\n      staleTime: 1000 * 60 * 5,    // 5 minutes\n      gcTime: 1000 * 60 * 30,      // Evict unused data after 30 minutes unless overridden\n      refetchOnWindowFocus: false,  // Disabled for casino context"
        },
        {
          "line": 48,
          "keyword": "staleTime",
          "directive": "PROHIBITED",
          "statement": "- **staleTime: 5 minutes**: Balances data freshness with reduced network requests. Casino operations don't require sub-minute updates for most data.",
          "context": "\n**Rationale**:\n- **staleTime: 5 minutes**: Balances data freshness with reduced network requests. Casino operations don't require sub-minute updates for most data.\n- **gcTime: 30 minutes**: Keeps warm caches available for operators who bounce between views while still bounding memory usage. High-churn domains can override to shorter windows alongside domain-specific `staleTime` values when live data requires it (see below).\n- **refetchOnWindowFocus: false**: Prevents unnecessary refetches in a multi-window casino environment where users frequently switch tabs."
        },
        {
          "line": 49,
          "keyword": "staleTime",
          "directive": "REQUIRED",
          "statement": "- **gcTime: 30 minutes**: Keeps warm caches available for operators who bounce between views while still bounding memory usage. High-churn domains can override to shorter windows alongside domain-specific `staleTime` values when live data requires it (see below).",
          "context": "**Rationale**:\n- **staleTime: 5 minutes**: Balances data freshness with reduced network requests. Casino operations don't require sub-minute updates for most data.\n- **gcTime: 30 minutes**: Keeps warm caches available for operators who bounce between views while still bounding memory usage. High-churn domains can override to shorter windows alongside domain-specific `staleTime` values when live data requires it (see below).\n- **refetchOnWindowFocus: false**: Prevents unnecessary refetches in a multi-window casino environment where users frequently switch tabs.\n- **queries.retry: 1**: Single retry handles transient network issues without excessive delay."
        },
        {
          "line": 59,
          "keyword": "staleTime",
          "directive": "REQUIRED",
          "statement": "**Override Guidance**: The 5-minute/30-minute defaults serve as a baseline. Hook authors should explicitly set shorter `staleTime`/`gcTime` values for high-volatility queries such as live table availability or player status dashboards, and extend the window for infrequently accessed reports. Document any override in the corresponding domain README so cross-team consumers know the expected freshness.",
          "context": "- TypeScript-first design\n\n**Override Guidance**: The 5-minute/30-minute defaults serve as a baseline. Hook authors should explicitly set shorter `staleTime`/`gcTime` values for high-volatility queries such as live table availability or player status dashboards, and extend the window for infrequently accessed reports. Document any override in the corresponding domain README so cross-team consumers know the expected freshness.\n\n**Evidence**: `/home/diepulp/projects/pt-2/lib/query-client.ts` - 4 tests passing"
        },
        {
          "line": 373,
          "keyword": "staleTime",
          "directive": "NEUTRAL",
          "statement": "- Background refetching (5-minute staleTime working)",
          "context": "\n2. **Automatic Cache Management** \u2705 Validated\n   - Background refetching (5-minute staleTime working)\n   - Stale-while-revalidate pattern (validated in Wave 3)\n   - Memory management (no leaks observed)"
        },
        {
          "line": 391,
          "keyword": "staleTime",
          "directive": "NEUTRAL",
          "statement": "- Intelligent caching reduces requests (5-minute staleTime)",
          "context": "\n5. **Performance Optimization** \u2705 Validated\n   - Intelligent caching reduces requests (5-minute staleTime)\n   - Single operations: <1s (Wave 3 baseline)\n   - Complex workflows: <3s (Wave 3 baseline)"
        },
        {
          "line": 409,
          "keyword": "staleTime",
          "directive": "REQUIRED",
          "statement": "- Requires tuning of `staleTime` and `refetchInterval`",
          "context": "   - Background refetching may fetch unnecessary data\n   - **Resolution**: `refetchOnWindowFocus: false` prevents unnecessary refetches in casino context\n   - Requires tuning of `staleTime` and `refetchInterval`\n   - **Resolution**: 5-minute staleTime balances freshness with performance\n"
        },
        {
          "line": 410,
          "keyword": "staleTime",
          "directive": "NEUTRAL",
          "statement": "- **Resolution**: 5-minute staleTime balances freshness with performance",
          "context": "   - **Resolution**: `refetchOnWindowFocus: false` prevents unnecessary refetches in casino context\n   - Requires tuning of `staleTime` and `refetchInterval`\n   - **Resolution**: 5-minute staleTime balances freshness with performance\n\n3. **Additional Dependencies** \u2705 Acceptable"
        },
        {
          "line": 546,
          "keyword": "staleTime",
          "directive": "NEUTRAL",
          "statement": "**Question**: What `staleTime` balances freshness vs performance?",
          "context": "\n### 1. React Query Defaults \u2705 RESOLVED\n**Question**: What `staleTime` balances freshness vs performance?\n**Answer**: 5 minutes (`1000 * 60 * 5`)\n**Rationale**: Casino operations don't require sub-minute updates for most data. Balances freshness with reduced network requests."
        },
        {
          "line": 14,
          "keyword": "real-time",
          "directive": "NEUTRAL",
          "statement": "- Real-time updates (player status, table events)",
          "context": "- Server data (players, visits, rating slips, tables, casinos, MTL, loyalty)\n- UI state (modals, navigation, filters, forms)\n- Real-time updates (player status, table events)\n- Cache invalidation and optimistic updates\n- Cross-component data sharing"
        },
        {
          "line": 330,
          "keyword": "real-time",
          "directive": "NEUTRAL",
          "statement": "### Real-Time Updates Integration",
          "context": "- `/home/diepulp/projects/pt-2/store/README.md` - Complete guidelines (7.8KB)\n\n### Real-Time Updates Integration\n\n**Status**: Deferred to feature implementation (Weeks 4-6)"
        },
        {
          "line": 334,
          "keyword": "real-time",
          "directive": "NEUTRAL",
          "statement": "**Planned Pattern**: Real-time hooks update React Query cache",
          "context": "**Status**: Deferred to feature implementation (Weeks 4-6)\n\n**Planned Pattern**: Real-time hooks update React Query cache\n\n**Proposed Implementation** (aligned with existing architecture standards):"
        },
        {
          "line": 352,
          "keyword": "real-time",
          "directive": "NEUTRAL",
          "statement": "4. **Performance impact**: Measure and optimize based on actual real-time load",
          "context": "2. **Selective subscriptions**: Subscribe only to relevant entities per component\n3. **Reconnection handling**: Use React Query's automatic refetch on reconnect\n4. **Performance impact**: Measure and optimize based on actual real-time load\n\n**Rationale**:"
        },
        {
          "line": 356,
          "keyword": "real-time",
          "directive": "NEUTRAL",
          "statement": "- Real-time updates flow through established patterns",
          "context": "**Rationale**:\n- Single source of truth (React Query cache)\n- Real-time updates flow through established patterns\n- No separate real-time state management needed\n- Aligns with existing domain-specific real-time hooks pattern"
        },
        {
          "line": 357,
          "keyword": "real-time",
          "directive": "NEUTRAL",
          "statement": "- No separate real-time state management needed",
          "context": "- Single source of truth (React Query cache)\n- Real-time updates flow through established patterns\n- No separate real-time state management needed\n- Aligns with existing domain-specific real-time hooks pattern\n"
        },
        {
          "line": 358,
          "keyword": "real-time",
          "directive": "NEUTRAL",
          "statement": "- Aligns with existing domain-specific real-time hooks pattern",
          "context": "- Real-time updates flow through established patterns\n- No separate real-time state management needed\n- Aligns with existing domain-specific real-time hooks pattern\n\n**Note**: Real-time patterns will be finalized during feature implementation when actual requirements are known."
        },
        {
          "line": 360,
          "keyword": "real-time",
          "directive": "REQUIRED",
          "statement": "**Note**: Real-time patterns will be finalized during feature implementation when actual requirements are known.",
          "context": "- Aligns with existing domain-specific real-time hooks pattern\n\n**Note**: Real-time patterns will be finalized during feature implementation when actual requirements are known.\n\n## Consequences"
        },
        {
          "line": 369,
          "keyword": "real-time",
          "directive": "NEUTRAL",
          "statement": "- Real-time: Updates React Query cache (pattern documented)",
          "context": "   - Server state: React Query (all 6 services tested)\n   - UI state: Zustand (20 tests passing)\n   - Real-time: Updates React Query cache (pattern documented)\n   - No overlap or confusion\n"
        },
        {
          "line": 585,
          "keyword": "real-time",
          "directive": "NEUTRAL",
          "statement": "### 4. Real-Time Integration \u23f8\ufe0f DEFERRED",
          "context": "**Rationale**: Self-documenting, consistent across domains\n\n### 4. Real-Time Integration \u23f8\ufe0f DEFERRED\n**Status**: Deferred to feature implementation (Weeks 4-6)\n**Reason**: No real-time features implemented yet. Will be resolved during actual implementation."
        },
        {
          "line": 587,
          "keyword": "real-time",
          "directive": "REQUIRED",
          "statement": "**Reason**: No real-time features implemented yet. Will be resolved during actual implementation.",
          "context": "### 4. Real-Time Integration \u23f8\ufe0f DEFERRED\n**Status**: Deferred to feature implementation (Weeks 4-6)\n**Reason**: No real-time features implemented yet. Will be resolved during actual implementation.\n**Pattern**: Documented in \"Real-Time Updates Integration\" section above\n"
        },
        {
          "line": 588,
          "keyword": "real-time",
          "directive": "NEUTRAL",
          "statement": "**Pattern**: Documented in \"Real-Time Updates Integration\" section above",
          "context": "**Status**: Deferred to feature implementation (Weeks 4-6)\n**Reason**: No real-time features implemented yet. Will be resolved during actual implementation.\n**Pattern**: Documented in \"Real-Time Updates Integration\" section above\n\n## References"
        },
        {
          "line": 15,
          "keyword": "cache",
          "directive": "NEUTRAL",
          "statement": "- Cache invalidation and optimistic updates",
          "context": "- UI state (modals, navigation, filters, forms)\n- Real-time updates (player status, table events)\n- Cache invalidation and optimistic updates\n- Cross-component data sharing\n"
        },
        {
          "line": 49,
          "keyword": "cache",
          "directive": "REQUIRED",
          "statement": "- **gcTime: 30 minutes**: Keeps warm caches available for operators who bounce between views while still bounding memory usage. High-churn domains can override to shorter windows alongside domain-specific `staleTime` values when live data requires it (see below).",
          "context": "**Rationale**:\n- **staleTime: 5 minutes**: Balances data freshness with reduced network requests. Casino operations don't require sub-minute updates for most data.\n- **gcTime: 30 minutes**: Keeps warm caches available for operators who bounce between views while still bounding memory usage. High-churn domains can override to shorter windows alongside domain-specific `staleTime` values when live data requires it (see below).\n- **refetchOnWindowFocus: false**: Prevents unnecessary refetches in a multi-window casino environment where users frequently switch tabs.\n- **queries.retry: 1**: Single retry handles transient network issues without excessive delay."
        },
        {
          "line": 132,
          "keyword": "cache",
          "directive": "NEUTRAL",
          "statement": "### Cache Invalidation Strategy",
          "context": "**Evidence**: `/home/diepulp/projects/pt-2/hooks/shared/README.md` - 30 query key patterns documented\n\n### Cache Invalidation Strategy\n\n**Validated Strategies** (from Wave 2 hook templates):"
        },
        {
          "line": 192,
          "keyword": "cache",
          "directive": "NEUTRAL",
          "statement": "// Remove deleted entity's detail query from cache",
          "context": "  {\n    onSuccess: (data, playerId) => {\n      // Remove deleted entity's detail query from cache\n      queryClient.removeQueries({\n        queryKey: ['player', 'detail', playerId]"
        },
        {
          "line": 210,
          "keyword": "cache",
          "directive": "NEUTRAL",
          "statement": "#### 4. Direct Cache Updates with `setQueryData`",
          "context": "- Preventing 404 errors on deleted entities\n\n#### 4. Direct Cache Updates with `setQueryData`\nUse when mutation responses already contain the updated entity or small collections. This keeps lists and detail views in sync without additional network hops.\n"
        },
        {
          "line": 218,
          "keyword": "cache",
          "directive": "NEUTRAL",
          "statement": "// Refresh the detail cache directly from the mutation payload",
          "context": "  {\n    onSuccess: (data) => {\n      // Refresh the detail cache directly from the mutation payload\n      queryClient.setQueryData(['visit', 'detail', data.id], data);\n"
        },
        {
          "line": 221,
          "keyword": "cache",
          "directive": "NEUTRAL",
          "statement": "// Merge the updated record into paginated list caches",
          "context": "      queryClient.setQueryData(['visit', 'detail', data.id], data);\n\n      // Merge the updated record into paginated list caches\n      queryClient.setQueriesData({ queryKey: ['visit', 'list'] }, (current) =>\n        current ? {"
        },
        {
          "line": 239,
          "keyword": "cache",
          "directive": "NEUTRAL",
          "statement": "- Optimistic updates already mutated the cache and you need to reconcile with the server response",
          "context": "- Mutation payloads include the complete entity snapshot required by consuming UIs\n- Lists are small to moderate and merging avoids redundant refetches\n- Optimistic updates already mutated the cache and you need to reconcile with the server response\n- High-frequency mutations where refetching would exceed Supabase rate limits\n"
        },
        {
          "line": 273,
          "keyword": "cache",
          "directive": "NEUTRAL",
          "statement": "- pass those values into the relevant service query hook so cache keys stay aligned.",
          "context": "- Filters that drive React Query queries must surface through selector hooks that derive query keys directly from the Zustand state to prevent divergence. Each consuming component should \n  - read filters via `usePlayerFilters()` (or domain equivalent), and\n  - pass those values into the relevant service query hook so cache keys stay aligned.\n- When filters need to be shareable (deep links, collaborative workflows), promote them to URL params with Next.js router helpers and hydrate the Zustand store from the route in layout loaders. The ADR assumes \u201cUI state only\u201d filters during Wave 3, but teams should graduate filters to URL state whenever cross-session persistence or copy/paste links are required.\n- React Query remains the single source of truth for server data; Zustand holds only the transient filter inputs and view configuration."
        },
        {
          "line": 334,
          "keyword": "cache",
          "directive": "NEUTRAL",
          "statement": "**Planned Pattern**: Real-time hooks update React Query cache",
          "context": "**Status**: Deferred to feature implementation (Weeks 4-6)\n\n**Planned Pattern**: Real-time hooks update React Query cache\n\n**Proposed Implementation** (aligned with existing architecture standards):"
        },
        {
          "line": 340,
          "keyword": "cache",
          "directive": "REQUIRED",
          "statement": "// Option 1: Directly update cache (faster, requires complete data)",
          "context": "// Domain-specific hook handles subscription\nusePlayerRealtime((event) => {\n  // Option 1: Directly update cache (faster, requires complete data)\n  queryClient.setQueryData(['player', 'detail', event.playerId], event.newData);\n"
        },
        {
          "line": 355,
          "keyword": "cache",
          "directive": "NEUTRAL",
          "statement": "- Single source of truth (React Query cache)",
          "context": "\n**Rationale**:\n- Single source of truth (React Query cache)\n- Real-time updates flow through established patterns\n- No separate real-time state management needed"
        },
        {
          "line": 369,
          "keyword": "cache",
          "directive": "NEUTRAL",
          "statement": "- Real-time: Updates React Query cache (pattern documented)",
          "context": "   - Server state: React Query (all 6 services tested)\n   - UI state: Zustand (20 tests passing)\n   - Real-time: Updates React Query cache (pattern documented)\n   - No overlap or confusion\n"
        },
        {
          "line": 372,
          "keyword": "cache",
          "directive": "REQUIRED",
          "statement": "2. **Automatic Cache Management** \u2705 Validated",
          "context": "   - No overlap or confusion\n\n2. **Automatic Cache Management** \u2705 Validated\n   - Background refetching (5-minute staleTime working)\n   - Stale-while-revalidate pattern (validated in Wave 3)"
        },
        {
          "line": 436,
          "keyword": "cache",
          "directive": "NEUTRAL",
          "statement": "- Manual cache management",
          "context": "\n**Cons**:\n- Manual cache management\n- No automatic refetching\n- Performance issues with large state trees"
        },
        {
          "line": 441,
          "keyword": "cache",
          "directive": "NEUTRAL",
          "statement": "**Decision**: Rejected due to missing cache management features",
          "context": "- Requires extensive custom logic\n\n**Decision**: Rejected due to missing cache management features\n\n### Alternative 2: Redux Toolkit + RTK Query"
        },
        {
          "line": 507,
          "keyword": "cache",
          "directive": "REQUIRED",
          "statement": "- \u2705 3 cache invalidation strategies documented",
          "context": "- \u2705 Complete documentation (`hooks/shared/README.md`) - 729 lines\n- \u2705 30 query key patterns documented (all 7 domains)\n- \u2705 3 cache invalidation strategies documented\n- \u2705 36+ mutation examples provided\n"
        },
        {
          "line": 574,
          "keyword": "cache",
          "directive": "REQUIRED",
          "statement": "**Rationale**: Different filter values = different data, should be cached separately",
          "context": "**Question**: Should filters be part of key or options?\n**Answer**: Filters are part of the query key\n**Rationale**: Different filter values = different data, should be cached separately\n**Example**: `['player', 'list', { status: 'active' }]`\n"
        },
        {
          "line": 629,
          "keyword": "cache",
          "directive": "REQUIRED",
          "statement": "\u2705 All 3 cache invalidation strategies validated",
          "context": "\u2705 All React Query defaults finalized with rationale\n\u2705 All 30 query key patterns documented across 7 domains\n\u2705 All 3 cache invalidation strategies validated\n\u2705 Zustand scope clearly defined and boundaries enforced\n\u2705 32 integration tests passing (100% pass rate)"
        }
      ],
      "adr/ADR-001-dual-database-type-strategy.md": [
        {
          "line": 213,
          "keyword": "cache",
          "directive": "NEUTRAL",
          "statement": "supabase migration new add_player_rating_cache",
          "context": "```bash\n# 1. Create migration locally\nsupabase migration new add_player_rating_cache\n\n# 2. Write SQL migration"
        },
        {
          "line": 216,
          "keyword": "cache",
          "directive": "NEUTRAL",
          "statement": "vim supabase/migrations/20251006120000_add_player_rating_cache.sql",
          "context": "\n# 2. Write SQL migration\nvim supabase/migrations/20251006120000_add_player_rating_cache.sql\n\n# 3. Apply locally"
        },
        {
          "line": 225,
          "keyword": "cache",
          "directive": "NEUTRAL",
          "statement": "# services/player/queries.ts now has RatingCache types",
          "context": "\n# 5. Implement service layer using new types\n# services/player/queries.ts now has RatingCache types\n\n# 6. Run tests locally"
        },
        {
          "line": 232,
          "keyword": "cache",
          "directive": "NEUTRAL",
          "statement": "git commit -m \"Add player rating cache table\"",
          "context": "# 7. Commit when green\ngit add supabase/migrations types/database.types.ts\ngit commit -m \"Add player rating cache table\"\n```\n"
        },
        {
          "line": 284,
          "keyword": "cache",
          "directive": "NEUTRAL",
          "statement": "Local DB: Has new migration (player_rating_cache table)",
          "context": "### Scenario 1: Local Ahead of Remote (Development)\n```\nLocal DB: Has new migration (player_rating_cache table)\nRemote DB: Does not have migration yet\nLocal Types: Include player_rating_cache"
        },
        {
          "line": 286,
          "keyword": "cache",
          "directive": "NEUTRAL",
          "statement": "Local Types: Include player_rating_cache",
          "context": "Local DB: Has new migration (player_rating_cache table)\nRemote DB: Does not have migration yet\nLocal Types: Include player_rating_cache\nRemote Types: Missing player_rating_cache\n"
        },
        {
          "line": 287,
          "keyword": "cache",
          "directive": "NEUTRAL",
          "statement": "Remote Types: Missing player_rating_cache",
          "context": "Remote DB: Does not have migration yet\nLocal Types: Include player_rating_cache\nRemote Types: Missing player_rating_cache\n\nStatus: \u2705 Normal during development"
        },
        {
          "line": 371,
          "keyword": "cache",
          "directive": "NEUTRAL",
          "statement": "if git diff --cached --name-only | grep \"supabase/migrations\"; then",
          "context": "\n# Check if migration files changed\nif git diff --cached --name-only | grep \"supabase/migrations\"; then\n  echo \"\ud83d\udd0d Migration detected, regenerating local types...\"\n  npm run db:types"
        }
      ]
    },
    "exports": {
      "system-prd/SERVICE_LAYER_ARCHITECTURE_DIAGRAM.md": [
        {
          "line": 200,
          "keyword": "default export",
          "directive": "NEUTRAL",
          "statement": "// NO: default exports mixed with named exports",
          "context": "// NO: return { ...(service as any).hiddenMethod } - incomplete interfaces\n// NO: @deprecated class wrappers that delegate to functional services\n// NO: default exports mixed with named exports\n```\n"
        },
        {
          "line": 312,
          "keyword": "default export",
          "directive": "REQUIRED",
          "statement": "\u2705 Use named exports exclusively (no default exports)",
          "context": "\u2705 Enable RLS on all tables\n\u2705 Keep factories pure and stateless\n\u2705 Use named exports exclusively (no default exports)\n\n### DON'T (PT-1 Anti-Patterns):"
        },
        {
          "line": 26,
          "keyword": "named export",
          "directive": "NEUTRAL",
          "statement": "- Mixed default and named exports",
          "context": "### Export/Module Anti-Patterns (Eliminated)\n\n- Mixed default and named exports\n- Zero-value wrapper functions\n- Runtime validation in factory functions"
        },
        {
          "line": 200,
          "keyword": "named export",
          "directive": "NEUTRAL",
          "statement": "// NO: default exports mixed with named exports",
          "context": "// NO: return { ...(service as any).hiddenMethod } - incomplete interfaces\n// NO: @deprecated class wrappers that delegate to functional services\n// NO: default exports mixed with named exports\n```\n"
        },
        {
          "line": 312,
          "keyword": "named export",
          "directive": "REQUIRED",
          "statement": "\u2705 Use named exports exclusively (no default exports)",
          "context": "\u2705 Enable RLS on all tables\n\u2705 Keep factories pure and stateless\n\u2705 Use named exports exclusively (no default exports)\n\n### DON'T (PT-1 Anti-Patterns):"
        },
        {
          "line": 324,
          "keyword": "named export",
          "directive": "PROHIBITED",
          "statement": "\u274c Mix default and named exports from service modules",
          "context": "\u274c Create deprecated class wrappers that delegate to functional services\n\u274c Leave methods undeclared in interfaces (must be complete)\n\u274c Mix default and named exports from service modules\n\u274c Add runtime validation in factory functions (use dev-only assertions)\n\u274c Create zero-value wrapper functions that just alias services"
        }
      ],
      "system-prd/CANONICAL_BLUEPRINT_MVP_PRD.md": [
        {
          "line": 181,
          "keyword": "named export",
          "directive": "PROHIBITED",
          "statement": "- Ban mixing default and named exports from service modules; use named exports exclusively for consistency and traceability.",
          "context": "  - Ban duplicate/competing factory patterns (e.g., `createXService` + `createXServices` doing the same thing - violation in `services/compliance/index.ts`).\n  - Prohibit zero-value wrapper functions that merely alias existing service creators without adding functionality.\n  - Ban mixing default and named exports from service modules; use named exports exclusively for consistency and traceability.\n  - Prohibit runtime validation in service factory functions; move validation to development-only assertions or initialization-time checks.\n  - **Forbid `as any` type casting to bypass incomplete interfaces** (violation in `services/visit/index.ts:76`). If a method exists in implementation, it MUST be declared in the interface."
        },
        {
          "line": 181,
          "keyword": "named export",
          "directive": "PROHIBITED",
          "statement": "- Ban mixing default and named exports from service modules; use named exports exclusively for consistency and traceability.",
          "context": "  - Ban duplicate/competing factory patterns (e.g., `createXService` + `createXServices` doing the same thing - violation in `services/compliance/index.ts`).\n  - Prohibit zero-value wrapper functions that merely alias existing service creators without adding functionality.\n  - Ban mixing default and named exports from service modules; use named exports exclusively for consistency and traceability.\n  - Prohibit runtime validation in service factory functions; move validation to development-only assertions or initialization-time checks.\n  - **Forbid `as any` type casting to bypass incomplete interfaces** (violation in `services/visit/index.ts:76`). If a method exists in implementation, it MUST be declared in the interface."
        },
        {
          "line": 86,
          "keyword": "export pattern",
          "directive": "NEUTRAL",
          "statement": "- **Consistent Export Pattern**: Export both the factory function and the service type. Name them consistently: `createXService` \u2192 `XService` interface \u2192 `export type XService`.",
          "context": "  ```\n\n- **Consistent Export Pattern**: Export both the factory function and the service type. Name them consistently: `createXService` \u2192 `XService` interface \u2192 `export type XService`.\n\n#### Service Architecture"
        }
      ]
    }
  }
}
