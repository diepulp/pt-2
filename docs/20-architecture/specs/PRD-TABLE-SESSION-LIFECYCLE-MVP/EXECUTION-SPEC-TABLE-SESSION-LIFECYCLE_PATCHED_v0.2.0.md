---
# EXECUTION-SPEC Frontmatter
# Generated by prd-pipeline skill

prd: PRD-TABLE-SESSION-LIFECYCLE-MVP
prd_title: "Table Session Lifecycle MVP"
service: TableContextService
mvp_phase: 2
bounded_context: TableContextService

# Workstream Definitions
workstreams:
  WS1:
    name: Database Foundation + RLS
    description: Migration with enum, table, constraints, triggers, and RLS policies
    executor: backend-service-builder
    executor_type: skill
    depends_on: []
    outputs:
      - supabase/migrations/20260115023500_table_session_lifecycle.sql
    gate: schema-validation
    estimated_complexity: medium

  WS2:
    name: ADR-024 Compliant RPCs
    description: 4 SECURITY DEFINER RPCs with set_rls_context_from_staff()
    executor: backend-service-builder
    executor_type: skill
    depends_on: [WS1]
    outputs:
      - supabase/migrations/20260115023600_table_session_rpcs.sql
    gate: type-check
    estimated_complexity: medium

  WS3:
    name: Service Layer Extension
    description: Extend TableContextService with session operations
    executor: backend-service-builder
    executor_type: skill
    depends_on: [WS2]
    outputs:
      - services/table-context/table-session.ts
      - services/table-context/dtos.ts (update)
      - services/table-context/schemas.ts (update)
      - services/table-context/keys.ts (update)
      - services/table-context/index.ts (update)
    gate: type-check
    estimated_complexity: medium

  WS4:
    name: Route Handlers
    description: REST endpoints for session state machine operations
    executor: api-builder
    executor_type: skill
    depends_on: [WS3]
    outputs:
      - app/api/v1/table-sessions/route.ts
      - app/api/v1/table-sessions/[id]/rundown/route.ts
      - app/api/v1/table-sessions/[id]/close/route.ts
      - app/api/v1/tables/[tableId]/current-session/route.ts
    gate: lint
    estimated_complexity: medium

  WS5:
    name: UI Components
    description: Session status banner and action buttons for table screen
    executor: frontend-design:frontend-design-pt-2
    executor_type: skill
    depends_on: [WS4]
    outputs:
      - components/table/session-status-banner.tsx
      - components/table/session-action-buttons.tsx
      - components/table/close-session-dialog.tsx
      - hooks/table-context/use-table-session.ts
    gate: type-check
    estimated_complexity: medium

  WS6:
    name: Integration Tests
    description: State machine, constraint, and RLS tests
    executor: qa-specialist
    executor_type: skill
    depends_on: [WS3, WS4]
    outputs:
      - __tests__/services/table-context/table-session.int.test.ts
      - __tests__/services/table-context/table-session-rls.int.test.ts
      - app/api/v1/table-sessions/__tests__/route.test.ts
    gate: test-pass
    estimated_complexity: medium

# Execution Phases (topologically sorted, parallelized where possible)
execution_phases:
  - name: Phase 1 - Foundation
    parallel: [WS1]
    gates: [schema-validation]

  - name: Phase 2 - RPCs
    parallel: [WS2]
    gates: [type-check]

  - name: Phase 3 - Backend
    parallel: [WS3, WS4]
    gates: [type-check, lint]

  - name: Phase 4 - Frontend
    parallel: [WS5]
    gates: [type-check]

  - name: Phase 5 - Validation
    parallel: [WS6]
    gates: [test-pass, build]

# Validation Gates
gates:
  schema-validation:
    command: npm run db:types
    success_criteria: "Exit code 0, no type errors"

  type-check:
    command: npm run type-check
    success_criteria: "Exit code 0"

  lint:
    command: npm run lint -- --max-warnings=0
    success_criteria: "Exit code 0, no errors, no warnings"

  test-pass:
    command: npm test -- __tests__/services/table-context/table-session
    success_criteria: "All tests pass, ≥90% coverage"

  build:
    command: npm run build
    success_criteria: "Exit code 0"

# External Dependencies
external_dependencies:
  - prd: PRD-000
    service: CasinoService
    required_for: "Temporal authority (gaming_day computation via compute_gaming_day)"
  - prd: PRD-007
    service: TableContextService
    required_for: "gaming_table FK, table_inventory_snapshot FK, table_drop_event FK"

# Risks and Mitigations
risks:
  - risk: "Partial unique index complexity with connection pooling"
    mitigation: "Use standard PostgreSQL partial unique index, tested with Supabase pooler"
  - risk: "State machine edge cases (concurrent transitions)"
    mitigation: "Use SELECT ... FOR UPDATE in RPCs to prevent race conditions"
---

# EXECUTION-SPEC: PRD-TABLE-SESSION-LIFECYCLE-MVP - Table Session Lifecycle

## Overview

This EXECUTION-SPEC implements the MVP Table Session Lifecycle for PT-2: a minimal state machine that creates session boundaries for gaming tables. Sessions enable telemetry attribution and shift dashboard rollups.

**Key Deliverable**: Pit boss can open/rundown/close table sessions, with exactly one active session per table enforced at the database level.

## Scope

**In Scope:**
- `table_session` table with state machine (OPEN → ACTIVE → RUNDOWN → CLOSED)
- 4 ADR-024 compliant RPCs for session lifecycle
- Service layer extension to TableContextService
- REST endpoints for session operations
- UI components for session management on table screen
- Integration tests for state transitions and RLS

**Out of Scope:**
- Full rundown accounting (breaks, re-opens, partial drops)
- Soft count integration
- Promotional instrument accounting
- Retroactive backfills

## Architecture Context

**Bounded Context:** TableContextService (SRM v4.0.0)
- Answers: "What is the operational state and chip custody posture of this gaming table?"
- `table_session` fits naturally within this context

**Key ADR References:**
- ADR-024: RLS context self-injection via `set_rls_context_from_staff()`
- ADR-015: Pattern C (Hybrid) RLS with JWT fallback
- ADR-018: SECURITY DEFINER governance

---

## Workstream Details

### WS1: Database Foundation + RLS

**Purpose:** Create `table_session` table with state machine constraints and RLS policies.

**Migration File:** `supabase/migrations/20260115023500_table_session_lifecycle.sql`

**Schema Elements:**

```sql
-- 1. Enum type
CREATE TYPE table_session_status AS ENUM ('OPEN', 'ACTIVE', 'RUNDOWN', 'CLOSED');

-- 2. Table
CREATE TABLE table_session (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  casino_id uuid NOT NULL REFERENCES casino(id),
  gaming_table_id uuid NOT NULL REFERENCES gaming_table(id),
  gaming_day date NOT NULL,
  shift_id uuid NULL,
  status table_session_status NOT NULL DEFAULT 'OPEN',
  opened_at timestamptz NOT NULL DEFAULT now(),
  opened_by_staff_id uuid NOT NULL REFERENCES staff(id),
  rundown_started_at timestamptz NULL,
  rundown_started_by_staff_id uuid NULL REFERENCES staff(id),
  closed_at timestamptz NULL,
  closed_by_staff_id uuid NULL REFERENCES staff(id),
  opening_inventory_snapshot_id uuid NULL, -- TODO(FK): add reference when canonical inventory snapshot table exists
  closing_inventory_snapshot_id uuid NULL, -- TODO(FK): add reference when canonical inventory snapshot table exists
  drop_event_id uuid NULL, -- TODO(FK): add reference when canonical drop event table exists
  notes text NULL,
  metadata jsonb NULL,
  created_at timestamptz NOT NULL DEFAULT now(),
  updated_at timestamptz NOT NULL DEFAULT now()
);

-- 3. Unique active session constraint (partial unique index)
CREATE UNIQUE INDEX unique_active_session_per_table
ON table_session (casino_id, gaming_table_id)
WHERE status IN ('OPEN', 'ACTIVE', 'RUNDOWN');

-- 4. Rollup query index
CREATE INDEX idx_table_session_rollup
ON table_session (casino_id, gaming_day, gaming_table_id, status);

-- 5. Gaming day trigger (follows existing pattern)
CREATE OR REPLACE FUNCTION set_table_session_gaming_day()
RETURNS TRIGGER LANGUAGE plpgsql AS $$
DECLARE
  gstart interval;
BEGIN
  SELECT COALESCE(gaming_day_start_time::interval, interval '06:00:00') INTO gstart
    FROM casino_settings
   WHERE casino_id = NEW.casino_id;

  NEW.gaming_day := compute_gaming_day(COALESCE(NEW.opened_at, now()), gstart);
  RETURN NEW;
END;
$$;

CREATE TRIGGER trg_table_session_gaming_day
  BEFORE INSERT ON table_session
  FOR EACH ROW EXECUTE FUNCTION set_table_session_gaming_day();

-- 6. Updated_at trigger
CREATE TRIGGER trg_table_session_updated_at
  BEFORE UPDATE ON table_session
  FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
```

**RLS Policies (Pattern C Hybrid):**

```sql
-- Enable RLS
ALTER TABLE table_session ENABLE ROW LEVEL SECURITY;

-- SELECT: All authenticated staff can read (casino-scoped)
CREATE POLICY "table_session_select_policy" ON table_session
FOR SELECT TO authenticated
USING (
  auth.uid() IS NOT NULL
  AND casino_id = COALESCE(
    NULLIF(current_setting('app.casino_id', true), '')::uuid,
    (auth.jwt() -> 'app_metadata' ->> 'casino_id')::uuid
  )
);

-- INSERT: Blocked for direct access (RPC-only via SECURITY DEFINER)
CREATE POLICY "table_session_insert_deny" ON table_session
FOR INSERT TO authenticated
WITH CHECK (false);

-- UPDATE: Blocked for direct access (RPC-only via SECURITY DEFINER)
CREATE POLICY "table_session_update_deny" ON table_session
FOR UPDATE TO authenticated
USING (false)
WITH CHECK (false);

-- DELETE: Always denied (immutable after creation)
CREATE POLICY "table_session_delete_deny" ON table_session
FOR DELETE TO authenticated
USING (false);
```

**Acceptance Criteria:**
- [ ] `npm run db:types` succeeds
- [ ] Partial unique index enforces one active session per table
- [ ] RLS policies enforce casino scoping
- [ ] Gaming day computed via trigger

---

### WS2: ADR-024 Compliant RPCs

**Purpose:** Implement 4 SECURITY DEFINER RPCs with authoritative context derivation.

**Migration File:** `supabase/migrations/20260115023600_table_session_rpcs.sql`

**RPC Signatures:**

```sql
-- 1. Open Table Session
CREATE OR REPLACE FUNCTION rpc_open_table_session(p_gaming_table_id uuid)
RETURNS table_session
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_result table_session;
  v_casino_id uuid;
  v_actor_id uuid;
  v_role text;
BEGIN
  -- ADR-024: Derive context from authoritative sources
  PERFORM set_rls_context_from_staff();

  v_casino_id := current_setting('app.casino_id')::uuid;
  v_actor_id := current_setting('app.actor_id')::uuid;

  -- Authorization (MVP): only pit_boss/admin may mutate sessions
  v_role := COALESCE(
    NULLIF(current_setting('app.staff_role', true), ''),
    (auth.jwt() -> 'app_metadata' ->> 'staff_role')::text
  );

  IF v_role NOT IN ('pit_boss','admin') THEN  -- TODO: align literals to canonical staff_role enum values
    RAISE EXCEPTION 'forbidden'
      USING ERRCODE = 'P0001';
  END IF;

  -- Validate no active session exists
  IF EXISTS (
    SELECT 1 FROM table_session
    WHERE gaming_table_id = p_gaming_table_id
    AND casino_id = v_casino_id
    AND status IN ('OPEN', 'ACTIVE', 'RUNDOWN')
    FOR UPDATE
  ) THEN
    RAISE EXCEPTION 'active_session_exists'
      USING HINT = 'Close existing session before opening new one';
  END IF;

  -- Create new session
  INSERT INTO table_session (
    casino_id,
    gaming_table_id,
    status,
    opened_by_staff_id
  ) VALUES (
    v_casino_id,
    p_gaming_table_id,
    'ACTIVE',
    v_actor_id
  )
  RETURNING * INTO v_result;

  RETURN v_result;
EXCEPTION
  WHEN unique_violation THEN
    RAISE EXCEPTION 'active_session_exists'
      USING ERRCODE = '23505';
END;
$$;

-- 2. Start Table Rundown
CREATE OR REPLACE FUNCTION rpc_start_table_rundown(p_table_session_id uuid)
RETURNS table_session
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_result table_session;
  v_casino_id uuid;
  v_actor_id uuid;
  v_role text;
  v_current_status table_session_status;
BEGIN
  PERFORM set_rls_context_from_staff();

  v_casino_id := current_setting('app.casino_id')::uuid;
  v_actor_id := current_setting('app.actor_id')::uuid;

  -- Authorization (MVP): only pit_boss/admin may mutate sessions
  v_role := COALESCE(
    NULLIF(current_setting('app.staff_role', true), ''),
    (auth.jwt() -> 'app_metadata' ->> 'staff_role')::text
  );

  IF v_role NOT IN ('pit_boss','admin') THEN  -- TODO: align literals to canonical staff_role enum values
    RAISE EXCEPTION 'forbidden'
      USING ERRCODE = 'P0001';
  END IF;

  -- Get current status with lock
  SELECT status INTO v_current_status
  FROM table_session
  WHERE id = p_table_session_id
  AND casino_id = v_casino_id
  FOR UPDATE;

  IF NOT FOUND THEN
    RAISE EXCEPTION 'session_not_found';
  END IF;

  IF v_current_status NOT IN ('OPEN', 'ACTIVE') THEN
    RAISE EXCEPTION 'invalid_state_transition'
      USING HINT = format('Cannot start rundown from %s state', v_current_status);
  END IF;

  UPDATE table_session SET
    status = 'RUNDOWN',
    rundown_started_at = now(),
    rundown_started_by_staff_id = v_actor_id
  WHERE id = p_table_session_id
  RETURNING * INTO v_result;

  RETURN v_result;
END;
$$;

-- 3. Close Table Session
CREATE OR REPLACE FUNCTION rpc_close_table_session(
  p_table_session_id uuid,
  p_drop_event_id uuid DEFAULT NULL,
  p_closing_inventory_snapshot_id uuid DEFAULT NULL,
  p_notes text DEFAULT NULL
)
RETURNS table_session
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_result table_session;
  v_casino_id uuid;
  v_actor_id uuid;
  v_role text;
  v_current_status table_session_status;
BEGIN
  PERFORM set_rls_context_from_staff();

  v_casino_id := current_setting('app.casino_id')::uuid;
  v_actor_id := current_setting('app.actor_id')::uuid;

  -- Authorization (MVP): only pit_boss/admin may mutate sessions
  v_role := COALESCE(
    NULLIF(current_setting('app.staff_role', true), ''),
    (auth.jwt() -> 'app_metadata' ->> 'staff_role')::text
  );

  IF v_role NOT IN ('pit_boss','admin') THEN  -- TODO: align literals to canonical staff_role enum values
    RAISE EXCEPTION 'forbidden'
      USING ERRCODE = 'P0001';
  END IF;

  -- Get current status with lock
  SELECT status INTO v_current_status
  FROM table_session
  WHERE id = p_table_session_id
  AND casino_id = v_casino_id
  FOR UPDATE;

  IF NOT FOUND THEN
    RAISE EXCEPTION 'session_not_found';
  END IF;

  -- Require RUNDOWN state (or ACTIVE if shortcut allowed)
  IF v_current_status NOT IN ('RUNDOWN', 'ACTIVE') THEN
    RAISE EXCEPTION 'invalid_state_transition'
      USING HINT = format('Cannot close from %s state', v_current_status);
  END IF;

  -- Require at least one closing artifact
  IF p_drop_event_id IS NULL AND p_closing_inventory_snapshot_id IS NULL THEN
    RAISE EXCEPTION 'missing_closing_artifact'
      USING HINT = 'Provide drop_event_id or closing_inventory_snapshot_id';
  END IF;

  UPDATE table_session SET
    status = 'CLOSED',
    closed_at = now(),
    closed_by_staff_id = v_actor_id,
    drop_event_id = COALESCE(p_drop_event_id, drop_event_id),
    closing_inventory_snapshot_id = COALESCE(p_closing_inventory_snapshot_id, closing_inventory_snapshot_id),
    notes = COALESCE(p_notes, notes)
  WHERE id = p_table_session_id
  RETURNING * INTO v_result;

  RETURN v_result;
END;
$$;

-- 4. Get Current Table Session
CREATE OR REPLACE FUNCTION rpc_get_current_table_session(p_gaming_table_id uuid)
RETURNS table_session
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_result table_session;
  v_casino_id uuid;
BEGIN
  PERFORM set_rls_context_from_staff();

  v_casino_id := current_setting('app.casino_id')::uuid;

  SELECT * INTO v_result
  FROM table_session
  WHERE gaming_table_id = p_gaming_table_id
  AND casino_id = v_casino_id
  AND status IN ('OPEN', 'ACTIVE', 'RUNDOWN')
  ORDER BY opened_at DESC
  LIMIT 1;

  RETURN v_result; -- Returns NULL if not found
END;
$$;

-- Grant execute to authenticated role
GRANT EXECUTE ON FUNCTION rpc_open_table_session(uuid) TO authenticated;
GRANT EXECUTE ON FUNCTION rpc_start_table_rundown(uuid) TO authenticated;
GRANT EXECUTE ON FUNCTION rpc_close_table_session(uuid, uuid, uuid, text) TO authenticated;
GRANT EXECUTE ON FUNCTION rpc_get_current_table_session(uuid) TO authenticated;
```

**Error Conditions:**
| Error | HTTP | When |
|-------|------|------|
| `active_session_exists` | 409 | Opening session when one already active |
| `session_not_found` | 404 | Session ID not found or wrong casino |
| `invalid_state_transition` | 422 | Invalid status transition |
| `missing_closing_artifact` | 400 | Close without drop or inventory
| `forbidden` | 403 | Caller role is not authorized to mutate sessions snapshot |

**Acceptance Criteria:**
- [ ] All RPCs use `set_rls_context_from_staff()` as first statement
- [ ] No spoofable casino_id/actor_id parameters
- [ ] State transitions enforced with SELECT FOR UPDATE
- [ ] Meaningful error messages with hints

---

### WS3: Service Layer Extension

**Purpose:** Extend TableContextService with session operations.

**Files:**

1. **`services/table-context/table-session.ts`** (NEW)
```typescript
// Session CRUD operations via RPCs
export async function openTableSession(supabase, tableId: string): Promise<TableSessionDTO>
export async function startRundown(supabase, sessionId: string): Promise<TableSessionDTO>
export async function closeSession(supabase, sessionId: string, input: CloseSessionInput): Promise<TableSessionDTO>
export async function getCurrentSession(supabase, tableId: string): Promise<TableSessionDTO | null>
```

2. **`services/table-context/dtos.ts`** (UPDATE)
```typescript
// Add session DTOs
export type TableSessionStatus = Database['public']['Enums']['table_session_status'];

// eslint-disable-next-line custom-rules/no-manual-dto-interfaces -- Pattern A: RPC return type
export interface TableSessionDTO {
  id: string;
  casino_id: string;
  gaming_table_id: string;
  gaming_day: string;
  shift_id: string | null;
  status: TableSessionStatus;
  opened_at: string;
  opened_by_staff_id: string;
  rundown_started_at: string | null;
  rundown_started_by_staff_id: string | null;
  closed_at: string | null;
  closed_by_staff_id: string | null;
  opening_inventory_snapshot_id: string | null;
  closing_inventory_snapshot_id: string | null;
  drop_event_id: string | null;
  notes: string | null;
}

export interface CloseSessionInput {
  dropEventId?: string;
  closingInventorySnapshotId?: string;
  notes?: string;
}
```

3. **`services/table-context/schemas.ts`** (UPDATE)
```typescript
// Add Zod schemas
export const openSessionSchema = z.object({
  tableId: z.string().uuid(),
});

export const closeSessionSchema = z.object({
  dropEventId: z.string().uuid().optional(),
  closingInventorySnapshotId: z.string().uuid().optional(),
  notes: z.string().max(1000).optional(),
}).refine(
  data => data.dropEventId || data.closingInventorySnapshotId,
  { message: 'Either dropEventId or closingInventorySnapshotId is required' }
);
```

4. **`services/table-context/keys.ts`** (UPDATE)
```typescript
// Add session query keys
export const tableSessionKeys = {
  all: ['table-sessions'] as const,
  current: (tableId: string) => [...tableSessionKeys.all, 'current', tableId] as const,
  byId: (sessionId: string) => [...tableSessionKeys.all, sessionId] as const,
};
```

5. **`services/table-context/index.ts`** (UPDATE)
```typescript
// Add to TableContextServiceInterface
openSession(tableId: string): Promise<TableSessionDTO>;
startRundown(sessionId: string): Promise<TableSessionDTO>;
closeSession(sessionId: string, input: CloseSessionInput): Promise<TableSessionDTO>;
getCurrentSession(tableId: string): Promise<TableSessionDTO | null>;
```

**Acceptance Criteria:**
- [ ] Follows Pattern A (Contract-First with manual DTOs)
- [ ] Service factory pattern extended
- [ ] Zod validation with artifact requirement
- [ ] Query keys follow existing pattern

---

### WS4: Route Handlers

**Purpose:** REST endpoints for session state machine operations.

**Files:**

1. **`app/api/v1/table-sessions/route.ts`**
   - POST: Open new session
   - Request: `{ tableId: string }`
   - Response: `ServiceHttpResult<TableSessionDTO>`

2. **`app/api/v1/table-sessions/[id]/rundown/route.ts`**
   - POST: Start rundown
   - Request: (empty body)
   - Response: `ServiceHttpResult<TableSessionDTO>`

3. **`app/api/v1/table-sessions/[id]/close/route.ts`**
   - POST: Close session
   - Request: `{ dropEventId?, closingInventorySnapshotId?, notes? }`
   - Response: `ServiceHttpResult<TableSessionDTO>`

4. **`app/api/v1/tables/[tableId]/current-session/route.ts`**
   - GET: Get current active session
   - Response: `ServiceHttpResult<TableSessionDTO | null>`

**HTTP Method/Status Mapping:**
| Endpoint | Method | Success | Errors |
|----------|--------|---------|--------|
| `/table-sessions` | POST | 201 | 409 (active exists) |
| `/table-sessions/[id]/rundown` | POST | 200 | 404, 422 |
| `/table-sessions/[id]/close` | POST | 200 | 400, 404, 422 |
| `/tables/[tableId]/current-session` | GET | 200 | - |

**Acceptance Criteria:**
- [ ] All mutations require `Idempotency-Key` header
- [ ] `withServerAction` middleware wraps all handlers
- [ ] Error codes map to appropriate HTTP status
- [ ] Response uses `ServiceHttpResult<T>` envelope

---

### WS5: UI Components

**Purpose:** Session management UI for table screen.

**Files:**

1. **`components/table/session-status-banner.tsx`**
   - Shows current session state with visual indicator
   - Props: `{ session: TableSessionDTO | null }`
   - Displays: status, opened_at, opened_by name

2. **`components/table/session-action-buttons.tsx`**
   - Contextual buttons based on session state
   - Props: `{ session: TableSessionDTO | null, tableId: string }`
   - Buttons: Open (no session), Rundown (OPEN/ACTIVE), Close (RUNDOWN)

3. **`components/table/close-session-dialog.tsx`**
   - Modal for close workflow with artifact selection
   - Props: `{ sessionId: string, isOpen: boolean, onClose: () => void }`
   - Requires: dropdown for drop_event or inventory_snapshot

4. **`hooks/table-context/use-table-session.ts`**
   - React Query hooks for session operations
   - `useCurrentSession(tableId)` - query
   - `useOpenSession()` - mutation
   - `useStartRundown()` - mutation
   - `useCloseSession()` - mutation

**State Management:**
- React Query for server state (session data)
- Local state for dialog open/close
- `useTransition` for mutation pending states

**Acceptance Criteria:**
- [ ] Buttons disabled based on session state
- [ ] Close dialog validates artifact selection
- [ ] Mutations use `useTransition` for pending states
- [ ] Query invalidation on successful mutations

---

### WS6: Integration Tests

**Purpose:** Validate state machine, constraints, and RLS policies.

**Files:**

1. **`__tests__/services/table-context/table-session.int.test.ts`**
   - State transition tests
   - Constraint enforcement tests

2. **`__tests__/services/table-context/table-session-rls.int.test.ts`**
   - RLS policy tests
   - Role-based access tests

3. **`app/api/v1/table-sessions/__tests__/route.test.ts`**
   - Route handler HTTP contract tests

**Test Cases (mapped to PRD §17 Acceptance Scenarios):**

| Scenario | Test | File |
|----------|------|------|
| Happy path | `should complete full lifecycle: OPEN → RUNDOWN → CLOSED` | table-session.int.test.ts |
| Double-open prevention | `should reject second session for same table` | table-session.int.test.ts |
| Close without artifact | `should reject close without drop or inventory snapshot` | table-session.int.test.ts |
| RLS enforcement | `should deny session operations for dealer role` | table-session-rls.int.test.ts |
| Cross-casino isolation | `should not access other casino sessions` | table-session-rls.int.test.ts |

**Mocking Strategy:**
- Real Supabase for integration tests (not mocks)
- Test fixtures create isolated casino/table/staff per test
- Cleanup in afterEach to prevent test pollution

**Acceptance Criteria:**
- [ ] ≥90% coverage for table-session.ts
- [ ] All 4 acceptance scenarios covered
- [ ] Tests run against real database
- [ ] No flaky tests

---

## Definition of Done

### Database (DoD-A)
- [ ] `table_session` table exists with all columns
- [ ] Partial unique index enforces one active session per table
- [ ] RLS policies enforce casino scoping
- [ ] `npm run db:types` succeeds

### RPCs (DoD-B)
- [ ] 4 RPCs implemented with ADR-024 compliance
- [ ] All use `set_rls_context_from_staff()`
- [ ] State transition validation with meaningful errors
- [ ] Fail-closed on missing context

### UI (DoD-C)
- [ ] Pit boss can open session from table screen
- [ ] Pit boss can start rundown
- [ ] Pit boss can close session with artifact selection
- [ ] UI prevents illegal state transitions

### Integration (DoD-D)
- [ ] Telemetry attribution via time-window join works
- [ ] Shift dashboards can compute per-session totals

### Tests (DoD-E)
- [ ] State transition tests pass
- [ ] Constraint enforcement tests pass
- [ ] RLS policy tests pass
- [ ] ≥90% coverage achieved
