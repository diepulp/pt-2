---
# EXECUTION-SPEC Frontmatter
# Generated by prd-pipeline skill via lead-architect scaffolding

prd: ADR-026
prd_title: "Gaming-Day-Scoped Visits"
service: VisitService
mvp_phase: 2  # Session Context phase

# Workstream Definitions
workstreams:
  WS1:
    name: Database Schema
    description: Add gaming_day column to visit table with trigger and constraints
    executor: backend-service-builder
    executor_type: skill
    depends_on: []
    outputs:
      - supabase/migrations/YYYYMMDDHHMMSS_adr026_gaming_day_scoped_visits.sql
      - types/database.types.ts (regenerated)
    gate: schema-validation
    estimated_complexity: medium

  WS2:
    name: SECURITY DEFINER RPC
    description: Implement rpc_start_or_resume_visit with gaming day boundary handling
    executor: rls-expert
    executor_type: skill
    depends_on: [WS1]
    outputs:
      - supabase/migrations/YYYYMMDDHHMMSS_adr026_rpc_start_or_resume_visit.sql
    gate: schema-validation
    estimated_complexity: high

  WS3:
    name: BFF RPC Fix
    description: Update rpc_get_rating_slip_modal_data to filter financials by gaming_day
    executor: backend-service-builder
    executor_type: skill
    depends_on: [WS1]
    outputs:
      - supabase/migrations/YYYYMMDDHHMMSS_adr026_bff_gaming_day_filter.sql
    gate: schema-validation
    estimated_complexity: low

  WS4:
    name: Service Layer Update
    description: Update VisitService.startVisit to call new RPC, update DTOs
    executor: backend-service-builder
    executor_type: skill
    depends_on: [WS2]
    outputs:
      - services/visit/crud.ts
      - services/visit/dtos.ts
      - services/visit/index.ts
    gate: type-check
    estimated_complexity: medium

  WS5:
    name: UI Integration
    description: Add resuming session notification and gaming day display
    executor: frontend-design:frontend-design-pt-2
    executor_type: skill
    depends_on: [WS4]
    outputs:
      - components/modals/rating-slip/rating-slip-modal.tsx
    gate: type-check
    estimated_complexity: low

  WS6:
    name: Integration Tests
    description: Test gaming day boundary scenarios and financial filtering
    executor: backend-service-builder
    executor_type: skill
    depends_on: [WS2, WS3, WS4]
    outputs:
      - services/visit/__tests__/gaming-day-boundary.int.test.ts
    gate: test-pass
    estimated_complexity: medium

  WS7:
    name: Quality Validation
    description: Final build and E2E validation
    executor: qa-specialist
    executor_type: skill
    depends_on: [WS5, WS6]
    outputs: []
    gate: build
    estimated_complexity: low

# Execution Phases (topologically sorted, parallelized where possible)
execution_phases:
  - name: Phase 1 - Foundation
    parallel: [WS1]
    gates: [schema-validation]

  - name: Phase 2 - RPCs
    parallel: [WS2, WS3]
    gates: [schema-validation]

  - name: Phase 3 - Service Layer
    parallel: [WS4]
    gates: [type-check]

  - name: Phase 4 - UI
    parallel: [WS5]
    gates: [type-check]

  - name: Phase 5 - Validation
    parallel: [WS6, WS7]
    gates: [test-pass, build]

# Validation Gates
gates:
  schema-validation:
    command: npm run db:types
    success_criteria: "Exit code 0, no type errors"

  type-check:
    command: npm run type-check
    success_criteria: "Exit code 0"

  test-pass:
    command: npm test services/visit/__tests__/gaming-day-boundary.int.test.ts
    success_criteria: "All tests pass"

  build:
    command: npm run build
    success_criteria: "Exit code 0"

# Dependencies on other PRDs/Services
external_dependencies:
  - prd: PRD-000
    service: CasinoService
    required_for: "compute_gaming_day(casino_id, timestamp) RPC for temporal authority"

  - prd: PRD-018
    service: RatingSlipModalService
    required_for: "BFF RPC to update for gaming_day filtering"

# Risks and Mitigations
risks:
  - risk: "Schema migration backfill may be slow on large datasets"
    mitigation: "Run against local DB first, validate with db:reset. Backfill uses UPDATE with IS DISTINCT FROM for efficiency."

  - risk: "Race conditions in concurrent visit starts"
    mitigation: "Unique partial index uq_visit_player_gaming_day_active provides database-level safety. RPC uses INSERT with ON unique_violation SELECT."

  - risk: "Cross-midnight sessions may exhibit unexpected behavior"
    mitigation: "Auto-close stale visits on first action after cutoff. Link via visit_group_id for continuity."

---

# EXECUTION-SPEC: ADR-026 - Gaming-Day-Scoped Visits

## Overview

This ADR implements gaming-day-scoped visits to fix a compliance issue where the rating slip modal displays "Total Cash In" that includes amounts from prior gaming days. The fix ensures visits are bounded to a single gaming day, with automatic rollover handling when sessions cross the gaming day cutoff.

**Problem Statement**: When a player returns after the gaming day cutoff, `startVisit()` returns an existing active visit from the previous gaming day. Financial totals aggregated by `visit_id` then show multi-day amounts as "today's" total, creating compliance risk for CTR/MTL thresholds.

**Solution**: Add `gaming_day` column to `visit` table with unique constraint ensuring one active visit per player per casino per gaming day. New RPC `rpc_start_or_resume_visit` handles automatic stale visit closure and gaming day boundary enforcement.

## Scope

### In Scope
- Add `visit.gaming_day` column with auto-compute trigger
- Unique partial index for one active visit per gaming day
- `rpc_start_or_resume_visit` SECURITY DEFINER RPC with stale visit handling
- Update BFF RPC financial aggregation to filter by gaming_day
- Update `VisitService.startVisit()` to call new RPC
- UI notification for resumed sessions

### Out of Scope
- Scheduled cleanup job (post-MVP - marked as optional in ADR)
- `rating_slip_group_id` linking across gaming days (deferred question in ADR)
- Lifetime totals display alongside today totals (deferred question in ADR)

## Architecture Context

**SRM Ownership**: VisitService owns `visit` table (SRM v4.8.0)

**Related ADRs**:
- ADR-015: RLS Connection Pooling Strategy (Pattern C Hybrid)
- ADR-018: SECURITY DEFINER Governance (Template 5)
- ADR-024: Authoritative Context Injection (set_rls_context_from_staff)

**Existing Patterns**:
- `player_financial_transaction.gaming_day` - computed via trigger using `compute_gaming_day(casino_id, timestamp)`
- `table_session.gaming_day` - same pattern

## Workstream Details

### WS1: Database Schema

**Purpose**: Add `gaming_day` column to `visit` table with trigger, constraints, and indexes.

**Deliverables**:
1. Migration file: `YYYYMMDDHHMMSS_adr026_gaming_day_scoped_visits.sql`
2. Column: `visit.gaming_day date` (nullable for backfill, then NOT NULL)
3. Trigger: `set_visit_gaming_day()` using `compute_gaming_day(casino_id, started_at)`
4. Backfill: Update existing visits with computed gaming_day
5. Constraint: `ALTER TABLE visit ALTER COLUMN gaming_day SET NOT NULL`
6. Unique index: `uq_visit_player_gaming_day_active ON visit (casino_id, player_id, gaming_day) WHERE ended_at IS NULL AND player_id IS NOT NULL`
7. Performance index: `ix_visit_casino_gaming_day ON visit (casino_id, gaming_day)`

**SQL Sketch**:
```sql
-- 1. Add column (nullable for backfill)
ALTER TABLE visit ADD COLUMN gaming_day date;

-- 2. Create trigger
CREATE OR REPLACE FUNCTION set_visit_gaming_day()
RETURNS trigger LANGUAGE plpgsql AS $$
BEGIN
  NEW.gaming_day := compute_gaming_day(NEW.casino_id, COALESCE(NEW.started_at, now()));
  RETURN NEW;
END;
$$;

CREATE TRIGGER trg_visit_gaming_day
  BEFORE INSERT OR UPDATE OF started_at ON visit
  FOR EACH ROW EXECUTE FUNCTION set_visit_gaming_day();

-- 3. Backfill existing rows
UPDATE visit SET gaming_day = compute_gaming_day(casino_id, started_at);

-- 4. Set NOT NULL
ALTER TABLE visit ALTER COLUMN gaming_day SET NOT NULL;

-- 5. Unique partial index (one active visit per gaming day)
CREATE UNIQUE INDEX uq_visit_player_gaming_day_active
  ON visit (casino_id, player_id, gaming_day)
  WHERE ended_at IS NULL AND player_id IS NOT NULL;

-- 6. Performance index
CREATE INDEX ix_visit_casino_gaming_day
  ON visit (casino_id, gaming_day);
```

**Acceptance Criteria**:
- [ ] `npm run db:types` succeeds
- [ ] `visit.gaming_day` column exists with NOT NULL constraint
- [ ] Trigger correctly computes gaming_day using canonical timezone-aware RPC
- [ ] Unique index prevents duplicate active visits per gaming day

---

### WS2: SECURITY DEFINER RPC

**Purpose**: Implement `rpc_start_or_resume_visit` following ADR-018 governance and ADR-024 context injection.

**Deliverables**:
1. Migration file: `YYYYMMDDHHMMSS_adr026_rpc_start_or_resume_visit.sql`
2. RPC: `rpc_start_or_resume_visit(p_player_id uuid)` - SECURITY DEFINER

**RPC Contract**:
- **Input**: `p_player_id uuid` (only client-provided parameter)
- **Derivations** (server-side):
  - `v_casino_id := current_setting('app.casino_id')::uuid`
  - `v_actor_id := current_setting('app.actor_id')::uuid`
  - `v_gaming_day := compute_gaming_day(v_casino_id, now())`
- **Returns**: `TABLE(visit visit, is_new boolean, resumed boolean, gaming_day date)`

**Behavior**:
1. Call `set_rls_context_from_staff()` at start
2. If active visit exists for `(casino_id, player_id, gaming_day)` → return it (resumed=true)
3. Else:
   - Close stale active visits from prior gaming days
   - Close any active/paused rating slips on those stale visits
   - Create new visit with inherited `visit_group_id`
   - Return it (is_new=true)
4. Handle race conditions via INSERT + unique_violation exception → SELECT
5. Write audit_log entry for rollover

**Security Invariants**:
- [ ] SECURITY DEFINER with `SET search_path TO 'public'`
- [ ] Calls `set_rls_context_from_staff()` at start
- [ ] Derives casino_id from context, not parameters
- [ ] Uses `current_setting('app.*', true)` pattern

---

### WS3: BFF RPC Fix

**Purpose**: Update `rpc_get_rating_slip_modal_data` to filter financial aggregation by gaming_day.

**Deliverables**:
1. Migration file: `YYYYMMDDHHMMSS_adr026_bff_gaming_day_filter.sql`

**Changes to `rpc_get_rating_slip_modal_data`**:

**Current (problematic)**:
```sql
WHERE pft.visit_id = v_slip.visit_id
  AND pft.casino_id = p_casino_id;
```

**Fixed (gaming-day-scoped)**:
```sql
-- Get gaming_day from visit
SELECT gaming_day INTO v_visit_gaming_day FROM visit WHERE id = v_slip.visit_id;

-- Filter financial by gaming_day
WHERE pft.visit_id = v_slip.visit_id
  AND pft.gaming_day = v_visit_gaming_day
  AND pft.casino_id = p_casino_id;
```

**Additional change**: Include `gaming_day` in the BFF response for UI display.

**Acceptance Criteria**:
- [ ] Financial totals only include current gaming day transactions
- [ ] Response includes `gamingDay` field in slip object
- [ ] Existing E2E tests pass

---

### WS4: Service Layer Update

**Purpose**: Update `VisitService.startVisit()` to call `rpc_start_or_resume_visit` and update DTOs.

**Deliverables**:
1. Update `services/visit/crud.ts` - Replace `startVisit` implementation
2. Update `services/visit/dtos.ts` - Extend `StartVisitResultDTO`
3. Update `services/visit/index.ts` - Update interface

**DTO Changes**:
```typescript
// services/visit/dtos.ts
export interface StartVisitResultDTO {
  visit: VisitDTO;
  isNew: boolean;
  resumed: boolean;  // NEW: true if resuming same-day visit
  gamingDay: string; // NEW: ISO date string (YYYY-MM-DD)
}
```

**Service Implementation**:
```typescript
export async function startVisit(
  supabase: SupabaseClient<Database>,
  playerId: string,
  casinoId: string,
): Promise<StartVisitResultDTO> {
  const { data, error } = await supabase.rpc('rpc_start_or_resume_visit', {
    p_player_id: playerId,
  });

  if (error) throw mapDatabaseError(error);

  const row = Array.isArray(data) ? data[0] : data;
  return {
    visit: toVisitDTO(row.visit),
    isNew: row.is_new,
    resumed: row.resumed,
    gamingDay: row.gaming_day,
  };
}
```

**Acceptance Criteria**:
- [ ] `startVisit` calls `rpc_start_or_resume_visit`
- [ ] No client-side `.update()` calls for visit closure
- [ ] DTO includes `resumed` and `gamingDay` fields
- [ ] Type check passes

---

### WS5: UI Integration

**Purpose**: Display resuming session notification and gaming day in modal.

**Deliverables**:
1. Update `components/modals/rating-slip/rating-slip-modal.tsx`

**UI Changes**:

1. **Resuming Session Notification** (when `resumed=true`):
```tsx
{modalData.resumed && (
  <div className="p-3 bg-blue-950/30 border border-blue-800/50 rounded-lg text-sm">
    <Info className="h-4 w-4 inline mr-2" />
    Resuming session from earlier today. Existing buy-in: ${totalCashIn}
  </div>
)}
```

2. **Gaming Day Display** in modal header:
```tsx
<DialogDescription>
  Gaming Day: {formatDate(modalData.slip.gamingDay)}
</DialogDescription>
```

**Acceptance Criteria**:
- [ ] Notification appears when resuming same-day visit
- [ ] Gaming day is displayed in modal header
- [ ] Type check passes
- [ ] No visual regressions

---

### WS6: Integration Tests

**Purpose**: Test gaming day boundary scenarios and financial filtering.

**Deliverables**:
1. New test file: `services/visit/__tests__/gaming-day-boundary.int.test.ts`

**Test Scenarios**:
1. **New gaming day shows $0 total** - Start visit after gaming day cutoff, verify financial totals are $0
2. **Same gaming day resumes visit** - Start visit, close, start again same day → resumed=true
3. **Cross-day rollover** - Active visit from yesterday, start today → stale visit closed, new visit created
4. **Rating slip closure on rollover** - Active slip on stale visit is closed
5. **visit_group_id continuity** - New visit inherits visit_group_id from stale visit
6. **Race condition handling** - Concurrent startVisit calls for same player

**Acceptance Criteria**:
- [ ] All test scenarios pass
- [ ] Tests use test fixtures with controlled gaming day
- [ ] Tests run in isolation

---

### WS7: Quality Validation

**Purpose**: Final build and E2E validation.

**Validation Steps**:
1. Full build passes (`npm run build`)
2. Type check passes (`npm run type-check`)
3. All tests pass (`npm test`)
4. E2E tests for rating slip modal pass

**Acceptance Criteria**:
- [ ] Build succeeds
- [ ] No type errors
- [ ] No test regressions

---

## Definition of Done

From ADR-026 Acceptance Criteria:

- [ ] New session for new gaming day shows $0 total (not historical)
- [ ] Session within same gaming day is reused with notification
- [ ] Unique constraint prevents duplicate active visits per gaming day
- [ ] MTL threshold checks use gaming-day-scoped totals
- [ ] `visit_group_id` links related visits for player history
- [ ] Existing visits from previous gaming days are closed on new session start
- [ ] Regression test reproduces and verifies fix for carry-over scenario

---

## Security Invariants (from ADR-026)

**INV-1**: Visit `gaming_day` is computed via `compute_gaming_day(casino_id, started_at)` — the canonical timezone-aware RPC

**INV-2**: At most one active visit per `(casino_id, player_id, gaming_day)` tuple

**INV-3**: Financial aggregations for "today" use `gaming_day` filter

**INV-4**: Stale visit closure is automatic on new gaming day seat action

**INV-5**: `visit_group_id` preserves multi-day player history linkage

**INV-6**: Rating slips do not span gaming days: stale visit slips are closed at rollover
