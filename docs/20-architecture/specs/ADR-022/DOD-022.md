# DOD-022: Player Identity Enrollment Definition of Done

> **Purpose:** Executable gate checklist. If it can't run in CI, it's not a gate — it's a wish.

---

## Gate Status

| Gate | Status | Test File | CI Job |
|------|--------|-----------|--------|
| A. Functional | Pending | `__tests__/services/player/identity.test.ts` | `npm run test` |
| B. Security | Pending | `__tests__/rls/player-identity.test.ts` | `npm run test:rls` |
| C. Data Integrity | Pending | `__tests__/services/player/identity-integrity.test.ts` | `npm run test` |
| D. Operability | Pending | `__tests__/services/player/identity-errors.test.ts` | `npm run test` |

---

## A. Functional Gates

### A1. Schema Gates

| Gate | Test | Status |
|------|------|--------|
| `player` table has `middle_name`, `email`, `phone_number` columns | `expect(columns).toContain('middle_name')` | [ ] |
| `player_casino` table has `enrolled_by` column | `expect(columns).toContain('enrolled_by')` | [ ] |
| `player_casino` table has `UNIQUE (casino_id, player_id)` constraint | `expect(constraints).toContain('uq_player_casino_casino_player')` | [ ] |
| `player_identity` table exists with correct columns | Schema snapshot test | [ ] |
| FK enforces enrollment prerequisite (INV-2) | Insert identity without enrollment → error | [ ] |

### A2. Enrollment Flow Gates

| Gate | Test | Status |
|------|------|--------|
| Can create player with contact info | `createPlayer({ email, phone })` succeeds | [ ] |
| Can enroll player at casino | `enrollPlayer(playerId, casinoId)` succeeds | [ ] |
| Can attach identity to enrollment | `upsertIdentity(casinoId, playerId, data)` succeeds | [ ] |
| Enrollment → Identity sequence enforced | Identity before enrollment → FK error | [ ] |

### A3. Hash + Last4 Gates

| Gate | Test | Status |
|------|------|--------|
| Document number stored as hash | `data.document_number_hash` is SHA-256 | [ ] |
| Document number last 4 extracted | `data.document_number_last4.length === 4` | [ ] |
| No plaintext document number in DB | `data.document_number === undefined` | [ ] |
| Duplicate hash detection works | Second enrollment with same doc → unique violation | [ ] |

---

## B. Security Gates

> **CRITICAL:** Tests MUST run under non-owner roles. Table owners and BYPASSRLS bypass RLS. Use `supabaseTestClient('pit_boss')` not service role.

### B1. Role Matrix Gates

| Gate | Test | Status |
|------|------|--------|
| pit_boss can read player_identity | `SELECT` as pit_boss → rows returned | [ ] |
| pit_boss can write player_identity | `INSERT` as pit_boss → success | [ ] |
| admin can read player_identity | `SELECT` as admin → rows returned | [ ] |
| admin can write player_identity | `INSERT` as admin → success | [ ] |
| cashier can read player_identity | `SELECT` as cashier → rows returned | [ ] |
| cashier CANNOT write player_identity | `INSERT` as cashier → RLS error | [ ] |
| **dealer CANNOT read player_identity** | `SELECT` as dealer → 0 rows | [ ] |
| **dealer CANNOT write player_identity** | `INSERT` as dealer → RLS error | [ ] |

### B2. Actor Binding Gates (INV-9)

| Gate | Test | Status |
|------|------|--------|
| `created_by` bound to current actor | `INSERT` with wrong `created_by` → RLS error | [ ] |
| `enrolled_by` bound to current actor | `INSERT player_casino` with wrong `enrolled_by` → RLS error | [ ] |
| `verified_by` bound to current actor | `UPDATE verified_by` with wrong value → RLS error | [ ] |
| `updated_by` auto-populated on UPDATE | After `UPDATE`, `updated_by` matches `app.actor_id` | [ ] |

### B3. Casino Isolation Gates

| Gate | Test | Status |
|------|------|--------|
| Cannot read other casino's identities | `SELECT` as casino_A, try casino_B data → 0 rows | [ ] |
| Cannot write to other casino | `INSERT` as casino_A, target casino_B → RLS error | [ ] |
| Cannot UPDATE to different casino | `UPDATE casino_id` → trigger error (INV-10) | [ ] |

### B4. Authentication Guard Gate (INV-7)

| Gate | Test | Status |
|------|------|--------|
| Anonymous cannot read player_identity | No auth.uid() → 0 rows | [ ] |
| Anonymous cannot write player_identity | No auth.uid() → RLS error | [ ] |

### B5. Immutability Gates (INV-10)

| Gate | Test | Status |
|------|------|--------|
| `casino_id` immutable after creation | `UPDATE casino_id` → trigger error | [ ] |
| `player_id` immutable after creation | `UPDATE player_id` → trigger error | [ ] |
| `created_by` immutable after creation | `UPDATE created_by` → trigger error | [ ] |

### B6. Delete Denial Gates

| Gate | Test | Status |
|------|------|--------|
| Cannot delete player_identity | `DELETE` → RLS error (false policy) | [ ] |
| Cannot delete player_casino | `DELETE` → RLS error (false policy) | [ ] |
| Cannot delete player | `DELETE` → RLS error (false policy) | [ ] |

### B7. Bounded Context Ownership Gates (SLAD)

> **CRITICAL:** These gates enforce Service Layer Access Discipline per SRM.

| Gate | Test | Status |
|------|------|--------|
| `enrollPlayer()` is in CasinoService | `grep -l "enrollPlayer" services/casino/crud.ts` → file exists | [ ] |
| `enrollPlayer()` NOT in PlayerService | `grep -l "export.*enrollPlayer" services/player/crud.ts` → 0 matches | [ ] |
| PlayerService imports from CasinoService for enrollment | Import check in `services/player/index.ts` | [ ] |
| No direct `player_casino` INSERT in PlayerService | `grep "player_casino.*insert\|\.from('player_casino')" services/player/` → 0 matches | [ ] |

---

## C. Data Integrity Gates

### C1. Constraint Gates

| Gate | Test | Status |
|------|------|--------|
| One identity per enrollment | `UNIQUE (casino_id, player_id)` enforced | [ ] |
| One document per casino | `UNIQUE (casino_id, document_number_hash)` enforced | [ ] |
| FK cascade on enrollment delete | Delete `player_casino` → cascades to `player_identity` | [ ] |

### C2. Trigger Gates

| Gate | Test | Status |
|------|------|--------|
| `updated_at` auto-updates on change | After `UPDATE`, `updated_at > created_at` | [ ] |
| `updated_by` set from session context | `updated_by` matches `app.actor_id` | [ ] |
| Immutability trigger fires on key mutation | `UPDATE player_id` → check_violation (23514) | [ ] |

---

## D. Operability Gates

### D1. Error Handling Gates

| Gate | Test | Status |
|------|------|--------|
| FK violation returns domain error | Insert without enrollment → `ENROLLMENT_REQUIRED` | [ ] |
| Unique violation returns domain error | Duplicate hash → `DUPLICATE_DOCUMENT` | [ ] |
| RLS violation returns 403 | Dealer access → `FORBIDDEN` | [ ] |
| No raw SQL in error messages | Error messages don't contain table names | [ ] |

### D2. Audit Trail Gates

| Gate | Test | Status |
|------|------|--------|
| `created_by` tracked on all inserts | All new rows have `created_by IS NOT NULL` | [ ] |
| `enrolled_by` tracked on enrollments | New enrollments have `enrolled_by IS NOT NULL` | [ ] |
| `verified_by` tracked on verification | After verification, `verified_by IS NOT NULL` | [ ] |

---

## E. Connection Pooling Gates

> **CRITICAL:** Must verify RLS works under production pooling mode.

| Gate | Test | Status |
|------|------|--------|
| RLS works with session context injection | `set_rls_context()` + query → correct rows | [ ] |
| RLS works with JWT fallback | No session vars, JWT claims → correct rows | [ ] |
| Context injection is transaction-scoped | After transaction, context cleared | [ ] |

---

## Test Implementation Template

### Bounded Context Ownership Test

```typescript
// __tests__/slad/player-identity-ownership.test.ts
import { execSync } from 'child_process';
import * as path from 'path';

describe('B7. Bounded Context Ownership (SLAD)', () => {
  const servicesDir = path.resolve(__dirname, '../../services');

  it('enrollPlayer() is in CasinoService', () => {
    const casinoFile = path.join(servicesDir, 'casino/crud.ts');
    const content = require('fs').readFileSync(casinoFile, 'utf8');
    expect(content).toMatch(/export\s+(async\s+)?function\s+enrollPlayer/);
  });

  it('enrollPlayer() is NOT exported from PlayerService', () => {
    const playerFile = path.join(servicesDir, 'player/crud.ts');
    const content = require('fs').readFileSync(playerFile, 'utf8');
    expect(content).not.toMatch(/export\s+(async\s+)?function\s+enrollPlayer/);
  });

  it('PlayerService does not write directly to player_casino', () => {
    const result = execSync(
      `grep -r "from('player_casino')" services/player/ || true`,
      { encoding: 'utf8' }
    );
    // Should only have READ operations, no INSERT/UPDATE
    expect(result).not.toMatch(/\.insert\(|\.upsert\(/);
  });
});
```

### RLS Test Template

```typescript
// __tests__/rls/player-identity.test.ts
import { createTestClient } from '@/lib/test-utils';

describe('player_identity RLS', () => {
  // CRITICAL: Use non-service role clients
  const pitBossClient = createTestClient({ role: 'pit_boss', casinoId: CASINO_A });
  const dealerClient = createTestClient({ role: 'dealer', casinoId: CASINO_A });
  const otherCasinoClient = createTestClient({ role: 'pit_boss', casinoId: CASINO_B });

  describe('B1. Role Matrix', () => {
    it('dealer CANNOT read player_identity', async () => {
      const { data, error } = await dealerClient
        .from('player_identity')
        .select('*');

      // RLS filters to 0 rows, no error
      expect(error).toBeNull();
      expect(data).toHaveLength(0);
    });

    it('dealer CANNOT write player_identity', async () => {
      const { error } = await dealerClient
        .from('player_identity')
        .insert({ /* ... */ });

      expect(error?.code).toBe('42501'); // RLS violation
    });
  });

  describe('B2. Actor Binding (INV-9)', () => {
    it('created_by must match current actor', async () => {
      const { error } = await pitBossClient
        .from('player_identity')
        .insert({
          casino_id: CASINO_A,
          player_id: ENROLLED_PLAYER,
          created_by: OTHER_STAFF_ID, // Spoofed actor
        });

      expect(error?.code).toBe('42501'); // RLS WITH CHECK violation
    });
  });

  describe('B5. Immutability (INV-10)', () => {
    it('casino_id cannot be changed', async () => {
      const { error } = await pitBossClient
        .from('player_identity')
        .update({ casino_id: CASINO_B })
        .eq('id', EXISTING_IDENTITY);

      expect(error?.code).toBe('23514'); // check_violation from trigger
      expect(error?.message).toContain('immutable');
    });
  });
});
```

---

## CI Integration

```yaml
# .github/workflows/test.yml
jobs:
  rls-gates:
    name: RLS Security Gates
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Start Supabase
        run: npx supabase start
      - name: Run RLS tests
        run: npm run test:rls
        env:
          # Use non-service role for tests
          SUPABASE_TEST_ROLE: authenticated
```

---

## Gate Completion Criteria

| Criteria | Requirement |
|----------|-------------|
| All gates pass | 100% of tests in DOD-022 pass |
| No RLS bypass | Tests run under non-owner roles |
| CI automated | Gates run on every PR |
| No manual verification | Every gate has an automated test |

---

## References

| Document | Purpose |
|----------|---------|
| **ADR-022** | Durable decisions |
| **EXEC-SPEC-022** | Implementation details |
| **FEATURE_BOUNDARY** | Scope definition |
| `docs/30-security/SEC-001-rls-policy-matrix.md` | RLS templates |

---

**Gate:** If it can't run in CI, it's not a gate — it's a wish.
