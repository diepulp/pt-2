---
# EXECUTION-SPEC Frontmatter
# Generated by lead-architect skill

prd: SHIFT-DASHBOARDS-CASH-OBS
prd_title: "Shift Dashboards v0.2 PATCH - Cash Observations Telemetry"
prd_file: docs/10-prd/PRD-Shift-Dashboards-Shift-Reports-v0.2_PATCH_cash-observations.md
service: TableContextService
mvp_phase: 2  # Extends shift dashboards with telemetry aggregates

# Workstream Definitions
workstreams:
  WS1:
    name: Rollup RPCs
    description: SECURITY INVOKER RPCs for cash observation rollups (table/pit/casino grains)
    executor: backend-service-builder
    executor_type: skill
    depends_on: []
    outputs:
      - supabase/migrations/*_shift_cash_obs_rollup_rpcs.sql
    gate: schema-validation
    estimated_complexity: medium

  WS2:
    name: Spike Alerts
    description: RPC for threshold-based cash-out spike alerts using casino_settings.alert_thresholds
    executor: backend-service-builder
    executor_type: skill
    depends_on: [WS1]
    outputs:
      - supabase/migrations/*_shift_cash_obs_alerts.sql
    gate: schema-validation
    estimated_complexity: low

  WS3:
    name: TypeScript DTOs
    description: Add CashObs rollup DTOs to table-context service + React Query keys
    executor: backend-service-builder
    executor_type: skill
    depends_on: [WS1]
    outputs:
      - services/table-context/dtos.ts
      - services/table-context/keys.ts
      - services/table-context/shift-cash-obs.ts
    gate: type-check
    estimated_complexity: low

  WS4:
    name: Integration Tests
    description: Tests for RPC correctness, alert thresholds, RLS compliance
    executor: qa-specialist
    executor_type: skill
    depends_on: [WS1, WS2, WS3]
    outputs:
      - services/table-context/__tests__/shift-cash-obs.test.ts
    gate: test-pass
    estimated_complexity: medium

# Execution Phases (topologically sorted, parallelized where possible)
execution_phases:
  - name: Phase 1 - Database Layer
    parallel: [WS1]
    gates: [schema-validation]

  - name: Phase 2 - Alerts & Types
    parallel: [WS2, WS3]
    gates: [schema-validation, type-check]

  - name: Phase 3 - Testing
    parallel: [WS4]
    gates: [test-pass]

# Validation Gates
gates:
  schema-validation:
    command: npm run db:types
    success_criteria: "Exit code 0, types regenerated"

  schema-verification:
    command: npm test schema-verification
    success_criteria: "Schema verification tests pass"

  type-check:
    command: npm run type-check
    success_criteria: "Exit code 0, no type errors"

  test-pass:
    command: npm test services/table-context/__tests__/shift-cash-obs
    success_criteria: "All tests pass"

# Dependencies on other PRDs/Services
external_dependencies:
  - prd: PRD-OPS-CASH-OBS-001
    service: RatingSlipService
    required_for: "pit_cash_observation table (data source for rollups)"
  - prd: PRD-007
    service: TableContextService
    required_for: "gaming_table.pit for pit-level grouping"
  - prd: PRD-002
    service: RatingSlipService
    required_for: "rating_slip.table_id for join path to tables"
  - prd: INTERNAL
    service: CasinoService
    required_for: "casino_settings.alert_thresholds column (migration 20260106235906 - already exists, READ-ONLY access)"

# Notes
notes:
  - "This spec does NOT modify casino_settings - it only READS alert_thresholds (CasinoService-owned)"
  - "Test location follows ADR-002 v3.0.0: services/{domain}/__tests__/"

# Risks and Mitigations
risks:
  - risk: "Stakeholders confuse telemetry rollups with authoritative Drop/Win/Hold"
    mitigation: "All DTOs and RPCs explicitly named with 'observed' prefix; UI labels say 'TELEMETRY'"
  - risk: "Table-level rollups miss observations without rating_slip_id"
    mitigation: "Document that only linked observations appear in table/pit rollups; casino-level includes all"
  - risk: "Stale alert thresholds if casino_settings not configured"
    mitigation: "Sensible defaults in RPC (table: $5000, pit: $25000)"

---

# EXECUTION-SPEC: PRD-SHIFT-DASHBOARDS-v0.2-PATCH - Cash Observations Telemetry

## Overview

This PATCH extends the Shift Dashboards feature with **cash observation telemetry rollups**. It surfaces aggregated `pit_cash_observation` data (from PRD-OPS-CASH-OBS-001) in shift dashboards without affecting authoritative Drop/Win/Hold metrics.

**Key Problem Solved**: Shift supervisors cannot see cash-out activity patterns across tables during a shift. The existing `pit_cash_observation` table captures individual observations but lacks aggregation for operational review.

**Solution**: New read-only RPCs that aggregate observations by table, pit, and casino grain, plus threshold-based spike alerts.

## Scope

### In Scope
- Rollup RPCs: `rpc_shift_cash_obs_table`, `rpc_shift_cash_obs_pit`, `rpc_shift_cash_obs_casino`
- Alert RPC: `rpc_shift_cash_obs_alerts` (threshold-based spike detection)
- TypeScript DTOs for rollup responses
- React Query key factories for caching
- Integration tests for RPC correctness and RLS compliance

### Out of Scope (PRD Non-Goals)
- Authoritative Drop/Win/Hold calculations (separate Path B implementation)
- UI components (deferred to dashboard implementation phase)
- Real-time streaming (standard polling/query pattern)
- Cross-casino aggregation

### Explicit Guardrails
- **TELEMETRY-ONLY**: Rollups are observational estimates, NOT accounting truth
- **SECURITY INVOKER**: All RPCs run with caller's RLS context (no privilege escalation)
- **No schema changes to pit_cash_observation**: Consumes existing table as-is
- **ADR-024 Client-Callable**: RPCs are called from dashboard server actions under user JWT; no client-supplied casino_id/actor_id.

### Call Pattern & RLS Context (ADR-024)
- All `rpc_shift_*` functions are **client-callable** and **SECURITY INVOKER**.
- RPCs call `set_rls_context_from_staff()` as the first statement (ADR-024).
- Callers use `withServerAction` so other queries in the request also inherit RLS context.
- Casino scope is derived inside the RPC using the hybrid pattern:
  `COALESCE(NULLIF(current_setting('app.casino_id', true), '')::uuid, (auth.jwt() -> 'app_metadata' ->> 'casino_id')::uuid)`
- **No p_casino_id / p_actor_id inputs** are accepted; scope always comes from context.

## Architecture Context

### Bounded Context Placement

**Data Ownership**: `RatingSlipService` owns `pit_cash_observation` (per SRM v4.0.0)

**Query Ownership**: `TableContextService` owns shift metrics rollup queries because:
- Rollups are table/pit operational state queries
- Join path goes through `gaming_table` (table-context owned)
- Shift dashboards are operational context, not telemetry capture

**Cross-Context Pattern**: TableContextService RPCs JOIN across:
```
pit_cash_observation (rating-slip)
  → rating_slip (rating-slip)
  → gaming_table (table-context)
```

This is valid read-only cross-context consumption via RPC (no direct table access in TypeScript).

### Join Path for Table-Level Rollups

```
pit_cash_observation.rating_slip_id → rating_slip.id
rating_slip.table_id → gaming_table.id
gaming_table.pit → pit grouping
```

**Important**: Only observations where `rating_slip_id IS NOT NULL` are included in table/pit rollups. Casino-level rollups include ALL observations.

### Rollup Fields (per SHIFT_METRICS_CATALOG §3.7)

| Field | Formula | Description |
|-------|---------|-------------|
| `cash_out_observed_estimate_total` | `SUM(amount) WHERE direction = 'out' AND amount_kind = 'estimate'` | Total estimated cash-out |
| `cash_out_observed_confirmed_total` | `SUM(amount) WHERE direction = 'out' AND amount_kind = 'cage_confirmed'` | Total cage-confirmed cash-out |
| `cash_out_observation_count` | `COUNT(*) WHERE direction = 'out'` | Number of cash-out observations |
| `cash_out_last_observed_at` | `MAX(observed_at) WHERE direction = 'out'` | Most recent cash-out observation |

**Telemetry eligibility rules (pilot)**:
- All `cash_out_*` metrics are computed from rows where `direction = 'out'`.
- `cash_in` is ignored for this pilot slice.

## Workstream Details

### WS1: Rollup RPCs

**Purpose**: Create SECURITY INVOKER RPCs for shift cash observation rollups at table, pit, and casino grains.

**Migration**: `supabase/migrations/{TIMESTAMP}_shift_cash_obs_rollup_rpcs.sql`

**RPC Signatures**:

```sql
-- Table-level rollups
CREATE OR REPLACE FUNCTION rpc_shift_cash_obs_table(
  p_start_ts TIMESTAMPTZ,
  p_end_ts TIMESTAMPTZ,
  p_table_id UUID DEFAULT NULL  -- Optional filter to single table
)
RETURNS TABLE (
  table_id UUID,
  table_label TEXT,
  pit TEXT,
  cash_out_observed_estimate_total NUMERIC,
  cash_out_observed_confirmed_total NUMERIC,
  cash_out_observation_count BIGINT,
  cash_out_last_observed_at TIMESTAMPTZ
)
LANGUAGE plpgsql
STABLE
SECURITY INVOKER
AS $$
BEGIN
  PERFORM set_rls_context_from_staff();

  RETURN QUERY
  SELECT
    rs.table_id,
    gt.label AS table_label,
    gt.pit,
    COALESCE(SUM(pco.amount) FILTER (WHERE pco.direction = 'out' AND pco.amount_kind = 'estimate'), 0),
    COALESCE(SUM(pco.amount) FILTER (WHERE pco.direction = 'out' AND pco.amount_kind = 'cage_confirmed'), 0),
    COUNT(*) FILTER (WHERE pco.direction = 'out'),
    MAX(pco.observed_at) FILTER (WHERE pco.direction = 'out')
  FROM pit_cash_observation pco
  JOIN rating_slip rs ON pco.rating_slip_id = rs.id
  JOIN gaming_table gt ON rs.table_id = gt.id
  WHERE pco.casino_id = COALESCE(
      NULLIF(current_setting('app.casino_id', true), '')::uuid,
      (auth.jwt() -> 'app_metadata' ->> 'casino_id')::uuid
    )
    AND pco.observed_at >= p_start_ts
    AND pco.observed_at < p_end_ts
    AND pco.rating_slip_id IS NOT NULL
    AND (p_table_id IS NULL OR rs.table_id = p_table_id)
  GROUP BY rs.table_id, gt.label, gt.pit
  ORDER BY SUM(pco.amount) FILTER (WHERE pco.direction = 'out' AND pco.amount_kind = 'estimate') DESC NULLS LAST;
END;
$$;

-- Pit-level rollups (grouped by pit)
CREATE OR REPLACE FUNCTION rpc_shift_cash_obs_pit(
  p_start_ts TIMESTAMPTZ,
  p_end_ts TIMESTAMPTZ,
  p_pit TEXT DEFAULT NULL  -- Optional filter to single pit
)
RETURNS TABLE (
  pit TEXT,
  cash_out_observed_estimate_total NUMERIC,
  cash_out_observed_confirmed_total NUMERIC,
  cash_out_observation_count BIGINT,
  cash_out_last_observed_at TIMESTAMPTZ
)
LANGUAGE plpgsql
STABLE
SECURITY INVOKER
AS $$
BEGIN
  PERFORM set_rls_context_from_staff();

  RETURN QUERY
  SELECT
    gt.pit,
    COALESCE(SUM(pco.amount) FILTER (WHERE pco.direction = 'out' AND pco.amount_kind = 'estimate'), 0),
    COALESCE(SUM(pco.amount) FILTER (WHERE pco.direction = 'out' AND pco.amount_kind = 'cage_confirmed'), 0),
    COUNT(*) FILTER (WHERE pco.direction = 'out'),
    MAX(pco.observed_at) FILTER (WHERE pco.direction = 'out')
  FROM pit_cash_observation pco
  JOIN rating_slip rs ON pco.rating_slip_id = rs.id
  JOIN gaming_table gt ON rs.table_id = gt.id
  WHERE pco.casino_id = COALESCE(
      NULLIF(current_setting('app.casino_id', true), '')::uuid,
      (auth.jwt() -> 'app_metadata' ->> 'casino_id')::uuid
    )
    AND pco.observed_at >= p_start_ts
    AND pco.observed_at < p_end_ts
    AND pco.rating_slip_id IS NOT NULL
    AND (p_pit IS NULL OR gt.pit = p_pit)
  GROUP BY gt.pit
  ORDER BY SUM(pco.amount) FILTER (WHERE pco.direction = 'out' AND pco.amount_kind = 'estimate') DESC NULLS LAST;
END;
$$;

-- Casino-level rollups (all observations, including those without rating_slip_id)
CREATE OR REPLACE FUNCTION rpc_shift_cash_obs_casino(
  p_start_ts TIMESTAMPTZ,
  p_end_ts TIMESTAMPTZ
)
RETURNS TABLE (
  cash_out_observed_estimate_total NUMERIC,
  cash_out_observed_confirmed_total NUMERIC,
  cash_out_observation_count BIGINT,
  cash_out_last_observed_at TIMESTAMPTZ
)
LANGUAGE plpgsql
STABLE
SECURITY INVOKER
AS $$
BEGIN
  PERFORM set_rls_context_from_staff();

  RETURN QUERY
  SELECT
    COALESCE(SUM(pco.amount) FILTER (WHERE pco.direction = 'out' AND pco.amount_kind = 'estimate'), 0),
    COALESCE(SUM(pco.amount) FILTER (WHERE pco.direction = 'out' AND pco.amount_kind = 'cage_confirmed'), 0),
    COUNT(*) FILTER (WHERE pco.direction = 'out'),
    MAX(pco.observed_at) FILTER (WHERE pco.direction = 'out')
  FROM pit_cash_observation pco
  WHERE pco.casino_id = COALESCE(
      NULLIF(current_setting('app.casino_id', true), '')::uuid,
      (auth.jwt() -> 'app_metadata' ->> 'casino_id')::uuid
    )
    AND pco.observed_at >= p_start_ts
    AND pco.observed_at < p_end_ts;
END;
$$;
```

**Acceptance Criteria**:
- [ ] `npm run db:types` succeeds
- [ ] RPCs use SECURITY INVOKER (caller's RLS context)
- [ ] RPCs derive casino scope from RLS context (no p_casino_id input)
- [ ] Table/pit rollups exclude observations where `rating_slip_id IS NULL`
- [ ] Casino rollups include ALL observations
- [ ] Rollups filter `direction = 'out'` per telemetry spec
- [ ] Results ordered by estimate_total DESC for easy identification of high-activity entities

---

### WS2: Spike Alerts

**Purpose**: Create RPC for detecting cash-out spike alerts using configurable thresholds.

**Migration**: `supabase/migrations/{TIMESTAMP}_shift_cash_obs_alerts.sql`

**Threshold Storage**: `casino_settings.alert_thresholds` JSONB column

Expected structure:
```json
{
  "cash_out_spike_table_threshold": 5000,
  "cash_out_spike_pit_threshold": 25000
}
```

**RPC Signature**:

**Severity values**: `info`, `warn`, `critical` (lowercase) per the Shift Dashboards alert thresholds doc. This RPC emits `warn` (and may emit `critical` if thresholds are extended).

```sql
CREATE OR REPLACE FUNCTION rpc_shift_cash_obs_alerts(
  p_start_ts TIMESTAMPTZ,
  p_end_ts TIMESTAMPTZ
)
RETURNS TABLE (
  alert_type TEXT,
  severity TEXT,
  entity_type TEXT,
  entity_id TEXT,
  entity_label TEXT,
  observed_value NUMERIC,
  threshold NUMERIC,
  message TEXT,
  is_telemetry BOOLEAN  -- Always TRUE for cash observations
)
LANGUAGE plpgsql
STABLE
SECURITY INVOKER
AS $$
DECLARE
  v_thresholds JSONB;
  v_table_threshold NUMERIC;
  v_pit_threshold NUMERIC;
BEGIN
  PERFORM set_rls_context_from_staff();

  -- Get thresholds from casino_settings (with sensible defaults)
  SELECT COALESCE(cs.alert_thresholds, '{}'::jsonb) INTO v_thresholds
  FROM casino_settings cs
  WHERE cs.casino_id = COALESCE(
    NULLIF(current_setting('app.casino_id', true), '')::uuid,
    (auth.jwt() -> 'app_metadata' ->> 'casino_id')::uuid
  );

  v_table_threshold := COALESCE((v_thresholds->>'cash_out_spike_table_threshold')::numeric, 5000);
  v_pit_threshold := COALESCE((v_thresholds->>'cash_out_spike_pit_threshold')::numeric, 25000);

  -- Table-level spike alerts
  RETURN QUERY
  SELECT
    'cash_out_observed_spike_telemetry'::TEXT,
    'warn'::TEXT,
    'table'::TEXT,
    r.table_id::TEXT,
    r.table_label,
    r.cash_out_observed_estimate_total,
    v_table_threshold,
    format('TELEMETRY: Table %s observed cash-out $%s exceeds threshold $%s',
           r.table_label,
           to_char(r.cash_out_observed_estimate_total, 'FM999,999,999.00'),
           to_char(v_table_threshold, 'FM999,999,999.00')),
    TRUE  -- is_telemetry
  FROM rpc_shift_cash_obs_table(p_start_ts, p_end_ts, NULL) r
  WHERE r.cash_out_observed_estimate_total > v_table_threshold;

  -- Pit-level spike alerts
  RETURN QUERY
  SELECT
    'cash_out_observed_spike_telemetry'::TEXT,
    'warn'::TEXT,
    'pit'::TEXT,
    r.pit,
    format('Pit %s', r.pit),
    r.cash_out_observed_estimate_total,
    v_pit_threshold,
    format('TELEMETRY: Pit %s observed cash-out $%s exceeds threshold $%s',
           r.pit,
           to_char(r.cash_out_observed_estimate_total, 'FM999,999,999.00'),
           to_char(v_pit_threshold, 'FM999,999,999.00')),
    TRUE  -- is_telemetry
  FROM rpc_shift_cash_obs_pit(p_start_ts, p_end_ts, NULL) r
  WHERE r.cash_out_observed_estimate_total > v_pit_threshold;
END;
$$;
```

**Acceptance Criteria**:
- [ ] Default thresholds used when `alert_thresholds` not configured
- [ ] Alerts include `is_telemetry = TRUE` flag
- [ ] Alert messages explicitly say "TELEMETRY" to prevent confusion with authoritative metrics
- [ ] Both table and pit level alerts returned

---

### WS3: TypeScript DTOs

**Purpose**: Add DTOs and service methods for consuming rollup RPCs.

**Files to Update**:

#### `services/table-context/dtos.ts` (append)

```typescript
// === Shift Cash Observation Rollup DTOs (PRD-SHIFT-DASHBOARDS v0.2 PATCH) ===
// TELEMETRY-ONLY: These rollups are observational, NOT authoritative Drop/Win/Hold

/**
 * Per-table cash observation rollup for shift window.
 * Pattern A: Contract-First - computed aggregates from RPC.
 *
 * @see PRD-SHIFT-DASHBOARDS-v0.2 §8.1 Cash observations telemetry
 */
// eslint-disable-next-line custom-rules/no-manual-dto-interfaces -- Pattern A: RPC aggregate response
export interface CashObsTableRollupDTO {
  table_id: string;
  table_label: string;
  pit: string | null;
  cash_out_observed_estimate_total: number;
  cash_out_observed_confirmed_total: number;
  cash_out_observation_count: number;
  cash_out_last_observed_at: string | null;
}

/**
 * Per-pit cash observation rollup.
 */
// eslint-disable-next-line custom-rules/no-manual-dto-interfaces -- Pattern A: RPC aggregate response
export interface CashObsPitRollupDTO {
  pit: string;
  cash_out_observed_estimate_total: number;
  cash_out_observed_confirmed_total: number;
  cash_out_observation_count: number;
  cash_out_last_observed_at: string | null;
}

/**
 * Casino-level cash observation rollup.
 */
// eslint-disable-next-line custom-rules/no-manual-dto-interfaces -- Pattern A: RPC aggregate response
export interface CashObsCasinoRollupDTO {
  cash_out_observed_estimate_total: number;
  cash_out_observed_confirmed_total: number;
  cash_out_observation_count: number;
  cash_out_last_observed_at: string | null;
}

/**
 * Cash observation spike alert.
 * TELEMETRY label: This is observational, not authoritative.
 */
// eslint-disable-next-line custom-rules/no-manual-dto-interfaces -- Pattern A: RPC alert response
export interface CashObsSpikeAlertDTO {
  alert_type: 'cash_out_observed_spike_telemetry';
  severity: 'info' | 'warn' | 'critical';
  entity_type: 'table' | 'pit';
  entity_id: string;
  entity_label: string;
  observed_value: number;
  threshold: number;
  message: string;
  is_telemetry: true;
}

// === Shift Cash Obs Input Types ===

export interface ShiftCashObsTimeWindow {
  casinoId: string; // Cache scoping only; RPC derives casino scope from RLS context.
  startTs: string;  // ISO timestamp
  endTs: string;    // ISO timestamp
}

export interface ShiftCashObsTableParams extends ShiftCashObsTimeWindow {
  tableId?: string;  // Optional filter to single table
}

export interface ShiftCashObsPitParams extends ShiftCashObsTimeWindow {
  pit?: string;  // Optional filter to single pit
}
```

#### `services/table-context/keys.ts` (append to tableContextKeys object)

```typescript
// Shift cash observation rollups (PRD-SHIFT-DASHBOARDS v0.2 PATCH)
shiftCashObs: {
  table: (casinoId: string, startTs: string, endTs: string, tableId?: string) =>
    [...ROOT, 'shift-cash-obs', 'table', casinoId, startTs, endTs, tableId ?? 'all'] as const,
  pit: (casinoId: string, startTs: string, endTs: string, pit?: string) =>
    [...ROOT, 'shift-cash-obs', 'pit', casinoId, startTs, endTs, pit ?? 'all'] as const,
  casino: (casinoId: string, startTs: string, endTs: string) =>
    [...ROOT, 'shift-cash-obs', 'casino', casinoId, startTs, endTs] as const,
  alerts: (casinoId: string, startTs: string, endTs: string) =>
    [...ROOT, 'shift-cash-obs', 'alerts', casinoId, startTs, endTs] as const,
},
```

#### `services/table-context/shift-cash-obs.ts` (new file)

```typescript
/**
 * Shift Cash Observation Rollup Queries
 *
 * TELEMETRY-ONLY: These functions return observational aggregates,
 * NOT authoritative Drop/Win/Hold metrics.
 *
 * @see PRD-SHIFT-DASHBOARDS-v0.2 PATCH
 * @see SHIFT_METRICS_CATALOG §3.7
 */

import type { SupabaseClient } from '@supabase/supabase-js';
import type { Database } from '@/types/database.types';
import { mapDatabaseError } from '@/lib/errors/supabase-error-mapper';
import type {
  CashObsTableRollupDTO,
  CashObsPitRollupDTO,
  CashObsCasinoRollupDTO,
  CashObsSpikeAlertDTO,
  ShiftCashObsTableParams,
  ShiftCashObsPitParams,
  ShiftCashObsTimeWindow,
} from './dtos';

/**
 * Get table-level cash observation rollups for a shift window.
 * Only includes observations linked to a rating slip (has table context).
 */
export async function getShiftCashObsTable(
  supabase: SupabaseClient<Database>,
  params: ShiftCashObsTableParams,
): Promise<CashObsTableRollupDTO[]> {
  const { data, error } = await supabase.rpc('rpc_shift_cash_obs_table', {
    p_start_ts: params.startTs,
    p_end_ts: params.endTs,
    p_table_id: params.tableId ?? null,
  });

  if (error) {
    throw mapDatabaseError(error);
  }

  return (data ?? []).map(toCashObsTableRollup);
}

/**
 * Get pit-level cash observation rollups for a shift window.
 */
export async function getShiftCashObsPit(
  supabase: SupabaseClient<Database>,
  params: ShiftCashObsPitParams,
): Promise<CashObsPitRollupDTO[]> {
  const { data, error } = await supabase.rpc('rpc_shift_cash_obs_pit', {
    p_start_ts: params.startTs,
    p_end_ts: params.endTs,
    p_pit: params.pit ?? null,
  });

  if (error) {
    throw mapDatabaseError(error);
  }

  return (data ?? []).map(toCashObsPitRollup);
}

/**
 * Get casino-level cash observation rollups for a shift window.
 * Includes ALL observations (even those without rating slip link).
 */
export async function getShiftCashObsCasino(
  supabase: SupabaseClient<Database>,
  params: ShiftCashObsTimeWindow,
): Promise<CashObsCasinoRollupDTO> {
  const { data, error } = await supabase.rpc('rpc_shift_cash_obs_casino', {
    p_start_ts: params.startTs,
    p_end_ts: params.endTs,
  });

  if (error) {
    throw mapDatabaseError(error);
  }

  // RPC returns single row; default if no observations
  const row = Array.isArray(data) ? data[0] : data;
  return toCashObsCasinoRollup(row);
}

/**
 * Get cash observation spike alerts for a shift window.
 * Returns alerts where observed totals exceed configured thresholds.
 */
export async function getShiftCashObsAlerts(
  supabase: SupabaseClient<Database>,
  params: ShiftCashObsTimeWindow,
): Promise<CashObsSpikeAlertDTO[]> {
  const { data, error } = await supabase.rpc('rpc_shift_cash_obs_alerts', {
    p_start_ts: params.startTs,
    p_end_ts: params.endTs,
  });

  if (error) {
    throw mapDatabaseError(error);
  }

  return (data ?? []).map(toCashObsSpikeAlert);
}

function toCashObsTableRollup(row: unknown): CashObsTableRollupDTO {
  return row as CashObsTableRollupDTO;
}

function toCashObsPitRollup(row: unknown): CashObsPitRollupDTO {
  return row as CashObsPitRollupDTO;
}

function toCashObsCasinoRollup(row: unknown): CashObsCasinoRollupDTO {
  return (
    (row as CashObsCasinoRollupDTO) ?? {
      cash_out_observed_estimate_total: 0,
      cash_out_observed_confirmed_total: 0,
      cash_out_observation_count: 0,
      cash_out_last_observed_at: null,
    }
  );
}

function toCashObsSpikeAlert(row: unknown): CashObsSpikeAlertDTO {
  return row as CashObsSpikeAlertDTO;
}
```

**Acceptance Criteria**:
- [ ] DTOs in `dtos.ts` with eslint-disable comments for Pattern A
- [ ] React Query keys added to `keys.ts`
- [ ] Service functions in `shift-cash-obs.ts` use mappers (avoid raw `as` casts at call sites)
- [ ] `npm run type-check` passes
- [ ] Export new functions from `index.ts`

---

### WS4: Integration Tests

**Purpose**: Validate RPC correctness, alert threshold behavior, and RLS compliance.

**File**: `services/table-context/__tests__/shift-cash-obs.test.ts`

```typescript
import { describe, it, expect, beforeAll, afterAll } from 'vitest';
import { createClient } from '@supabase/supabase-js';
import type { Database } from '@/types/database.types';
import {
  getShiftCashObsTable,
  getShiftCashObsPit,
  getShiftCashObsCasino,
  getShiftCashObsAlerts,
} from '../shift-cash-obs';

// Test fixtures setup would go here
// Using test database with seeded pit_cash_observation records

describe('Shift Cash Observation Rollups', () => {
  describe('rpc_shift_cash_obs_table', () => {
    it('returns rollups grouped by table with correct aggregates', async () => {
      // GIVEN: 3 observations on table A (2 estimate @ $100, 1 confirmed @ $50)
      // WHEN: Query shift window containing all 3
      // THEN: estimate_total = 200, confirmed_total = 50, count = 3
    });

    it('excludes observations outside time window', async () => {
      // GIVEN: observation at 2pm, query window 3pm-5pm
      // THEN: observation not included
    });

    it('excludes observations without rating_slip_id', async () => {
      // GIVEN: observation with rating_slip_id = NULL
      // THEN: not included in table rollups
    });

    it('filters to single table when p_table_id provided', async () => {
      // GIVEN: observations on table A and table B
      // WHEN: p_table_id = table_A
      // THEN: only table A rollup returned
    });

    it('orders results by estimate_total DESC', async () => {
      // GIVEN: table A with $1000, table B with $500
      // THEN: table A appears first
    });
  });

  describe('rpc_shift_cash_obs_pit', () => {
    it('returns rollups grouped by pit', async () => {
      // GIVEN: observations across tables in pit "Main Floor"
      // THEN: single pit rollup with aggregated totals
    });
  });

  describe('rpc_shift_cash_obs_casino', () => {
    it('includes observations without rating_slip_id', async () => {
      // GIVEN: observation with rating_slip_id = NULL
      // THEN: included in casino-level rollup
    });

    it('returns zero totals when no observations in window', async () => {
      // GIVEN: no observations in query window
      // THEN: all totals = 0, count = 0, last_observed_at = null
    });
  });

  describe('rpc_shift_cash_obs_alerts', () => {
    it('returns alert when table exceeds threshold', async () => {
      // GIVEN: casino_settings.alert_thresholds = { cash_out_spike_table_threshold: 1000 }
      // GIVEN: table with cash_out_observed_estimate_total = 1500
      // THEN: alert returned with is_telemetry = true
    });

    it('returns no alert when below threshold', async () => {
      // GIVEN: all tables below threshold
      // THEN: empty result set
    });

    it('uses default threshold when not configured', async () => {
      // GIVEN: casino_settings.alert_thresholds = NULL
      // THEN: uses default $5000 for tables
    });

    it('alert message includes TELEMETRY label', async () => {
      // THEN: message starts with "TELEMETRY:"
    });
  });

  describe('RLS: Casino scoping', () => {
    it('only returns observations for authenticated casino', async () => {
      // GIVEN: observations for casino A and casino B
      // GIVEN: RLS context set for casino A
      // THEN: only casino A observations in rollups
    });

    it('returns empty when no RLS context', async () => {
      // GIVEN: no app.casino_id set
      // THEN: query returns empty (RLS blocks access)
    });
  });
});
```

**Acceptance Criteria**:
- [ ] Tests cover all RPC correctness scenarios
- [ ] Alert threshold tests verify default and configured values
- [ ] RLS tests confirm casino scoping enforced
- [ ] All tests pass: `npm test services/table-context/__tests__/shift-cash-obs`

---

## Definition of Done

- [ ] WS1 complete (Rollup RPCs)
- [ ] WS2 complete (Spike Alerts)
- [ ] WS3 complete (TypeScript DTOs)
- [ ] WS4 complete (Integration Tests)
- [ ] All gates pass:
  - [ ] `npm run db:types` (schema-validation)
  - [ ] `npm run type-check` (type-check)
  - [ ] `npm test services/table-context/__tests__/shift-cash-obs` (test-pass)
- [ ] TELEMETRY labels present in all alert messages
- [ ] Documentation updated:
  - [ ] SRM updated to note TableContextService provides shift cash obs rollups
  - [ ] SHIFT_METRICS_CATALOG §3.7 cross-referenced

## Appendix: Migration Naming

Generate timestamps for migrations:

```bash
# WS1: Rollup RPCs
date +"%Y%m%d%H%M%S"  # e.g., 20260107093045_shift_cash_obs_rollup_rpcs.sql

# WS2: Alerts
date +"%Y%m%d%H%M%S"  # e.g., 20260107093145_shift_cash_obs_alerts.sql
```

## Appendix: Index Recommendations

The existing indexes on `pit_cash_observation` should support these queries:

- `ix_pit_cash_observation_casino_day` - covers `casino_id` filter
- `ix_pit_cash_observation_visit_time` - covers `observed_at` ordering

Consider adding if performance issues arise:

```sql
-- Composite index for shift window queries
CREATE INDEX IF NOT EXISTS ix_pit_cash_obs_casino_observed
  ON pit_cash_observation (casino_id, observed_at);

-- Cover the rating_slip_id NOT NULL filter
CREATE INDEX IF NOT EXISTS ix_pit_cash_obs_slip_not_null
  ON pit_cash_observation (rating_slip_id)
  WHERE rating_slip_id IS NOT NULL;
```
