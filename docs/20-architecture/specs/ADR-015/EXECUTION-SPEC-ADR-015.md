---
# EXECUTION-SPEC Frontmatter
# Generated by lead-architect skill
# Date: 2025-12-10

adr: ADR-015
adr_title: "RLS Connection Pooling Strategy"
category: security-infrastructure
mvp_phase: 0  # Horizontal Infrastructure - blocks all RLS-dependent operations

# Workstream Definitions
workstreams:
  WS1:
    name: Database RPC Layer
    description: Create set_rls_context() RPC that wraps SET LOCAL in single transaction
    agent: backend-developer
    depends_on: []
    outputs:
      - supabase/migrations/YYYYMMDDHHMMSS_rls_context_rpc.sql
    gate: migration-validation
    estimated_complexity: low

  WS2:
    name: TypeScript RLS Context Refactor
    description: Update injectRLSContext() to use single RPC call instead of multiple exec_sql calls
    agent: backend-developer
    depends_on: [WS1]
    outputs:
      - lib/supabase/rls-context.ts
    gate: type-check
    estimated_complexity: low

  WS3:
    name: Middleware Integration
    description: Update withServerAction and withRLS middleware to use transaction-wrapped context
    agent: backend-developer
    depends_on: [WS2]
    outputs:
      - lib/server-actions/middleware/rls.ts
      - lib/server-actions/with-server-action-wrapper.ts
    gate: type-check
    estimated_complexity: low

  WS4:
    name: Hybrid RLS Policy Migration
    description: Update existing RLS policies to use COALESCE pattern (JWT fallback)
    agent: rls-security-specialist
    depends_on: [WS1]
    outputs:
      - supabase/migrations/YYYYMMDDHHMMSS_hybrid_rls_policies.sql
    gate: migration-validation
    estimated_complexity: medium

  WS5:
    name: SEC-001 Documentation Update
    description: Update SEC-001 to reflect new canonical RLS patterns per ADR-015
    agent: lead-architect
    depends_on: [WS1, WS4]
    outputs:
      - docs/30-security/SEC-001-rls-policy-matrix.md
    gate: lint
    estimated_complexity: low

  WS6:
    name: Integration Tests
    description: RLS context persistence tests with real Supabase connection pooling
    agent: backend-developer
    depends_on: [WS2, WS3, WS4]
    outputs:
      - lib/supabase/__tests__/rls-context.integration.test.ts
    gate: test-pass
    estimated_complexity: medium

# Execution Phases (topologically sorted, parallelized where possible)
execution_phases:
  - name: Phase 1 - Database Foundation
    parallel: [WS1]
    gates: [migration-validation]
    description: Deploy set_rls_context() RPC - enables all subsequent work

  - name: Phase 2 - Parallel Implementation
    parallel: [WS2, WS4]
    gates: [type-check, migration-validation]
    description: TypeScript refactor (WS2) and hybrid policies (WS4) can run in parallel

  - name: Phase 3 - Integration
    parallel: [WS3, WS5]
    gates: [type-check, lint]
    description: Middleware integration (WS3) and docs (WS5) can run in parallel

  - name: Phase 4 - Validation
    parallel: [WS6]
    gates: [test-pass]
    description: Integration tests validate end-to-end RLS context persistence

# Validation Gates
gates:
  migration-validation:
    command: npx supabase db reset && npm run db:types
    success_criteria: "Migration applies cleanly, types regenerate without errors"

  type-check:
    command: npm run type-check
    success_criteria: "Exit code 0, no TypeScript errors"

  lint:
    command: npm run lint
    success_criteria: "Exit code 0, no errors (warnings OK)"

  test-pass:
    command: npm test lib/supabase/
    success_criteria: "All RLS context tests pass"

# Dependencies on other PRDs/Services
external_dependencies:
  - prd: PRD-HZ-001
    service: TransportLayer
    required_for: "withServerAction middleware stack is the injection point"
  - adr: ADR-008
    required_for: "Existing exec_sql RPC pattern"

# Risks and Mitigations
risks:
  - risk: "Production RLS policies may break during migration"
    mitigation: "Deploy hybrid policies first (COALESCE fallback), then switch injection method"
    severity: high

  - risk: "JWT claims approach requires user re-login for role changes"
    mitigation: "Short-term: transaction-wrapped RPC (immediate). Long-term: JWT claims (Phase 2-3)"
    severity: medium

  - risk: "Multiple SET LOCAL statements in single RPC may have performance implications"
    mitigation: "Benchmark before/after; single RPC call is likely faster than multiple round-trips"
    severity: low

---

# EXECUTION-SPEC: ADR-015 - RLS Connection Pooling Strategy

## Overview

**Problem**: PT-2 uses `SET LOCAL` session variables to inject RLS context (`app.casino_id`, `app.actor_id`, `app.staff_role`) into PostgreSQL sessions. Supabase uses Supavisor connection pooling in **transaction mode** (port 6543) by default. In transaction mode:

1. Each query may get a **different connection** from the pool
2. `SET LOCAL` settings apply only to the **current transaction**
3. If `SET LOCAL` and subsequent queries execute as separate statements, they may run on different connections
4. **Result**: RLS policies using `current_setting('app.casino_id')` fail intermittently

**Solution**: Transaction-wrapped context injection via single RPC, with hybrid policies using JWT claims as fallback.

## Scope

**In Scope**:
- Create `set_rls_context()` RPC wrapping all SET LOCAL statements in single transaction
- Refactor `injectRLSContext()` to use new RPC
- Update middleware stack for transaction-wrapped injection
- Deploy hybrid RLS policies with COALESCE fallback
- Update SEC-001 documentation
- Integration tests for RLS context persistence

**Out of Scope**:
- Full JWT claims migration (Phase 2-3 per ADR-015)
- Session mode connections for admin operations
- Individual policy migration per table (bulk migration in WS4)

## Implementation Status (Prior Work)

The following items were completed in commit `e3ce26b` (2025-12-09) as part of ADR-015 strategy formulation:

| Item | Status | File/Location |
|------|--------|---------------|
| ADR-015 created | ✅ Complete | `docs/80-adrs/ADR-015-rls-connection-pooling-strategy.md` |
| Staff RLS bootstrap fix | ✅ Complete | `supabase/migrations/20251209023430_fix_staff_rls_bootstrap.sql` |
| rls-security-specialist agent | ✅ Complete | `.claude/agents/rls-security-specialist.md` |
| SEC-001 blocker status | ✅ Complete | `docs/30-security/SEC-001-rls-policy-matrix.md` |
| Dev mode auth bypass | ✅ Complete | `lib/supabase/dev-context.ts` |

**Remaining Work** (addressed by this EXECUTION-SPEC):

| Workstream | Status | Gap Description |
|------------|--------|-----------------|
| WS1: Database RPC Layer | ❌ Pending | `set_rls_context()` RPC not created; `injectRLSContext()` still uses per-statement `exec_sql` loop |
| WS2: TypeScript Integration | ❌ Pending | `lib/supabase/rls-context.ts:100-105` uses old pattern |
| WS3: Middleware Validation | ❌ Pending | RLS middleware not integrated with transaction-wrapped pattern |
| WS4: Hybrid RLS Policies | ⚠️ Partial | Only `staff` table has hybrid policy; `visit`, `rating_slip`, `gaming_table`, `player_casino`, `dealer_rotation` need Pattern C |
| WS5: SEC-001 Update | ⚠️ Partial | ADR-015 blocker noted but canonical policy patterns not updated to Pattern A/B/C templates |
| WS6: Integration Tests | ❌ Pending | No tests validate RLS context persistence across pooled connections |

**Key Insight**: Commit `e3ce26b` was **strategy formulation** (ADR + bootstrap fix + dev bypass). This EXECUTION-SPEC implements the **actual solution** (transaction-wrapped RPC + hybrid policies + tests).

---

## Architecture Context

**References**:
- ADR-015: `docs/80-adrs/ADR-015-rls-connection-pooling-strategy.md`
- SEC-001: `docs/30-security/SEC-001-rls-policy-matrix.md`
- Current implementation: `lib/supabase/rls-context.ts`
- Middleware: `lib/server-actions/with-server-action-wrapper.ts`

**Key Files to Modify** (per `rls-security-specialist` agent):

| File | Purpose | Workstream |
|------|---------|------------|
| `lib/supabase/rls-context.ts` | Context injection implementation | WS2 |
| `lib/supabase/server.ts` | Server-side Supabase client | WS2, WS3 |
| `supabase/migrations/` | New migration files | WS1, WS4 |
| `docs/30-security/SEC-001-rls-policy-matrix.md` | Policy documentation | WS5 |
| `lib/server-actions/middleware/rls.ts` | RLS middleware | WS3 |
| `lib/server-actions/with-server-action-wrapper.ts` | Server action wrapper | WS3 |
| `lib/supabase/__tests__/rls-context.integration.test.ts` | Integration tests | WS6 |

**Memori Record** (2025-12-09):
> "RLS context injection via SET LOCAL fails with Supabase connection pooling. Each request gets fresh connection."

## Workstream Details

### WS1: Database RPC Layer

**Purpose**: Create `set_rls_context()` RPC that wraps all SET LOCAL statements in a single transaction-safe function.

**SQL Migration**:
```sql
-- Migration: YYYYMMDDHHMMSS_rls_context_rpc.sql

-- set_rls_context: Transaction-wrapped context injection
-- Called by injectRLSContext() to set all session variables atomically
CREATE OR REPLACE FUNCTION set_rls_context(
  p_actor_id uuid,
  p_casino_id uuid,
  p_staff_role text,
  p_correlation_id text DEFAULT NULL
) RETURNS void
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
BEGIN
  -- SET LOCAL ensures context persists for entire transaction
  -- The third parameter (true) makes these transaction-local
  PERFORM set_config('app.actor_id', p_actor_id::text, true);
  PERFORM set_config('app.casino_id', p_casino_id::text, true);
  PERFORM set_config('app.staff_role', p_staff_role, true);

  IF p_correlation_id IS NOT NULL THEN
    PERFORM set_config('application_name', p_correlation_id, true);
  END IF;
END;
$$;

-- Grant execute to authenticated role
GRANT EXECUTE ON FUNCTION set_rls_context(uuid, uuid, text, text) TO authenticated;

COMMENT ON FUNCTION set_rls_context IS
  'ADR-015: Transaction-wrapped RLS context injection. All SET LOCAL statements execute in same transaction, ensuring context persists for subsequent queries.';
```

**Acceptance Criteria**:
- [ ] Migration applies without errors
- [ ] Function grants execute to `authenticated` role
- [ ] Function is SECURITY DEFINER (runs with definer privileges)
- [ ] `npm run db:types` succeeds

---

### WS2: TypeScript RLS Context Refactor

**Purpose**: Update `injectRLSContext()` to use single RPC call instead of multiple `exec_sql` calls.

**Before** (`lib/supabase/rls-context.ts:84-106`):
```typescript
// Each SET LOCAL executes as separate RPC call
for (const stmt of statements) {
  const { error } = await supabase.rpc('exec_sql', { sql: stmt });
  // These may execute on DIFFERENT pooled connections!
}
```

**After**:
```typescript
/**
 * Inject RLS context via SET LOCAL (transaction-wrapped)
 *
 * Uses set_rls_context() RPC per ADR-015 to ensure all SET LOCAL
 * statements execute in the same transaction, fixing connection
 * pooling issues with Supavisor transaction mode.
 */
export async function injectRLSContext(
  supabase: SupabaseClient<Database>,
  context: RLSContext,
  correlationId?: string,
): Promise<void> {
  const { error } = await supabase.rpc('set_rls_context', {
    p_actor_id: context.actorId,
    p_casino_id: context.casinoId,
    p_staff_role: context.staffRole,
    p_correlation_id: correlationId ?? null,
  });

  if (error) {
    throw new Error(`Failed to inject RLS context: ${error.message}`);
  }
}
```

**Acceptance Criteria**:
- [ ] Single RPC call replaces multiple `exec_sql` calls
- [ ] TypeScript types match database function signature
- [ ] `npm run type-check` passes
- [ ] Backward compatible (same function signature)

---

### WS3: Middleware Integration

**Purpose**: Ensure middleware stack uses transaction-wrapped context injection correctly.

**Files to Update**:
1. `lib/server-actions/middleware/rls.ts` - Already calls `injectRLSContext()`; no changes needed if WS2 complete
2. `lib/server-actions/with-server-action-wrapper.ts` - Verify RLS context injection before handler execution

**Verification Points**:
1. `withServerAction` calls `injectRLSContext()` BEFORE `handler()`
2. Subsequent queries in `handler()` execute in same request context
3. Error handling propagates RLS injection failures correctly

**Acceptance Criteria**:
- [ ] `withServerAction` wrapper unchanged (uses updated `injectRLSContext`)
- [ ] `withRLS` middleware unchanged (delegates to `injectRLSContext`)
- [ ] All routes continue to work after refactor
- [ ] Error codes map correctly for RLS failures

---

### WS4: Hybrid RLS Policy Migration

**Purpose**: Update existing RLS policies to use Pattern C (Hybrid with Fallback) from ADR-015.

**Agent**: `rls-security-specialist` - See `.claude/agents/rls-security-specialist.md`

---

#### Approved Policy Patterns (Per rls-security-specialist)

The agent is authorized to implement ONLY these three patterns:

**Pattern A: JWT-Based (Preferred for New Code)**
```sql
CREATE POLICY "{table}_read_jwt_casino"
  ON {table_name} FOR SELECT USING (
    auth.uid() IS NOT NULL
    AND casino_id = (auth.jwt() -> 'app_metadata' ->> 'casino_id')::uuid
  );
```

**Pattern B: Transaction-Wrapped Context (Migration Path)**
```sql
CREATE POLICY "{table}_read_session_context"
  ON {table_name} FOR SELECT USING (
    auth.uid() IS NOT NULL
    AND casino_id = COALESCE(
      (current_setting('app.casino_id', true))::uuid,
      (auth.jwt() -> 'app_metadata' ->> 'casino_id')::uuid
    )
  );
```

**Pattern C: Hybrid with Fallback (Recommended for Migration)**
```sql
CREATE POLICY "{table}_read_hybrid"
  ON {table_name} FOR SELECT USING (
    auth.uid() IS NOT NULL
    AND casino_id = COALESCE(
      NULLIF(current_setting('app.casino_id', true), '')::uuid,
      (auth.jwt() -> 'app_metadata' ->> 'casino_id')::uuid
    )
  );
```

---

#### Agent Workflow

When invoked, `rls-security-specialist` MUST follow these steps:

1. **Read ADR-015 for Current Strategy**
   - Read `/home/diepulp/projects/pt-2/docs/80-adrs/ADR-015-rls-connection-pooling-strategy.md`
   - Confirm the current implementation phase and approved patterns

2. **Audit Existing RLS Policies**
   - Search for current RLS policies: `grep -r "CREATE POLICY" supabase/migrations/`
   - Identify policies using `current_setting('app.` without JWT fallback
   - Flag any policies not matching Pattern A, B, or C

3. **Audit Context Injection Code**
   - Read `lib/supabase/rls-context.ts`
   - Read `lib/supabase/server.ts`
   - Identify any `SET LOCAL` calls not wrapped in transactions

4. **Generate Migration Plan**
   - List all policies requiring migration
   - Determine target pattern (A, B, or C) for each
   - Create migration SQL in proper sequence

5. **Validate Policy Compliance**
   - Run grep to verify all policies match approved patterns
   - Flag any deviations for manual review

---

#### Tables Requiring Policy Updates

| Table | Current Pattern | New Pattern | Priority |
|-------|-----------------|-------------|----------|
| `staff` | Bootstrap (user_id = auth.uid()) | Keep as-is | - |
| `visit` | current_setting only | Hybrid (Pattern C) | P0 |
| `rating_slip` | current_setting only | Hybrid (Pattern C) | P0 |
| `gaming_table` | current_setting only | Hybrid (Pattern C) | P1 |
| `player_casino` | current_setting only | Hybrid (Pattern C) | P1 |
| `dealer_rotation` | current_setting only | Hybrid (Pattern C) | P2 |

---

#### Migration Strategy

1. DROP existing policies
2. CREATE hybrid policies with COALESCE fallback
3. Test with both injection methods

**Migration File Naming Convention**:
```
supabase/migrations/{timestamp}_adr015_{description}.sql
```

Example: `20251210120000_adr015_hybrid_rls_policies.sql`

---

#### Forbidden Actions

- DO NOT create policies without `auth.uid() IS NOT NULL` guard
- DO NOT use `SET LOCAL` without transaction wrapping
- DO NOT create new policies using only session variables (must have JWT fallback)
- DO NOT bypass RLS with `SECURITY DEFINER` unless explicitly required
- DO NOT modify policies without documenting in SEC-001

---

#### Security Verification Checklist

- [ ] No raw `SET LOCAL` outside transactions
- [ ] All policies have `auth.uid() IS NOT NULL` guard
- [ ] JWT fallback present for pooling resilience
- [ ] No cross-tenant data leakage possible
- [ ] SECURITY DEFINER used appropriately

---

#### Agent Report Template

After completing analysis or implementation, the agent provides:

```markdown
## RLS Security Specialist Report

### Scope
- Task requested: [description]
- Files analyzed: [count]
- Policies audited: [count]

### Findings

#### Non-Compliant Policies
| Policy Name | Table | Issue | Recommended Pattern |
|-------------|-------|-------|---------------------|
| ... | ... | ... | A/B/C |

#### Context Injection Issues
- [List any SET LOCAL calls not transaction-wrapped]

### Actions Taken
1. [Migration created: filename]
2. [Code modified: filepath]
3. [Documentation updated: filepath]

### Migrations Generated
- `{timestamp}_adr015_{description}.sql`

### Verification Status
- [ ] All policies match Pattern A, B, or C
- [ ] Transaction-wrapped context injection verified
- [ ] JWT claims integration tested
- [ ] No cross-tenant leakage vectors identified

### Recommendations
- [Any follow-up actions required]

### ADR-015 Compliance
- Status: COMPLIANT / PARTIAL / NON-COMPLIANT
- Deviations: [list any approved deviations]
```

---

#### Acceptance Criteria

- [ ] All casino-scoped tables have hybrid policies
- [ ] `staff` table keeps bootstrap policy (self-lookup)
- [ ] Policies work with SET LOCAL injection
- [ ] Policies work with JWT claims (future-proofing)
- [ ] No cross-tenant data access possible
- [ ] Agent report generated with compliance status

---

### WS5: SEC-001 Documentation Update

**Purpose**: Update SEC-001 to reflect new canonical RLS patterns per ADR-015.

**Changes Required**:
1. Remove "CRITICAL UPDATE" banner (ADR-015 implemented)
2. Add Pattern C (Hybrid) as canonical pattern
3. Update injection method documentation
4. Add reference to ADR-015
5. Update verification checklist

**Section Updates**:

```markdown
## Canonical RLS Pattern (ADR-015 Compliant)

**Pattern**: Transaction-wrapped context injection with JWT fallback

This pattern ensures:
1. **User is authenticated** via Supabase auth (`auth.uid()`)
2. **User is linked to active staff** via `staff.user_id`
3. **Casino scope injected** via `set_rls_context()` RPC (single transaction)
4. **JWT fallback** via `auth.jwt() -> 'app_metadata' ->> 'casino_id'`

## Policy Templates

### Template 1: Read Access (Hybrid - Preferred)

```sql
CREATE POLICY "{table}_read_hybrid"
  ON {table} FOR SELECT USING (
    auth.uid() IS NOT NULL
    AND casino_id = COALESCE(
      NULLIF(current_setting('app.casino_id', true), '')::uuid,
      (auth.jwt() -> 'app_metadata' ->> 'casino_id')::uuid
    )
  );
```
```

**Acceptance Criteria**:
- [ ] SEC-001 updated with ADR-015 patterns
- [ ] Pattern C documented as canonical
- [ ] Old Pattern A/B marked as migration path
- [ ] Verification checklist updated

---

### WS6: Integration Tests

**Purpose**: Validate RLS context persistence across queries in pooled connection environment.

**Coordination with WS4**: Integration tests MUST validate the security verification checklist from `rls-security-specialist`:
- [ ] No raw `SET LOCAL` outside transactions
- [ ] All policies have `auth.uid() IS NOT NULL` guard
- [ ] JWT fallback present for pooling resilience
- [ ] No cross-tenant data leakage possible
- [ ] SECURITY DEFINER used appropriately

**Test Cases**:

```typescript
// lib/supabase/__tests__/rls-context.integration.test.ts

describe('RLS Context Integration', () => {
  describe('Transaction-Wrapped Injection (ADR-015)', () => {
    it('should persist context across multiple queries in same request', async () => {
      const supabase = await createClient();

      // Inject context
      await injectRLSContext(supabase, {
        actorId: testStaff.id,
        casinoId: testCasino.id,
        staffRole: 'pit_boss',
      });

      // First query
      const { data: visits } = await supabase.from('visit').select('*');

      // Second query (same request, potentially different connection pre-ADR-015)
      const { data: slips } = await supabase.from('rating_slip').select('*');

      // Both should only return data for testCasino
      expect(visits?.every(v => v.casino_id === testCasino.id)).toBe(true);
      expect(slips?.every(s => s.casino_id === testCasino.id)).toBe(true);
    });

    it('should reject cross-tenant access attempts', async () => {
      const supabase = await createClient();

      // Inject context for Casino A
      await injectRLSContext(supabase, {
        actorId: casinoAStaff.id,
        casinoId: casinoA.id,
        staffRole: 'pit_boss',
      });

      // Attempt to read Casino B data
      const { data } = await supabase
        .from('visit')
        .select('*')
        .eq('casino_id', casinoB.id);

      // Should return empty (RLS blocks access)
      expect(data).toEqual([]);
    });

    it('should handle rapid sequential requests correctly', async () => {
      // Simulate multiple concurrent requests
      const requests = Array.from({ length: 10 }, (_, i) =>
        testRequest(i % 2 === 0 ? casinoA : casinoB)
      );

      const results = await Promise.all(requests);

      // Each request should only see its own casino data
      results.forEach((result, i) => {
        const expectedCasino = i % 2 === 0 ? casinoA : casinoB;
        expect(result.casinoId).toBe(expectedCasino.id);
      });
    });
  });

  describe('Hybrid Policy Fallback', () => {
    it('should work with JWT claims when SET LOCAL not available', async () => {
      // Test with authenticated user who has casino_id in JWT
      // (Simulates future JWT-based approach)
    });
  });
});
```

**Acceptance Criteria**:
- [ ] Context persists across multiple queries
- [ ] Cross-tenant access blocked
- [ ] Concurrent requests isolated correctly
- [ ] Tests pass with real Supabase (not mocks)

---

## Definition of Done

- [ ] **WS1**: `set_rls_context()` RPC deployed and callable
- [ ] **WS2**: `injectRLSContext()` uses single RPC call
- [ ] **WS3**: Middleware stack unchanged (uses updated function)
- [ ] **WS4**: Hybrid RLS policies deployed for all casino-scoped tables
- [ ] **WS5**: SEC-001 updated with ADR-015 patterns
- [ ] **WS6**: Integration tests pass for RLS context persistence
- [ ] **Gate**: All validation gates pass
- [ ] **Memory**: Record completion in Memori (arch_decisions namespace)
- [ ] **ADR-015**: Mark as "Implemented" in ADR status

## Execution Summary

```
Phase 1: WS1 (Database RPC)
    ↓ GATE: migration-validation
Phase 2: WS2 + WS4 (Parallel: TS refactor + policies)
    ↓ GATE: type-check, migration-validation
Phase 3: WS3 + WS5 (Parallel: middleware + docs)
    ↓ GATE: type-check, lint
Phase 4: WS6 (Integration tests)
    ↓ GATE: test-pass
COMPLETE
```

**Estimated Total**: 4 phases, 6 workstreams, ~2 parallel execution rounds

## Agent Assignments

| Workstream | Agent | Agent Definition | Rationale |
|------------|-------|------------------|-----------|
| WS1 | `backend-developer` | `.claude/agents/backend-developer.md` | SQL migration, lightweight |
| WS2 | `backend-developer` | `.claude/agents/backend-developer.md` | TypeScript service layer |
| WS3 | `backend-developer` | `.claude/agents/backend-developer.md` | Middleware validation |
| WS4 | `rls-security-specialist` | `.claude/agents/rls-security-specialist.md` | RLS policy expertise, security verification |
| WS5 | `lead-architect` | `.claude/skills/lead-architect/` | Governance documentation |
| WS6 | `backend-developer` | `.claude/agents/backend-developer.md` | Integration testing |

**WS4 Agent Details**: The `rls-security-specialist` is a security-focused agent with:
- **Approved Patterns**: Only Pattern A (JWT), B (Transaction-Wrapped), C (Hybrid) authorized
- **Audit Workflow**: Reads ADR-015 → Audits existing policies → Generates migration plan
- **Forbidden Actions**: No policies without auth guard, no raw SET LOCAL, no SECURITY DEFINER bypass
- **Report Output**: Structured compliance report with ADR-015 status

---

## Parallel Execution Instructions

For `/prd-execute ADR-015` invocation:

1. **Phase 1**: Launch WS1 agent
2. **GATE-1**: Validate migration applies
3. **Phase 2**: Launch WS2 and WS4 in parallel (single message, multiple Task calls)
4. **GATE-2**: Validate type-check and migration
5. **Phase 3**: Launch WS3 and WS5 in parallel
6. **GATE-3**: Validate type-check and lint
7. **Phase 4**: Launch WS6 for integration tests
8. **GATE-4**: Validate tests pass
9. **Record**: Update Memori with completion status
