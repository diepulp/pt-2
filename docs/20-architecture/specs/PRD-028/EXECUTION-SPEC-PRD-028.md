---
# EXECUTION-SPEC Frontmatter
# Generated by prd-pipeline (lead-architect scaffold + expert refinements)

prd: PRD-028
prd_title: "Restore loyalty_outbox Table (P0 Bug Fix)"
service: LoyaltyService
mvp_phase: 3  # Rewards

workstreams:
  WS1:
    name: Database Migration — Schema + RLS + Index
    description: >
      Restore loyalty_outbox (dropped in 20251213003000) with exact contract required
      by promo RPCs. DROP IF EXISTS + CREATE TABLE (not IF NOT EXISTS — prevents hiding
      schema drift). Single migration: preflight FK assertion, table creation (8 columns,
      nullable ledger_id), ENABLE RLS, 2 allow policies (SELECT, INSERT), REVOKE
      UPDATE+DELETE from authenticated+anon, 2 denial policies (UPDATE, DELETE), partial index.
    executor: backend-service-builder
    executor_type: skill
    depends_on: []
    outputs:
      - supabase/migrations/20260206005335_prd028_restore_loyalty_outbox.sql
    gate: schema-validation
    estimated_complexity: low

  WS2:
    name: Documentation Updates
    description: >
      Update SRM to verify loyalty_outbox deployed status.
      Update ADR-033 dependency section to mark outbox restoration as resolved.
    executor: lead-architect
    executor_type: skill
    depends_on: [WS1]
    outputs:
      - docs/20-architecture/SERVICE_RESPONSIBILITY_MATRIX.md
      - docs/issues/loyalty-ledger/ADR-033-LOYALTY-REWARD-DOMAIN-MODEL-SCAFFOLDING-MVP.md
    gate: type-check
    estimated_complexity: low

  WS3:
    name: RPC Integration Tests — Promo Outbox Contract
    description: >
      Integration tests verifying all three promo RPCs write correct outbox rows
      after table restoration. Tests: rpc_issue_promo_coupon, rpc_void_promo_coupon,
      rpc_replace_promo_coupon. Verifies event_type, payload, and column defaults.
    executor: backend-service-builder
    executor_type: skill
    depends_on: [WS1]
    outputs:
      - services/loyalty/__tests__/promo-outbox-contract.int.test.ts
    gate: test-pass
    estimated_complexity: medium

execution_phases:
  - name: Phase 1 — Foundation (Migration)
    parallel: [WS1]
    gates: [schema-validation]

  - name: Phase 2 — Docs + Tests (Parallel)
    parallel: [WS2, WS3]
    gates: [type-check, test-pass]

gates:
  schema-validation:
    command: npm run db:types
    success_criteria: "Exit code 0, TypeScript types regenerated"

  type-check:
    command: npm run type-check
    success_criteria: "Exit code 0"

  test-pass:
    command: npm test services/loyalty/__tests__/promo-outbox-contract.int.test.ts
    success_criteria: "All tests pass"

external_dependencies:
  - table: casino
    status: deployed
    required_for: "FK reference casino_id -> casino(id)"
  - table: loyalty_ledger
    status: deployed
    required_for: "FK reference ledger_id -> loyalty_ledger(id), nullable"
  - migration: 20260106235611_loyalty_promo_instruments.sql
    status: deployed
    required_for: "Three promo RPCs that INSERT into loyalty_outbox"

risks:
  - risk: "Outbox rows accumulate with no consumer"
    mitigation: "Append-only audit trail; pruning is future scope; rows are small (~200 bytes)"
  - risk: "ledger_id nullability changes original contract"
    mitigation: "Original callers (loyalty point RPCs) can still supply ledger_id. Only promo RPCs omit it."
---

# EXECUTION-SPEC: PRD-028 — Restore loyalty_outbox Table

## Overview

P0 bug fix restoring the `loyalty_outbox` table that was dropped in migration `20251213003000` (loyalty greenfield reset) and never recreated. Three promo RPCs (`rpc_issue_promo_coupon`, `rpc_void_promo_coupon`, `rpc_replace_promo_coupon`) INSERT into this table — every promo coupon operation currently fails at runtime.

## Scope

- **In Scope**: Table creation, RLS policies, append-only enforcement, partial index, TypeScript type regeneration, SRM verification, ADR-033 update, integration tests
- **Out of Scope**: Outbox consumer/processor, event-driven architecture, new RPCs, service layer changes, frontend changes

## Architecture Context

- **Bounded Context**: LoyaltyService owns `loyalty_outbox` (SRM v4.11.0)
- **RLS Pattern**: Pattern C hybrid (ADR-015/ADR-020) — `loyalty_outbox` is NOT an ADR-030 critical table
- **Key Change**: `ledger_id` is now nullable (was NOT NULL in original `20251109214028`) — promo events have no ledger entry
- **Migration Strategy**: DROP + CREATE (not IF NOT EXISTS) — P0 contract restore must guarantee exact schema, not silently accept drift

### RLS Bypass Analysis for Promo RPCs

The three promo RPCs are `SECURITY DEFINER` with `SET search_path = pg_catalog, public`.
In Supabase, `CREATE TABLE` runs as the `postgres` role, making `postgres` the table owner.
`SECURITY DEFINER` functions execute as their definer — also `postgres`.

**Postgres rule**: RLS policies do not apply to the table owner unless `ALTER TABLE ... FORCE ROW LEVEL SECURITY` is set. We do NOT set `FORCE ROW LEVEL SECURITY`, so:

| Caller | RLS applies? | Reason |
|--------|-------------|--------|
| Promo RPCs (DEFINER, runs as `postgres`) | **No** — table owner is exempt | `postgres` owns table; no `FORCE ROW LEVEL SECURITY` |
| Service layer queries (INVOKER, runs as `authenticated`) | **Yes** — SELECT policy enforced | `authenticated` role is subject to RLS |
| Future INVOKER write paths | **Yes** — INSERT policy enforced | `authenticated` role is subject to RLS |

**Consequence**: The INSERT policy exists solely for future INVOKER write paths. The current promo RPCs INSERT as `postgres` and are exempt from RLS evaluation entirely. The SELECT policy is the active protection — it gates service-layer reads via the `authenticated` role.

**Ownership verification** (required — the bypass analysis above depends on this):
```sql
-- WS1 migration must assert after CREATE TABLE:
DO $owner_check$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM pg_tables
    WHERE schemaname = 'public' AND tablename = 'loyalty_outbox' AND tableowner = current_user
  ) THEN
    RAISE EXCEPTION 'OWNER CHECK FAILED: loyalty_outbox is not owned by %, RLS bypass analysis may be invalid', current_user;
  END IF;
END
$owner_check$;
```
WS3 tests must also assert ownership matches the DEFINER role of the promo RPCs.

## Workstream Details

### WS1: Database Migration — Schema + RLS + Index

**Purpose**: Restore `loyalty_outbox` with full 8-column schema, RLS policies, and performance index.

**Migration File**: `supabase/migrations/20260206005335_prd028_restore_loyalty_outbox.sql`

**Migration Strategy**: `DROP TABLE IF EXISTS` + `CREATE TABLE` for the table (not `IF NOT EXISTS` —
a stale table with wrong columns would be silently accepted and RPCs would still fail).
The index uses `CREATE INDEX IF NOT EXISTS` intentionally — indexes don't affect the RPC
INSERT contract, and idempotent index creation is safe on a freshly-created table.

**Schema (from PRD Appendix A, adapted from original 20251109214028)**:
```sql
-- ============================================================================
-- PREFLIGHT: Assert FK targets exist (fail fast on broken migration ordering)
-- ============================================================================
DO $preflight$
BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_class WHERE relname = 'casino' AND relnamespace = 'public'::regnamespace) THEN
    RAISE EXCEPTION 'PREFLIGHT FAILED: public.casino does not exist — migration ordering is broken';
  END IF;
  IF NOT EXISTS (SELECT 1 FROM pg_class WHERE relname = 'loyalty_ledger' AND relnamespace = 'public'::regnamespace) THEN
    RAISE EXCEPTION 'PREFLIGHT FAILED: public.loyalty_ledger does not exist — migration ordering is broken';
  END IF;
END
$preflight$;

-- ============================================================================
-- SCHEMA: Restore loyalty_outbox (exact contract for promo RPCs)
-- ============================================================================
-- Ensure clean slate — table was dropped in 20251213003000, but guard against
-- any partial/stale recreation that would be silently accepted by IF NOT EXISTS
DROP TABLE IF EXISTS public.loyalty_outbox CASCADE;

CREATE TABLE public.loyalty_outbox (
  id            uuid           PRIMARY KEY DEFAULT gen_random_uuid(),
  casino_id     uuid           NOT NULL REFERENCES public.casino(id) ON DELETE CASCADE,
  ledger_id     uuid           REFERENCES public.loyalty_ledger(id) ON DELETE CASCADE,  -- nullable for promo events
  event_type    text           NOT NULL,
  payload       jsonb          NOT NULL,
  created_at    timestamptz    NOT NULL DEFAULT now(),
  processed_at  timestamptz,
  attempt_count int            NOT NULL DEFAULT 0
);
```

**RLS + Access Control (validated by rls-expert)** — 6 statements, exact SQL:

```sql
-- [1/6] Activate RLS
ALTER TABLE public.loyalty_outbox ENABLE ROW LEVEL SECURITY;

-- [2/6] Casino-scoped SELECT — Pattern C hybrid predicate (gates authenticated/INVOKER reads)
CREATE POLICY loyalty_outbox_select ON public.loyalty_outbox
  FOR SELECT USING (
    auth.uid() IS NOT NULL
    AND casino_id = COALESCE(
      NULLIF(current_setting('app.casino_id', true), '')::uuid,
      (auth.jwt() -> 'app_metadata' ->> 'casino_id')::uuid
    )
  );

-- [3/6] Casino-scoped INSERT — same Pattern C predicate (defense-in-depth for future INVOKER writes;
--        promo RPCs run as postgres/table-owner and are exempt from RLS — see bypass analysis above)
CREATE POLICY loyalty_outbox_insert ON public.loyalty_outbox
  FOR INSERT WITH CHECK (
    auth.uid() IS NOT NULL
    AND casino_id = COALESCE(
      NULLIF(current_setting('app.casino_id', true), '')::uuid,
      (auth.jwt() -> 'app_metadata' ->> 'casino_id')::uuid
    )
  );

-- ============================================================================
-- APPEND-ONLY ENFORCEMENT (belt-and-suspenders, two independent layers)
--
-- Why both layers:
--   Layer 1 (REVOKE): Removes UPDATE/DELETE privilege from authenticated/anon roles.
--     This is the hard guarantee — privilege checks run BEFORE RLS evaluation.
--     Protects against: any code path using authenticated or anon role.
--     Does NOT protect: postgres (table owner), service_role, or any role
--     granted UPDATE/DELETE in the future by a careless GRANT.
--
--   Layer 2 (denial policies): RLS policies that evaluate to false.
--     Protects against: any role that somehow retains or is granted UPDATE/DELETE
--     privilege in the future (e.g., a new role, an accidental GRANT).
--     Does NOT protect: postgres/table-owner (exempt from RLS, see bypass analysis).
--
--   Neither layer protects postgres — that is by-convention for admin operations.
--   Together they ensure no application-level role can mutate outbox rows even if
--   one layer is misconfigured (privilege re-granted or RLS force-enabled changes).
-- ============================================================================

-- [4/6] Layer 1: Privilege revocation (checked before RLS, not bypassable via SET config)
REVOKE UPDATE, DELETE ON public.loyalty_outbox FROM authenticated, anon;

-- [5/6] Layer 2: Denial policy — catches future roles with UPDATE privilege
-- NOTE: `auth.uid() IS NOT NULL AND false` is functionally identical to `false`.
-- The auth.uid() prefix is redundant but kept for SEC-006 pattern consistency across
-- all PT-2 denial policies (loyalty_ledger, mtl_entry, finance_outbox use the same form).
CREATE POLICY loyalty_outbox_no_updates ON public.loyalty_outbox
  FOR UPDATE USING (auth.uid() IS NOT NULL AND false);

-- [6/6] Layer 2: Denial policy — catches future roles with DELETE privilege (same note)
CREATE POLICY loyalty_outbox_no_deletes ON public.loyalty_outbox
  FOR DELETE USING (auth.uid() IS NOT NULL AND false);
```

**Index**:
```sql
CREATE INDEX IF NOT EXISTS ix_loyalty_outbox_unprocessed
  ON public.loyalty_outbox (casino_id, created_at DESC)
  WHERE processed_at IS NULL;
```

**Acceptance Criteria**:
- [ ] Preflight assertion passes (casino and loyalty_ledger tables exist — fails fast on broken migration ordering)
- [ ] Migration applies cleanly (DROP IF EXISTS + CREATE TABLE guarantees exact schema)
- [ ] `npm run db:types` succeeds
- [ ] Exactly 6 RLS/access-control statements applied: 1 ENABLE RLS, 2 allow policies, 1 REVOKE (2 privileges), 2 denial policies
- [ ] All three promo RPCs execute without "relation does not exist" error
- [ ] Column contract verified: 4 RPC-supplied columns + 4 default-resolved columns match schema
- [ ] Table ownership assertion passes: `loyalty_outbox` owner = migration runner role (validates RLS bypass analysis)

### WS2: Documentation Updates

**Purpose**: Update SRM and ADR-033 to reflect restoration.

**Deliverables**:
1. SRM: Verify `loyalty_outbox` row shows correct status (already listed under LoyaltyService)
2. ADR-033: Update dependency section to mark outbox restoration as resolved

**Acceptance Criteria**:
- [ ] SRM `loyalty_outbox` entry verified accurate
- [ ] ADR-033 dependency section references PRD-028 resolution

### WS3: RPC Integration Tests — Promo Outbox Contract

**Purpose**: Verify all three promo RPCs write correct outbox rows after table restoration.

**Test File**: `services/loyalty/__tests__/promo-outbox-contract.int.test.ts`

**Test Structure**:
```
describe('loyalty_outbox promo RPC contract (PRD-028)')
  ├── setup: auth client, casino fixture (known casino_id), player, promo_program fixtures
  │
  ├── test: rpc_issue_promo_coupon writes outbox row
  │     assert: event_type = 'promo_coupon_issued'
  │     assert: payload is non-empty JSONB containing coupon_id
  │     assert: casino_id = fixture casino_id (context derivation, not hardcoded)
  │
  ├── test: rpc_void_promo_coupon writes outbox row
  │     assert: event_type = 'promo_coupon_voided'
  │     assert: payload contains coupon_id and voided_by
  │     assert: casino_id = fixture casino_id
  │
  ├── test: rpc_replace_promo_coupon writes outbox row
  │     assert: event_type = 'promo_coupon_replaced'
  │     assert: payload contains old_coupon_id and new_coupon_id
  │     assert: casino_id = fixture casino_id
  │
  ├── test: omitted columns resolve to schema defaults
  │     assert: id is valid UUID (auto-generated)
  │     assert: ledger_id IS NULL (promo events have no ledger entry)
  │     assert: processed_at IS NULL
  │     assert: attempt_count = 0
  │     assert: created_at is within 5s of now() (not NULL, not epoch)
  │
  └── test: table ownership matches RPC definer role
        query: SELECT tableowner FROM pg_tables WHERE schemaname='public' AND tablename='loyalty_outbox'
        assert: tableowner = expected role (validates RLS bypass analysis)
```

**Acceptance Criteria**:
- [ ] All 5 test cases pass
- [ ] No "relation loyalty_outbox does not exist" errors
- [ ] Each RPC's outbox row has correct `event_type` and non-empty `payload`
- [ ] Each outbox row's `casino_id` equals the fixture casino — verifies context derivation wrote the correct scope
- [ ] Default column values verified (id=UUID, ledger_id=NULL, processed_at=NULL, attempt_count=0, created_at~now())

## Definition of Done

- [ ] All workstream outputs created (WS1 migration, WS2 docs, WS3 tests)
- [ ] All gates pass (schema-validation, type-check, test-pass)
- [ ] No regressions in existing tests
- [ ] TypeScript types regenerated (`npm run db:types`)
- [ ] SRM verified, ADR-033 updated
