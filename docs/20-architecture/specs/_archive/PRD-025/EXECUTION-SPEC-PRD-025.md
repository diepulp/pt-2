---
# EXECUTION-SPEC Frontmatter
# Generated by prd-pipeline (lead-architect + rls-expert + backend-service-builder + frontend-design)

prd: PRD-025
prd_title: "Onboarding v0.1 — Tenant Bootstrap, Staff Invites & Company Posture"
service: CasinoService
mvp_phase: 0  # Horizontal / cross-cutting (foundational onboarding)

workstreams:
  WS1:
    name: "Schema: staff_invite Table + Company RLS Lockdown + Invite RLS Policies"
    description: >
      Create staff_invite table with unique partial index, enable RLS on company
      (deny-by-default), and add staff_invite RLS policies (admin-only, casino-scoped,
      Template 2b session-var-only for all operations including SELECT — PII tightening).
      Bundled in a single migration (cohesive security unit, consistent with SEC-006 precedent).
      Update SEC-001/SEC-002 docs to codify company-as-metadata posture.
    executor: rls-expert
    executor_type: skill
    depends_on: []
    outputs:
      - supabase/migrations/YYYYMMDDHHMMSS_prd025_staff_invite_company_rls.sql
      - docs/30-security/SEC-001-rls-policy-matrix.md
      - docs/30-security/SEC-002-casino-scoped-security-model.md
    gate: schema-validation
    estimated_complexity: medium

  WS2:
    name: "RPC: Bootstrap Casino + GAP-4 Casino Active Validation"
    description: >
      Create rpc_bootstrap_casino (SECURITY DEFINER) that atomically creates
      casino + casino_settings + first admin staff binding. Amend
      set_rls_context_from_staff() to JOIN casino table and validate
      casino.status = 'active' (GAP-4 closure). Uses CREATE OR REPLACE
      (return type unchanged — safer than DROP+CREATE). Emit audit log event
      `tenant_bootstrap` capturing actor + casino ids.
    executor: rls-expert
    executor_type: skill
    depends_on: [WS1]
    outputs:
      - supabase/migrations/YYYYMMDDHHMMSS_prd025_rpc_bootstrap_gap4.sql
    gate: schema-validation
    estimated_complexity: high

  WS3:
    name: "RPC: Invite Create + Accept"
    description: >
      Create rpc_create_staff_invite (admin-only, hashed token via pgcrypto,
      returns raw token once with configurable TTL defaulting to 72 hours) and
      rpc_accept_staff_invite (validates token hash, creates staff binding, marks
      invite accepted, emits audit log `staff_invite_accepted`). Both SECURITY
      DEFINER. Invite creation also logs `staff_invite_created`.
    executor: rls-expert
    executor_type: skill
    depends_on: [WS1]
    outputs:
      - supabase/migrations/YYYYMMDDHHMMSS_prd025_rpc_invite_create_accept.sql
    gate: schema-validation
    estimated_complexity: high

  WS4:
    name: "Service Layer: CasinoService Onboarding Extensions"
    description: >
      Extend existing CasinoService with TypeScript RPC wrappers, DTOs,
      Zod schemas, and React Query key factories for bootstrap and invite flows.
      Pattern B DTOs derived from Database types via Pick/Omit.
    executor: backend-service-builder
    executor_type: skill
    depends_on: [WS2, WS3]
    outputs:
      - services/casino/dtos.ts
      - services/casino/schemas.ts
      - services/casino/crud.ts
      - services/casino/keys.ts
      - services/casino/http.ts
      - services/casino/index.ts
    gate: type-check
    estimated_complexity: medium

  WS5:
    name: "Tests: Bootstrap + Invite + RLS"
    description: >
      Unit tests for bootstrap idempotency and invite lifecycle. Integration
      test for full bootstrap -> invite -> accept -> context derivation flow.
      RLS tests for casino isolation and company deny-by-default.
    executor: backend-service-builder
    executor_type: skill
    depends_on: [WS4]
    outputs:
      - services/casino/__tests__/bootstrap.test.ts
      - services/casino/__tests__/invite.test.ts
      - services/casino/__tests__/onboarding-rpc-contract.test.ts
      - services/casino/__tests__/onboarding.int.test.ts
    gate: test-pass
    estimated_complexity: medium

  WS6:
    name: "UI: Bootstrap Wizard + Invite Screens + Accept Screen"
    description: >
      Bootstrap wizard (single-page form), invite management screen (admin),
      and invite acceptance screen. Uses withServerAction middleware compositor
      for server actions, useMutation/useQuery from TanStack Query for client
      mutations/queries, shadcn/ui components, React 19 useActionState for
      bootstrap form. Onboarding layout is centered max-w-lg (no sidebar/header).
      External dependency on PRD-024 Phase 1B for route group scaffold.
    executor: frontend-design:frontend-design-pt-2
    executor_type: skill
    depends_on: [WS4]
    outputs:
      - app/(onboarding)/layout.tsx                      # MODIFY (exists from PRD-024 WS3)
      - app/(onboarding)/bootstrap/page.tsx              # REPLACE (placeholder exists from PRD-024 WS3)
      - app/(onboarding)/bootstrap/_actions.ts           # CREATE
      - app/(onboarding)/invite/manage/page.tsx          # CREATE
      - app/(onboarding)/invite/manage/_actions.ts       # CREATE
      - app/(onboarding)/invite/accept/page.tsx          # CREATE
      - app/(onboarding)/invite/accept/_actions.ts       # CREATE
      - components/onboarding/bootstrap-form.tsx         # CREATE
      - components/onboarding/invite-form.tsx            # CREATE
      - components/onboarding/invite-list.tsx            # CREATE
      - components/onboarding/accept-invite-handler.tsx  # CREATE
      - hooks/casino/use-onboarding-mutations.ts         # CREATE
    gate: type-check
    estimated_complexity: medium

execution_phases:
  - name: "Phase 1 — Schema + Security Docs"
    parallel: [WS1]
    gates: [schema-validation]

  - name: "Phase 2 — Bootstrap RPC"
    parallel: [WS2]
    gates: [schema-validation]

  - name: "Phase 3 — Invite RPCs"
    parallel: [WS3]
    gates: [schema-validation]

  - name: "Phase 4 — Service Layer"
    parallel: [WS4]
    gates: [type-check]

  - name: "Phase 5 — Tests + UI"
    parallel: [WS5, WS6]
    gates: [test-pass, type-check, lint]

gates:
  schema-validation:
    command: "npm run db:types"
    success_criteria: "Exit code 0, types regenerated without errors"

  type-check:
    command: "npm run type-check"
    success_criteria: "Exit code 0, no type errors"

  test-pass:
    command: "npm test services/casino/__tests__/bootstrap.test.ts services/casino/__tests__/invite.test.ts services/casino/__tests__/onboarding-rpc-contract.test.ts"
    success_criteria: "All tests pass"

  lint:
    command: "npm run lint"
    success_criteria: "Exit code 0 (warnings acceptable)"

external_dependencies:
  - prd: PRD-024
    service: CasinoService
    required_for: "Route group scaffold (onboarding), /start gateway, setup_status migration, /signin canonical auth route, middleware public paths for /invite/*"
    impact: "WS6 UI can function standalone; gateway wiring is additive. PRD-024 WS2 middleware public paths must be extended to include /invite/manage and /invite/accept."

  - prd: AUTH-HARDENING-v0.1
    service: CrossCutting
    required_for: "set_rls_context_from_staff() RETURNS TABLE signature (WS2 extends this)"
    impact: "Must be deployed before WS2 migration runs"

risks:
  - risk: "WS2 modifies set_rls_context_from_staff() called by every authenticated RPC"
    mitigation: "Uses CREATE OR REPLACE (not DROP+CREATE) — return type unchanged. Only change is added casino JOIN in staff lookup query. Regression test: verify existing callers unaffected."

  - risk: "PRD-024 gateway not live when WS6 ships"
    mitigation: "Bootstrap wizard functions standalone via direct navigation. Gateway wiring is additive."

  - risk: "Company RLS lockdown breaks existing queries"
    mitigation: "Company is rarely queried directly. Verify no client-side reads depend on it."

  - risk: "Token brute-force on invite acceptance"
    mitigation: "72h TTL, single-use tokens, SHA-256 hashed storage, 32-byte raw tokens (2^256 search space)"

  - risk: "auth.uid() identity model confusion (Option A vs Option B)"
    mitigation: >
      Codified as Option A (Bound Identity) in Architecture Context. auth.uid() = auth.users.id
      always. staff.user_id is FK to auth.users(id). JWT sub = auth.users.id. staff.id is the
      actor_id in RLS context. Bootstrap/accept RPCs create staff.user_id = auth.uid() binding.
      syncUserRLSClaims(userId=auth.uid()) syncs JWT claims. Option B (sub=staff.id) was never
      implemented and is explicitly rejected. See ADR-024 INV-3 and migration
      20251229152317_adr024_rls_context_from_staff.sql for authoritative implementation.
---

# EXECUTION-SPEC: PRD-025 — Onboarding v0.1

## Overview

Ship the minimum onboarding flow: (1) atomic tenant bootstrap RPC, (2) invite-based staff onboarding with hashed tokens, (3) company RLS lockdown, and (4) GAP-4 casino active validation fix. All within CasinoService bounded context.

## Scope

**In Scope:**
- `staff_invite` table with RLS policies (admin-only, casino-scoped)
- Security documentation updates in SEC-001/SEC-002 reflecting company-as-metadata decision
- `rpc_bootstrap_casino` — atomic casino + settings + admin staff creation
- `rpc_create_staff_invite` / `rpc_accept_staff_invite` — invite lifecycle RPCs
- Company table RLS enable (deny-by-default)
- GAP-4 fix: casino active validation in `set_rls_context_from_staff()`
- Service layer TypeScript wrappers and tests
- Bootstrap wizard + invite management + accept UI screens
- Audit log events for tenant bootstrap and invite lifecycle steps

**Out of Scope (explicit deferrals):**
- Start Gateway route, `setup_status` migration, middleware, auth redirects — owned by PRD-024
- Email delivery automation (v0.1 uses "copy link")
- Wizard B (Initial Setup Wizard) — separate PRD
- Multi-casino membership per user
- Company-as-security-boundary

## Architecture Context

- **Bounded Context:** CasinoService (Foundational) per SRM v4.11.0
- **Tables Owned:** casino, casino_settings, company, staff, staff_invite (new)
- **RLS Strategy:** ADR-020 Track A (Pattern C hybrid), ADR-030 write-path hardening
- **Context Derivation:** ADR-024 authoritative `set_rls_context_from_staff()`, ADR-030 D1 RETURNS TABLE
- **SECURITY DEFINER Governance:** ADR-018 Template 5 context validation
- **Security Invariants:** ADR-024 INV-8 (no spoofable casino_id/actor_id params)

### Identity Model (Option A — Bound Identity)

> **Invariant**: `auth.uid()` always returns `auth.users.id` (the Supabase auth user UUID). It is **never** `staff.id`.

| Concept | Value | Source |
|---------|-------|--------|
| `auth.uid()` / JWT `sub` | `auth.users.id` (UUID) | Supabase standard — immutable |
| `staff.user_id` | FK → `auth.users(id)` | 1:1 binding, unique partial index (NULL for non-auth dealers) |
| `staff.id` | Staff table PK (actor_id in RLS context) | `app.actor_id` after context injection |
| `app_metadata.staff_id` | `staff.id` — JWT claim for fallback lookup | Synced via `syncUserRLSClaims()` |
| `app_metadata.casino_id` | `casino.id` from staff record | Synced via `syncUserRLSClaims()` |
| `app_metadata.staff_role` | `staff.role` | Synced via `syncUserRLSClaims()` |

**Context derivation flow** (`set_rls_context_from_staff()`):
1. Extract `staff_id` from `app_metadata.staff_id` JWT claim
2. If present: validate binding `staff.id = v_staff_id AND staff.user_id = auth.uid()` (prevents token escalation)
3. If absent: fallback lookup `staff WHERE user_id = auth.uid()` (first login, no claims yet)
4. Derive `casino_id`, `role` from staff record → `SET LOCAL` session vars

**Bootstrap/accept exception**: New users have no staff binding. `rpc_bootstrap_casino` and `rpc_accept_staff_invite` use `auth.uid()` directly (not `set_rls_context_from_staff()`) to identify the caller, then INSERT `staff.user_id = auth.uid()` to create the binding. After success, TypeScript layer calls `syncUserRLSClaims(auth.uid(), { staff_id, casino_id, staff_role })` so subsequent requests have JWT claims.

**References**: `supabase/migrations/20251229152317_adr024_rls_context_from_staff.sql`, `lib/supabase/auth-admin.ts`

---

## Workstream Details

### WS1: Schema — staff_invite Table + Company RLS Lockdown + Invite RLS Policies

**Purpose:** Create the `staff_invite` table and lock down security posture for both `staff_invite` and `company` tables.

**Deliverables — Single Migration File:**

1. **staff_invite table DDL:**
   - `id uuid PRIMARY KEY DEFAULT gen_random_uuid()`
   - `casino_id uuid NOT NULL REFERENCES casino(id)`
   - `email text NOT NULL`
   - `staff_role staff_role NOT NULL` (uses existing enum: dealer, pit_boss, cashier, admin)
   - `token_hash text NOT NULL`
   - `expires_at timestamptz NOT NULL`
   - `accepted_at timestamptz NULL`
   - `created_by uuid NOT NULL REFERENCES staff(id)`
   - `created_at timestamptz NOT NULL DEFAULT now()`

2. **Unique partial index:**
   ```sql
   CREATE UNIQUE INDEX idx_staff_invite_active
     ON staff_invite (casino_id, lower(email))
     WHERE accepted_at IS NULL;
   ```

3. **staff_invite RLS policies:**
   - `ALTER TABLE staff_invite ENABLE ROW LEVEL SECURITY`
   - **SELECT** `staff_invite_select_admin_session` (admin-only, Template 2b session-var-only):
     ```
     auth.uid() IS NOT NULL
     AND casino_id = NULLIF(current_setting('app.casino_id',true),'')::uuid
     AND NULLIF(current_setting('app.staff_role',true),'') = 'admin'
     ```
     > **Security tightening (deviates from ADR-030 D4 SELECT default):** `staff_invite` contains PII (staff emails) and operational metadata. Using session-var-only for SELECT eliminates the stale-JWT window (up to 3600s per `config.toml:127`) where a demoted admin could still read invites via cached `app_metadata.staff_role = 'admin'` JWT claim. This is safe because: (1) `staff_invite` is a new table with no existing queries to break, (2) all authenticated requests go through `withRLS` → `set_rls_context_from_staff()` which sets session vars, (3) INSERT/UPDATE already require session vars — making SELECT consistent. The `listStaffInvites` query in `crud.ts` runs within `withRLS` context, so session vars are always present.
   - **INSERT** `staff_invite_insert_admin_session` (admin-only, Template 2b session-var-only):
     ```
     auth.uid() IS NOT NULL
     AND casino_id = NULLIF(current_setting('app.casino_id',true),'')::uuid
     AND NULLIF(current_setting('app.staff_role',true),'') = 'admin'
     ```
   - **UPDATE** `staff_invite_update_admin_session` (admin-only, Template 2b + WITH CHECK):
     ```
     USING (
       auth.uid() IS NOT NULL
       AND casino_id = NULLIF(current_setting('app.casino_id',true),'')::uuid
       AND NULLIF(current_setting('app.staff_role',true),'') = 'admin'
     )
     WITH CHECK (
       casino_id = NULLIF(current_setting('app.casino_id',true),'')::uuid
     )
     ```
   - **No DELETE policy** — invites are never deleted, only accepted or expired

4. **Column-level privilege hardening — `token_hash`:**
   ```sql
   -- Revoke SELECT on token_hash from authenticated role.
   -- Even though token_hash is SHA-256 of random bytes (not reversible),
   -- defense-in-depth: prevent "creative querying" via Supabase REST API.
   -- SECURITY DEFINER RPCs (rpc_accept_staff_invite) still have access
   -- because they run as the function owner (superuser), not authenticated.
   REVOKE SELECT (token_hash) ON staff_invite FROM authenticated;
   ```
   > **Note:** This is the first column-level REVOKE in the codebase. Existing column restriction uses views (`visit_financial_summary`, `mtl_gaming_day_summary`), but a view is overkill here — `staff_invite` needs no aggregation or computed columns. Column-level REVOKE is the minimal, targeted hardening. The `listStaffInvites` SELECT in `crud.ts` already excludes `token_hash` from its column list, so this REVOKE has zero functional impact on the application.

5. **Company RLS lockdown:**
   ```sql
   -- Explicit cleanup: drop any pre-existing permissive policies on company
   -- so lockdown doesn't depend on the past being perfectly clean.
   DO $$ DECLARE pol record;
   BEGIN
     FOR pol IN
       SELECT policyname FROM pg_policies
       WHERE tablename = 'company' AND schemaname = 'public'
     LOOP
       EXECUTE format('DROP POLICY %I ON public.company', pol.policyname);
     END LOOP;
   END $$;

   ALTER TABLE company ENABLE ROW LEVEL SECURITY;
   -- No permissive policies for authenticated role = deny-by-default
   -- Only service_role and SECURITY DEFINER RPCs can access
   ```

6. **Security documentation updates:**
   - `docs/30-security/SEC-001-rls-policy-matrix.md` — add PRD-025 entry documenting company deny-by-default stance and staff_invite policy templates.
   - `docs/30-security/SEC-002-casino-scoped-security-model.md` — add subsection clarifying "company as metadata" decision, absence of `app.company_id`, and invite-scope posture.

**Patterns Applied:**
- ADR-030 D4 Template 2b session-var-only for ALL policies (SELECT, INSERT, UPDATE) — PII tightening; deviates from D4 SELECT default because `staff_invite` is new (no breakage risk) and contains emails
- SEC-001 deny-by-default for company

**Implementation Hints:**
- Bundle table DDL + RLS policies + company lockdown in one migration (cohesive security unit — consistent with SEC-006 precedent, not a governance mandate)
- `staff_role` column uses the existing `staff_role` ENUM (dealer|pit_boss|cashier|admin)
- `created_by` REFERENCES staff(id) — admin who created the invite
- `token_hash` is text, not bytea — stores hex-encoded SHA-256 hash
- Company deny-by-default: DROP all pre-existing policies first, then ENABLE RLS — do NOT add any new permissive policies
- Test: verify authenticated role SELECT on company returns 0 rows after lockdown

**Governance — Migration Safety Hook:**
- Migration contains RLS policy changes → pre-commit hook requires one of: `ADR-015`, `VERIFIED_SAFE`, or `RLS_REVIEW_COMPLETE` markers in migration header
- Include `ADR-030` marker (Template 2b session-var-only for all three policies — SELECT/INSERT/UPDATE)
- SEC-001/SEC-002 doc updates are separate file edits (not inside the .sql migration) — can be in same PR or separate commit; no governance rule constrains this

**Acceptance Criteria:**
- [ ] `npm run db:types` succeeds — `staff_invite` appears in `Database` types
- [ ] `company` table has RLS enabled with all pre-existing permissive policies dropped (clean deny-by-default)
- [ ] `staff_invite` has 3 RLS policies (SELECT, INSERT, UPDATE)
- [ ] No DELETE policy on `staff_invite`
- [ ] All 3 policies (SELECT, INSERT, UPDATE) use NULLIF-only — no COALESCE, no JWT fallback (Template 2b session-var-only for PII protection)
- [ ] `REVOKE SELECT (token_hash) ON staff_invite FROM authenticated` applied — column not readable by authenticated role
- [ ] `rpc_accept_staff_invite` (SECURITY DEFINER) can still read `token_hash` for validation
- [ ] Unique partial index enforces one active invite per casino+email
- [ ] Migration ends with `NOTIFY pgrst, 'reload schema'`
- [ ] Migration header includes `ADR-030` marker (pre-commit hook requirement)
- [ ] SEC-001 / SEC-002 updated with company metadata decision + invite policies (reviewed by security owner)

---

### WS2: RPC — Bootstrap Casino + GAP-4 Casino Active Validation

**Purpose:** Create the atomic tenant bootstrap RPC and close GAP-4 by adding casino active validation to the core RLS context function.

**Deliverables — Single Migration File:**

1. **`rpc_bootstrap_casino` (SECURITY DEFINER):**

   **Signature:**
   ```sql
   CREATE FUNCTION public.rpc_bootstrap_casino(
     p_casino_name text,
     p_timezone text DEFAULT 'America/Los_Angeles',
     p_gaming_day_start time DEFAULT '06:00'
   ) RETURNS TABLE (casino_id uuid, staff_id uuid, staff_role text)
   LANGUAGE plpgsql
   SECURITY DEFINER
   SET search_path = pg_catalog, public
   ```

   **Logic flow:**
   1. Validate `auth.uid() IS NOT NULL` — reject anonymous callers
   2. Check idempotency: `SELECT FROM staff WHERE user_id = auth.uid() AND status = 'active'`. If exists → RAISE `CONFLICT: user already has staff binding` (ERRCODE `23505`)
   3. INSERT casino (name, status='active')
   4. INSERT casino_settings (casino_id, timezone, gaming_day_start_time)
   5. INSERT staff (casino_id, user_id=auth.uid(), role='admin', status='active', first_name='Admin', last_name='User')
   6. RETURN casino_id, staff_id, 'admin'

   > **Identity model note (Option A):** `auth.uid()` = `auth.users.id` (Supabase auth user UUID). `staff.user_id` is an FK to `auth.users(id)`. Step 2 looks up existing staff by `user_id = auth.uid()` (auth user → staff mapping). Step 5 creates the staff binding with `user_id = auth.uid()` (FK to auth.users). This is **not** `staff.id` — the staff PK is a new `gen_random_uuid()`.

   **Note:** JWT claim sync (`syncUserRLSClaims(auth.uid(), { staff_id, casino_id, staff_role })`) happens at TypeScript service layer, NOT in the RPC. The `userId` parameter to `syncUserRLSClaims` is `auth.users.id`, not `staff.id`.

   **Key design decisions:**
   - Does NOT call `set_rls_context_from_staff()` — user has no staff binding yet (bootstrap creates it)
   - Uses `auth.uid()` directly for user identification (`auth.users.id`, per Identity Model §above)
   - No `p_casino_id` or `p_actor_id` parameters (INV-8 compliant)
   - Single transaction — any failure rolls back all three inserts

   **Grants:**
   ```sql
   REVOKE ALL ON FUNCTION public.rpc_bootstrap_casino FROM PUBLIC;
   GRANT EXECUTE ON FUNCTION public.rpc_bootstrap_casino TO authenticated;
   ```

2. **GAP-4 fix — amend `set_rls_context_from_staff()`:**

   **Pattern:** CREATE OR REPLACE (return type `TABLE(actor_id uuid, casino_id uuid, staff_role text)` is unchanged — safer than DROP+CREATE).

   **Change:** Add JOIN to casino table in the staff context derivation query:
   ```sql
   -- BEFORE (current):
   SELECT s.casino_id, s.role::text
   INTO v_casino_id, v_role
   FROM public.staff s
   WHERE s.id = v_staff_id
     AND s.status = 'active'
     AND s.casino_id IS NOT NULL;

   -- AFTER (GAP-4 fix):
   SELECT s.casino_id, s.role::text
   INTO v_casino_id, v_role
   FROM public.staff s
   JOIN public.casino c ON c.id = s.casino_id
   WHERE s.id = v_staff_id
     AND s.status = 'active'
     AND s.casino_id IS NOT NULL
     AND c.status = 'active';  -- GAP-4: casino must be active
   ```

   **Error message update:**
   ```sql
   -- Updated error when context derivation fails:
   RAISE EXCEPTION 'FORBIDDEN: staff not active, not casino-scoped, or casino deactivated'
     USING ERRCODE = 'P0001';
   ```

   **Preserved invariants:** INV-3 (staff bound to auth.uid()), INV-5 (SET LOCAL), INV-6 (unique user_id). Return type unchanged (TABLE).

**Patterns Applied:**
- ADR-018 SECURITY DEFINER with `SET search_path = pg_catalog, public`
- ADR-024 INV-8: no spoofable parameters
- ADR-030 D1: RETURNS TABLE preserved

**Implementation Hints:**
- GAP-4: Use CREATE OR REPLACE (safer than DROP+CREATE since return type unchanged)
- `casino_settings` INSERT: check which columns are required vs optional in schema
- Staff first_name/last_name: use `'Admin'` / `'User'` as placeholder — user updates profile later
- Casino status defaults to `'active'` — text column, no enum
- JWT claim sync (`syncUserRLSClaims`) happens at TypeScript service layer, NOT in the RPC
- Transaction safety: all 3 INSERTs in implicit transaction — any failure rolls back all
- COMMENT ON FUNCTION for documentation lineage
- Migration modifies `set_rls_context_from_staff()` → include `ADR-024` marker in header (pre-commit hook)

3. **Audit logging:**
   - Insert row into `audit_log` (or equivalent) after successful bootstrap with event_type `tenant_bootstrap`, payload `{ actor_id, casino_id, staff_id }`.
   - Ensure log write happens in same transaction for atomicity.

**Acceptance Criteria:**
- [ ] `npm run db:types` succeeds — `rpc_bootstrap_casino` appears in Database types
- [ ] `rpc_bootstrap_casino` callable by authenticated role
- [ ] Bootstrap creates casino + casino_settings + staff atomically
- [ ] Duplicate bootstrap for same `auth.uid()` returns ERRCODE 23505 conflict
- [ ] `set_rls_context_from_staff()` rejects staff at inactive casino (GAP-4)
- [ ] `set_rls_context_from_staff()` still works for staff at active casino (regression)
- [ ] Existing callers of `set_rls_context_from_staff()` unaffected (signature unchanged)
- [ ] No `p_casino_id` or `p_actor_id` parameters on `rpc_bootstrap_casino` (INV-8)
- [ ] Audit log entry recorded with actor + casino ids and new staff id
- [ ] Bootstrap staff INSERT uses `user_id = auth.uid()` where `auth.uid()` = `auth.users.id` (Option A identity model)
- [ ] `syncUserRLSClaims` called with `userId = auth.uid()` (auth.users.id), not staff.id

---

### WS3: RPC — Invite Create + Accept

**Purpose:** Create RPCs for the invite lifecycle — admin creates invite (hashed token), invitee accepts (validated + staff binding created).

**Deliverables — Single Migration File:**

1. **`rpc_create_staff_invite` (SECURITY DEFINER):**

   **Signature:**
   ```sql
   CREATE FUNCTION public.rpc_create_staff_invite(
     p_email text,
     p_role staff_role,
     p_ttl_hours integer DEFAULT NULL  -- NULL uses system default (72h)
   ) RETURNS TABLE (invite_id uuid, raw_token text, expires_at timestamptz)
   LANGUAGE plpgsql
   SECURITY DEFINER
   SET search_path = pg_catalog, public
   ```

   **Logic flow:**
   1. Call `set_rls_context_from_staff()` — injects context
   2. Validate `app.staff_role = 'admin'` — non-admins get `FORBIDDEN: admin role required`
   3. Derive `v_casino_id` from `app.casino_id`, `v_actor_id` from `app.actor_id`
   4. Generate raw bytes: `v_raw_bytes := gen_random_bytes(32)` (32 random bytes)
   5. Encode for return: `v_raw_token := encode(v_raw_bytes, 'hex')` (64-char hex string)
   6. Hash raw BYTES (not hex string): `v_token_hash := encode(digest(v_raw_bytes, 'sha256'), 'hex')`
   7. Normalize email: `lower(trim(p_email))` — matches partial index `lower(email)`
   8. Determine TTL hours: `v_ttl_hours := COALESCE(p_ttl_hours, NULLIF(current_setting('app.staff_invite_ttl_hours', true), '')::integer, 72)`
   9. INSERT into `staff_invite` (casino_id, email, staff_role, token_hash, expires_at=now()+ (v_ttl_hours || ' hours')::interval, created_by=v_actor_id)
   10. Handle unique constraint violation (active invite for same email+casino) → `CONFLICT: active invite already exists for this email` (ERRCODE 23505)
   11. INSERT audit log row `event_type='staff_invite_created'` with actor_id, casino_id, invite_id, ttl_hours
   12. RETURN invite_id, raw_token, expires_at

   **Token security:**
   - Raw token: 32 random bytes = 256 bits of entropy
   - Stored as SHA-256 hash — raw token never persisted
   - Returned exactly once in RPC response
   - TTL default = 72 hours but overrideable per RPC call or via `current_setting('app.staff_invite_ttl_hours', true)` (e.g., Supabase config/env var)

2. **`rpc_accept_staff_invite` (SECURITY DEFINER):**

   **Signature:**
   ```sql
   CREATE FUNCTION public.rpc_accept_staff_invite(
     p_token text
   ) RETURNS TABLE (staff_id uuid, casino_id uuid, staff_role text)
   LANGUAGE plpgsql
   SECURITY DEFINER
   SET search_path = pg_catalog, public
   ```

   **Logic flow:**
   1. Validate `auth.uid() IS NOT NULL` — `auth.uid()` = `auth.users.id` (per Identity Model §above)
   2. Does NOT call `set_rls_context_from_staff()` — accepting user may not have staff binding yet
   3. **Validate token format before decode:**
      ```sql
      IF p_token IS NULL OR p_token !~ '^[0-9a-f]{64}$' THEN
        RAISE EXCEPTION 'NOT_FOUND: invalid invite token'
          USING ERRCODE = 'P0002';
      END IF;
      ```
      > **Input hardening:** `decode(p_token, 'hex')` throws a raw Postgres error on non-hex input (e.g., `invalid hexadecimal data`). Without pre-validation, this leaks an internal error class to the caller instead of the clean `P0002` NOT_FOUND. Validating format first keeps UX predictable and avoids noisy error logs. The regex `^[0-9a-f]{64}$` matches exactly 64 lowercase hex chars (32 bytes encoded).
   4. Hash input token: `v_token_hash := encode(digest(decode(p_token, 'hex'), 'sha256'), 'hex')`
   5. Look up invite by `token_hash` with `SELECT ... FOR UPDATE` (prevent race conditions)
   6. Validate invite exists → else RAISE `NOT_FOUND: invalid invite token` (ERRCODE P0002)
   7. Validate `accepted_at IS NULL` → else RAISE `CONFLICT: invite already accepted` (ERRCODE 23505)
   8. Validate `expires_at > now()` → else RAISE `GONE: invite has expired` (ERRCODE P0003)
   9. Check user not already bound: `SELECT FROM staff WHERE user_id = auth.uid() AND status = 'active'` → else RAISE `CONFLICT: user already has active staff binding` (ERRCODE 23505)
   10. INSERT staff (casino_id from invite, role from invite, user_id=auth.uid(), status='active', first_name='Invited', last_name='Staff') — `user_id` is FK to `auth.users(id)`, not `staff.id`
   11. UPDATE staff_invite SET accepted_at = now() WHERE id = invite.id
   12. RETURN new staff_id, casino_id, role
   13. Insert audit log event `staff_invite_accepted` with invite + actor metadata

   > **Identity model note (Option A):** Same pattern as `rpc_bootstrap_casino`. Step 9 checks for existing binding via `staff.user_id = auth.uid()` (auth user → staff mapping). Step 10 creates the binding with `user_id = auth.uid()` (FK to `auth.users`). After success, TypeScript layer calls `syncUserRLSClaims(auth.uid(), ...)` so the new staff member gets JWT claims for subsequent requests.

   **Typed Error Codes:**
   - `P0002` — NOT_FOUND: invalid invite token
   - `23505` — CONFLICT: invite already accepted / user already has staff binding
   - `P0003` — GONE: invite has expired

   **Grants for both RPCs:**
   ```sql
   REVOKE ALL ON FUNCTION public.rpc_create_staff_invite FROM PUBLIC;
   GRANT EXECUTE ON FUNCTION public.rpc_create_staff_invite TO authenticated;
   REVOKE ALL ON FUNCTION public.rpc_accept_staff_invite FROM PUBLIC;
   GRANT EXECUTE ON FUNCTION public.rpc_accept_staff_invite TO authenticated;
   ```

**Patterns Applied:**
- ADR-018 SECURITY DEFINER governance (SET search_path = pg_catalog, public)
- ADR-024 INV-7: `rpc_create_staff_invite` calls `set_rls_context_from_staff()`
- ADR-024 INV-7 exception: `rpc_accept_staff_invite` does NOT call `set_rls_context_from_staff()`
- ADR-024 INV-8: no casino_id/actor_id parameters
- NFR-4: pgcrypto SHA-256 hashing, gen_random_bytes(32), 72h TTL

**Implementation Hints:**
- Hash raw BYTES not hex STRING: `digest(v_raw_bytes, 'sha256')` where `v_raw_bytes` is bytea
- Accept RPC: Use `SELECT ... FOR UPDATE` on invite row to prevent race conditions
- Email normalization: `lower(trim(p_email))` in create — matches partial index `lower(email)`
- Staff placeholder names: `'Invited'` / `'Staff'` — user updates profile later
- pgcrypto functions used: `gen_random_bytes()`, `digest()`, `encode()`/`decode()`
- Depends on WS1 (staff_invite table must exist) — separate migration file
- ERRCODE convention: P0002 for NOT_FOUND, P0003 for GONE (custom app codes)
- COMMENT ON FUNCTION for both RPCs with PRD-025 lineage
- Configurable TTL: store default hours in Postgres setting `app.staff_invite_ttl_hours`; use `NULLIF(..., '')::integer` to handle empty/unset config without throwing; validate positive integer before use.
- **Token format validation**: `rpc_accept_staff_invite` MUST validate `p_token ~ '^[0-9a-f]{64}$'` before calling `decode(p_token, 'hex')`. Without this, malformed input (non-hex chars, wrong length) causes `decode()` to throw a raw Postgres `invalid hexadecimal data` error instead of the clean `P0002` NOT_FOUND. Case sensitivity: accept only lowercase hex (tokens are generated via `encode(..., 'hex')` which produces lowercase).

**Acceptance Criteria:**
- [ ] `npm run db:types` succeeds — both RPCs appear in Database types
- [ ] Admin can create invite — raw token returned once, 64-char hex
- [ ] Non-admin caller gets FORBIDDEN error from `rpc_create_staff_invite`
- [ ] Accepting valid token creates staff row with correct casino_id and role
- [ ] Expired token returns typed GONE error (ERRCODE P0003)
- [ ] Already-accepted token returns typed CONFLICT error (ERRCODE 23505)
- [ ] User already bound to staff returns typed CONFLICT error (ERRCODE 23505)
- [ ] Token hash stored, raw token never persisted (verify via SELECT on staff_invite)
- [ ] Malformed token (non-hex, wrong length, NULL) returns P0002 NOT_FOUND — not a raw Postgres error
- [ ] Duplicate invite for same email+casino returns CONFLICT (partial unique index)
- [ ] No `p_casino_id` or `p_actor_id` parameters (INV-8 compliant)
- [ ] `rpc_create_staff_invite` calls `set_rls_context_from_staff()` (INV-7)
- [ ] `rpc_accept_staff_invite` does NOT call `set_rls_context_from_staff()` (INV-7 exception)
- [ ] Invite TTL configurable via RPC arg or database setting
- [ ] Audit log events recorded for create + accept flows
- [ ] Accept staff INSERT uses `user_id = auth.uid()` where `auth.uid()` = `auth.users.id` (Option A identity model)
- [ ] Accept idempotency check uses `staff.user_id = auth.uid()` (auth user → staff mapping, not staff.id)

---

### WS4: Service Layer — CasinoService Onboarding Extensions

**Purpose:** Extend existing CasinoService with TypeScript RPC wrappers, DTOs, and supporting modules.

**Deliverables — Extend Existing Files:**

1. **DTOs** (extend `services/casino/dtos.ts`):

   New base row type alias (follows existing pattern at lines 15-21):
   ```typescript
   type StaffInviteRow = Database['public']['Tables']['staff_invite']['Row'];
   ```

   Pattern B DTO (follows CasinoDTO/StaffDTO pattern):
   ```typescript
   /** Staff invite public view (excludes token_hash for security) */
   export type StaffInviteDTO = Pick<
     StaffInviteRow,
     'id' | 'casino_id' | 'email' | 'staff_role' | 'expires_at' | 'accepted_at' | 'created_at'
   >;
   ```

   RPC input/output types (manual interfaces — RPC-shaped, like GamingDayDTO):
   ```typescript
   export interface BootstrapCasinoInput {
     casino_name: string;
     timezone?: string;          // Default: 'America/Los_Angeles'
     gaming_day_start?: string;  // HH:MM format, Default: '06:00'
   }
   export interface BootstrapCasinoResult {
     casino_id: string;
     staff_id: string;
     staff_role: string;
   }
   export interface CreateInviteInput {
     email: string;
     role: Database['public']['Enums']['staff_role'];
   }
   export interface CreateInviteResult {
     invite_id: string;
     raw_token: string;
     expires_at: string;
   }
   export interface AcceptInviteInput {
     token: string;  // 64-char hex-encoded
   }
   export interface AcceptInviteResult {
     staff_id: string;
     casino_id: string;
     staff_role: string;
   }
   ```

   Note: `CreateInviteInput.role` uses the `Database` enum type directly to stay sync'd with schema. `token_hash` is never exposed in any DTO.

2. **Schemas** (extend `services/casino/schemas.ts`):

   Existing `staffRoleSchema` is `z.enum(['dealer', 'pit_boss', 'admin'])` — missing `'cashier'`. Fix: update to include `'cashier'` (matches the database enum and WS3's invite role parameter).

   New schemas (follow existing naming pattern — schemas export `Input` types via `z.infer`):
   ```typescript
   /** Bootstrap casino input (called from /bootstrap form) */
   export const bootstrapCasinoSchema = z.object({
     casino_name: z.string().min(1, 'Casino name is required').max(100),
     timezone: z.string().min(1).max(64).optional(),
     gaming_day_start: z.string()
       .regex(/^\d{2}:\d{2}$/, 'Must be HH:MM format')
       .optional(),
   });

   /** Staff invite creation input (admin-only) */
   export const createInviteSchema = z.object({
     email: z.string().email('Invalid email format'),
     role: z.enum(['dealer', 'pit_boss', 'cashier', 'admin']),
   });

   /** Invite acceptance input (token from URL) */
   export const acceptInviteSchema = z.object({
     token: z.string()
       .length(64, 'Token must be 64-character hex string')
       .regex(/^[0-9a-f]{64}$/, 'Token must be lowercase hexadecimal'),
   });
   ```

   Type exports (following existing convention at lines 262-274):
   ```typescript
   export type BootstrapCasinoInput = z.infer<typeof bootstrapCasinoSchema>;
   export type CreateInviteInput = z.infer<typeof createInviteSchema>;
   export type AcceptInviteInput = z.infer<typeof acceptInviteSchema>;
   ```

   **Note**: Schema `Input` types are for HTTP validation. DTO interfaces in `dtos.ts` are for RPC result types. Both exist — schemas validate input, DTOs type output.

3. **RPC wrappers** (extend `services/casino/crud.ts`):

   Follow existing patterns: `SupabaseClient<Database>` param, `DomainError` throws, `reconcileStaffClaims` for staff mutations.

   ```typescript
   /** Bootstrap a new casino tenant — atomic casino + settings + admin staff */
   export async function bootstrapCasino(
     supabase: SupabaseClient<Database>,
     input: BootstrapCasinoInput,
   ): Promise<BootstrapCasinoResult> {
     const { data, error } = await supabase.rpc('rpc_bootstrap_casino', {
       p_casino_name: input.casino_name,
       p_timezone: input.timezone,
       p_gaming_day_start: input.gaming_day_start,
     });
     // Handle error.code '23505' → DomainError('STAFF_ALREADY_BOUND')
     // Handle generic → DomainError('INTERNAL_ERROR')
     // After success: call reconcileStaffClaims() for the new admin staff
     // Return { casino_id, staff_id, staff_role } from RPC result
   }

   /** Create a staff invite (admin-only) */
   export async function createStaffInvite(
     supabase: SupabaseClient<Database>,
     input: CreateInviteInput,
   ): Promise<CreateInviteResult> {
     const { data, error } = await supabase.rpc('rpc_create_staff_invite', {
       p_email: input.email,
       p_role: input.role,
     });
     // Handle '23505' → DomainError('INVITE_ALREADY_EXISTS')
     // Handle 'P0001' → DomainError('FORBIDDEN')
     // Return { invite_id, raw_token, expires_at }
   }

   /** Accept a staff invite — creates staff binding */
   export async function acceptStaffInvite(
     supabase: SupabaseClient<Database>,
     input: AcceptInviteInput,
   ): Promise<AcceptInviteResult> {
     const { data, error } = await supabase.rpc('rpc_accept_staff_invite', {
       p_token: input.token,
     });
     // Handle 'P0002' → DomainError('INVITE_NOT_FOUND')
     // Handle 'P0003' → DomainError('INVITE_EXPIRED')
     // Handle '23505' → DomainError('STAFF_ALREADY_BOUND')
     // After success: call reconcileStaffClaims() for the new staff
     // Return { staff_id, casino_id, staff_role }
   }

   /** List staff invites for the current casino (admin-only, RLS-scoped) */
   export async function listStaffInvites(
     supabase: SupabaseClient<Database>,
   ): Promise<StaffInviteDTO[]> {
     const { data, error } = await supabase
       .from('staff_invite')
       .select('id, casino_id, email, staff_role, expires_at, accepted_at, created_at')
       .order('created_at', { ascending: false });
     // Return mapped StaffInviteDTO[] (identity mapping — no transformation needed)
   }
   ```

   **Critical**: `bootstrapCasino` and `acceptStaffInvite` both create new staff bindings → must call `reconcileStaffClaims()` after success to sync JWT claims (ADR-030 D2). Follow the pattern at crud.ts:353-359.

4. **Keys** (extend `services/casino/keys.ts`):

   Follow existing `.scope` pattern (lines 29-33, 52-56):
   ```typescript
   /** Staff invite queries (admin-only) */
   staffInvites: Object.assign(
     () => [...ROOT, 'staff-invites', 'list'] as const,
     { scope: [...ROOT, 'staff-invites'] as const },
   ),
   ```

5. **HTTP** (extend `services/casino/http.ts`):

   Follow existing `fetchJSON` + `IDEMPOTENCY_HEADER` pattern:
   ```typescript
   const ONBOARDING_BASE = '/api/v1/onboarding';

   /** Bootstrap a new casino tenant */
   export async function fetchBootstrapCasino(
     input: BootstrapCasinoInput,
   ): Promise<BootstrapCasinoResult> {
     return fetchJSON<BootstrapCasinoResult>(`${ONBOARDING_BASE}/bootstrap`, {
       method: 'POST',
       headers: {
         'content-type': 'application/json',
         [IDEMPOTENCY_HEADER]: generateIdempotencyKey(),
       },
       body: JSON.stringify(input),
     });
   }

   /** Create a staff invite */
   export async function fetchCreateInvite(
     input: CreateInviteInput,
   ): Promise<CreateInviteResult> {
     return fetchJSON<CreateInviteResult>(`${ONBOARDING_BASE}/invite`, {
       method: 'POST',
       headers: {
         'content-type': 'application/json',
         [IDEMPOTENCY_HEADER]: generateIdempotencyKey(),
       },
       body: JSON.stringify(input),
     });
   }

   /** Accept a staff invite */
   export async function fetchAcceptInvite(
     input: AcceptInviteInput,
   ): Promise<AcceptInviteResult> {
     return fetchJSON<AcceptInviteResult>(`${ONBOARDING_BASE}/invite/accept`, {
       method: 'POST',
       headers: {
         'content-type': 'application/json',
         [IDEMPOTENCY_HEADER]: generateIdempotencyKey(),
       },
       body: JSON.stringify(input),
     });
   }
   ```

6. **Service factory** (extend `services/casino/index.ts`):

   Extend `CasinoServiceInterface` (lines 43-133) with new method signatures:
   ```typescript
   // === Onboarding (PRD-025) ===
   bootstrapCasino(input: BootstrapCasinoInput): Promise<BootstrapCasinoResult>;
   createStaffInvite(input: CreateInviteInput): Promise<CreateInviteResult>;
   acceptStaffInvite(input: AcceptInviteInput): Promise<AcceptInviteResult>;
   listStaffInvites(): Promise<StaffInviteDTO[]>;
   ```

   Add to `createCasinoService` factory (lines 142-208):
   ```typescript
   bootstrapCasino: (input) => crud.bootstrapCasino(supabase, input),
   createStaffInvite: (input) => crud.createStaffInvite(supabase, input),
   acceptStaffInvite: (input) => crud.acceptStaffInvite(supabase, input),
   listStaffInvites: () => crud.listStaffInvites(supabase),
   ```

   Add to re-exports (lines 211-224):
   ```typescript
   export { bootstrapCasino, createStaffInvite, acceptStaffInvite, listStaffInvites } from './crud';
   ```

**Implementation Hints:**
- `staffRoleSchema` at schemas.ts:56 is missing `'cashier'` — update to `z.enum(['dealer', 'pit_boss', 'cashier', 'admin'])` for consistency with DB enum
- RPC result shape: `supabase.rpc()` returns `{ data, error }` where data is a single row for `RETURNS TABLE` with single-row return — handle via `.single()` or access `data[0]`
- DomainError codes for RPC failures: map PostgreSQL ERRCODE strings to DomainError codes (see existing pattern at crud.ts:124-128 for UNIQUE_VIOLATION). Use the canonical mapping table below.
- `reconcileStaffClaims` import already exists at crud.ts:16 — reuse for bootstrap and accept flows
- `listStaffInvites` uses table SELECT (not RPC) — RLS admin-only policy from WS1 handles access control. SELECT policy is session-var-only (Template 2b), so `listStaffInvites` MUST run within `withRLS` context (which sets session vars via `set_rls_context_from_staff()`). This is guaranteed when called through server actions or `withServerAction` compositor.
- No mapper file changes needed — StaffInviteDTO is identity-mapped (SELECT columns match DTO fields)

**Onboarding RPC Error Mapping Table:**

This table is the canonical mapping for all onboarding RPCs. Every ERRCODE must be wired in `crud.ts` — unmapped codes fall through to `DomainError('INTERNAL_ERROR')` which produces unhelpful "Something went wrong" toasts.

| RPC | PostgreSQL ERRCODE | SQL Error Message | DomainError Code | HTTP Status | User-Facing Message |
|-----|-------------------|-------------------|-----------------|-------------|---------------------|
| `rpc_bootstrap_casino` | `23505` | CONFLICT: user already has staff binding | `STAFF_ALREADY_BOUND` | 409 | "You already have an active casino." |
| `rpc_create_staff_invite` | `P0001` | FORBIDDEN: admin role required | `FORBIDDEN` | 403 | "Admin access required." |
| `rpc_create_staff_invite` | `23505` | CONFLICT: active invite already exists | `INVITE_ALREADY_EXISTS` | 409 | "An active invite already exists for this email." |
| `rpc_accept_staff_invite` | `P0002` | NOT_FOUND: invalid invite token | `INVITE_NOT_FOUND` | 404 | "This invite link is invalid." |
| `rpc_accept_staff_invite` | `P0003` | GONE: invite has expired | `INVITE_EXPIRED` | 410 | "This invite has expired." |
| `rpc_accept_staff_invite` | `23505` | CONFLICT: user already has active staff binding | `STAFF_ALREADY_BOUND` | 409 | "You already belong to a casino." |

**Consistency notes:**
- `23505` is reused for three distinct conflicts. Disambiguate by RPC name + message substring in the mapper (e.g., `error.message.includes('invite')` → `INVITE_ALREADY_EXISTS`, else → `STAFF_ALREADY_BOUND`).
- `P0001` is used project-wide for FORBIDDEN/UNAUTHORIZED (existing: `player-timeline/crud.ts:31`, `table-context/table-session.ts:200`). Keep consistent — `P0001` from onboarding RPCs means "caller lacks required role."
- `P0002` and `P0003` are new custom codes introduced by PRD-025. Document them in `DomainError` if a central error code registry exists.
- All DomainError codes above must be added to `getDefaultMessage()` and `getDefaultHttpStatus()` in `lib/errors/domain-errors.ts` if not already present.

**Patterns Applied:**
- SLAD v3.2.0 functional factory pattern (match existing createCasinoService)
- Pattern B DTOs: `StaffInviteDTO` via Pick from `Database` types
- Manual interfaces for RPC results (same exception as `GamingDayDTO`)
- ADR-013 Zod schemas with `z.infer<>` type exports
- ADR-030 D2: `reconcileStaffClaims()` after staff-creating mutations
- IDEMPOTENCY_HEADER on all POST fetchers (ADR-021)

**Acceptance Criteria:**
- [ ] `npm run type-check` passes
- [ ] `StaffInviteDTO` derived via `Pick<StaffInviteRow, ...>` from `Database` types
- [ ] RPC result interfaces are manual (like `GamingDayDTO`) — not DB-derived
- [ ] `staffRoleSchema` updated to `z.enum(['dealer', 'pit_boss', 'cashier', 'admin'])` — must match DB enum `staff_role` exactly (source of truth: `types/remote/database.types.ts` → `Database['public']['Enums']['staff_role']`). Verify no other Zod schema or UI select list hardcodes a subset.
- [ ] Zod schemas validate all RPC inputs with proper constraints
- [ ] `bootstrapCasino` and `acceptStaffInvite` call `reconcileStaffClaims` after success
- [ ] Service factory exports all 4 new methods via explicit interface
- [ ] HTTP fetchers use `IDEMPOTENCY_HEADER` on all mutations
- [ ] Query key factory uses `.scope` pattern for `staffInvites`
- [ ] No `as any`, no `console.*` in production code
- [ ] New crud functions re-exported from `index.ts` for server action use
- [ ] All PostgreSQL ERRCODEs from onboarding RPCs mapped to `DomainError` codes per error mapping table above

---

### WS5: Tests — Bootstrap + Invite + RLS

**Purpose:** Comprehensive test coverage for onboarding flows and security policies.

**Test Location:** `services/casino/__tests__/` (co-located per governance.context.md canonical pattern)

**Deliverables:**

1. **`services/casino/__tests__/bootstrap.test.ts`** — Unit tests:

   Mock strategy: mock `supabase.rpc()` responses, mock `reconcileStaffClaims`. Follow existing mock patterns in `services/casino/__tests__/crud.unit.test.ts`.

   Test scenarios:
   - `bootstrapCasino` calls `supabase.rpc('rpc_bootstrap_casino', ...)` with correct params
   - Success: returns `BootstrapCasinoResult` with casino_id, staff_id, staff_role
   - Success: calls `reconcileStaffClaims` with new staff binding data
   - Conflict (ERRCODE 23505): throws `DomainError('STAFF_ALREADY_BOUND')`
   - Generic RPC error: throws `DomainError('INTERNAL_ERROR')`
   - Input validation: `bootstrapCasinoSchema` rejects empty casino_name
   - Input validation: `bootstrapCasinoSchema` rejects casino_name > 100 chars
   - Input validation: `bootstrapCasinoSchema` rejects invalid gaming_day_start format

2. **`services/casino/__tests__/invite.test.ts`** — Unit tests:

   Mock strategy: mock `supabase.rpc()` for create/accept, mock `supabase.from('staff_invite')` for list.

   Test scenarios — `createStaffInvite`:
   - Success: returns `CreateInviteResult` with invite_id, raw_token (64-char hex), expires_at
   - Duplicate (ERRCODE 23505): throws `DomainError('INVITE_ALREADY_EXISTS')`
   - Forbidden (ERRCODE P0001): throws `DomainError('FORBIDDEN')`
   - Input validation: `createInviteSchema` rejects invalid email
   - Input validation: `createInviteSchema` accepts all 4 valid roles (dealer, pit_boss, cashier, admin)

   Test scenarios — `acceptStaffInvite`:
   - Success: returns `AcceptInviteResult` with staff_id, casino_id, staff_role
   - Success: calls `reconcileStaffClaims` with new staff binding data
   - Not found (ERRCODE P0002): throws `DomainError('INVITE_NOT_FOUND')`
   - Expired (ERRCODE P0003): throws `DomainError('INVITE_EXPIRED')`
   - Already accepted (ERRCODE 23505): throws `DomainError('STAFF_ALREADY_BOUND')`
   - Input validation: `acceptInviteSchema` rejects token != 64 chars
   - Input validation: `acceptInviteSchema` rejects non-hex characters (e.g., `'g'` or uppercase)

   Test scenarios — `listStaffInvites`:
   - Returns array of `StaffInviteDTO` (no token_hash in result)
   - Returns empty array when no invites exist
   - Results ordered by created_at descending

3. **`services/casino/__tests__/onboarding-rpc-contract.test.ts`** — RPC contract tests:

   Follow existing pattern in `services/casino/__tests__/http-contract.test.ts`. Validate that TypeScript RPC parameter types align with Database types.

   Test scenarios:
   - `rpc_bootstrap_casino` params: verify `p_casino_name: string`, `p_timezone?: string`, `p_gaming_day_start?: string`
   - `rpc_create_staff_invite` params: verify `p_email: string`, `p_role: staff_role`
   - `rpc_accept_staff_invite` params: verify `p_token: string`
   - Return type shapes match DTO interfaces (compile-time type assertions)
   - `staff_invite` table has expected columns (compile-time type assertion from Database types)

4. **`services/casino/__tests__/onboarding.int.test.ts`** — Integration tests:

   **Prerequisite:** Running Supabase instance with WS1-WS3 migrations applied.

   Test scenarios:
   - Full bootstrap flow: `rpc_bootstrap_casino` → casino + casino_settings + staff created → `set_rls_context_from_staff()` succeeds for new admin
   - Bootstrap idempotency: second bootstrap for same auth.uid() returns ERRCODE 23505
   - Full invite flow: bootstrap → create invite → accept invite (different user) → new staff binding exists
   - Casino isolation: admin from casino A cannot see invites from casino B
   - Company deny-by-default: authenticated role SELECT on company returns 0 rows
   - GAP-4 validation: deactivate casino → `set_rls_context_from_staff()` fails for staff at deactivated casino
   - Token security: accepted invite's `token_hash` column is not empty, raw token not stored

**Mocking Strategy:**
- Unit tests (`bootstrap.test.ts`, `invite.test.ts`): mock `supabase.rpc()` and `supabase.from()` responses; mock `reconcileStaffClaims` (follow crud.unit.test.ts patterns)
- RPC contract tests: compile-time type assertions (no runtime DB needed)
- Integration tests: require running Supabase instance (CI-compatible via `supabase start`)

**Implementation Hints:**
- Follow existing test structure in `services/casino/__tests__/crud.unit.test.ts` for supabase mock setup
- `reconcileStaffClaims` should be mocked via `jest.mock('@/lib/supabase/claims-reconcile')` in unit tests
- Integration tests may use the `supabase` client from `@/lib/supabase/server` with test user auth
- DomainError assertion pattern: `expect(() => ...).rejects.toThrow(DomainError)` + verify `.code` property

**Acceptance Criteria:**
- [ ] `npm test services/casino/__tests__/bootstrap.test.ts` passes
- [ ] `npm test services/casino/__tests__/invite.test.ts` passes
- [ ] `npm test services/casino/__tests__/onboarding-rpc-contract.test.ts` passes
- [ ] `npm test services/casino/__tests__/onboarding.int.test.ts` passes (when Supabase running)
- [ ] ≥80% coverage for new service layer code (per quality.context.md target)
- [ ] No `as any` in test files (use proper typing for mocks)

---

### WS6: UI — Bootstrap Wizard + Invite Screens + Accept Screen

**Purpose:** Create the onboarding UI screens for tenant bootstrap, invite management, and invite acceptance.

**Component Architecture — Server vs Client:**

| File | Type | Rationale |
|------|------|-----------|
| `app/(onboarding)/layout.tsx` | Server | Centered layout shell (no sidebar/header — onboarding is pre-dashboard) |
| `app/(onboarding)/bootstrap/page.tsx` | Server | Auth check → redirect if not authed; renders client form |
| `app/(onboarding)/bootstrap/_actions.ts` | Server action | `withServerAction` compositor wrapping `bootstrapCasino` from crud.ts |
| `app/(onboarding)/invite/manage/page.tsx` | Server | Auth + admin role check → redirect if not admin; renders client components |
| `app/(onboarding)/invite/manage/_actions.ts` | Server action | `withServerAction` compositor wrapping `createStaffInvite` from crud.ts |
| `app/(onboarding)/invite/accept/page.tsx` | Server | Auth check → redirect to `/signin` with return URL; passes token to client component |
| `app/(onboarding)/invite/accept/_actions.ts` | Server action | `withServerAction` compositor wrapping `acceptStaffInvite` from crud.ts |
| `components/onboarding/bootstrap-form.tsx` | Client | `useActionState` form (casino name, timezone, gaming day start) |
| `components/onboarding/invite-form.tsx` | Client | `useMutation` form (email + role), displays generated invite link |
| `components/onboarding/invite-list.tsx` | Client | `useQuery` with `casinoKeys.staffInvites()`, renders invite table |
| `components/onboarding/accept-invite-handler.tsx` | Client | `useMutation` auto-triggered on mount, handles redirect/errors |
| `hooks/casino/use-onboarding-mutations.ts` | Client hook | `useBootstrapCasino`, `useCreateInvite`, `useAcceptInvite` |

**Deliverables:**

1. **Onboarding Layout** (`app/(onboarding)/layout.tsx` — **already exists from PRD-024 WS3**):
   - Centered container, no sidebar/header (pre-dashboard context)
   - Existing implementation: `min-h-screen flex items-center justify-center bg-background` + `w-full max-w-lg p-6` wrapper
   - PRD-025 may extend but does NOT need to recreate this layout — it already exists at the correct path

2. **Bootstrap Wizard** (`app/(onboarding)/bootstrap/page.tsx` + `_actions.ts` + `bootstrap-form.tsx`):

  **Page (server):** Auth check via `createClient()` + `getUser()`. No user → redirect to `/signin?redirect=/bootstrap`. User with existing staff claims (casinoId in `app_metadata`) → redirect to `/start` so the gateway decides the next page. Otherwise render `<BootstrapForm />`.

   > **Route note (PRD-024 alignment):** The file path `app/(onboarding)/bootstrap/page.tsx` maps to URL `/bootstrap` — Next.js route groups like `(onboarding)` do NOT add a URL segment. PRD-024's gateway at `app/(public)/start/page.tsx` line 360 redirects to `'/bootstrap'` for authenticated users with no staff binding. All redirect targets in PRD-025 must use `/bootstrap`, `/invite/manage`, `/invite/accept` (not `/app/bootstrap`, `/app/invite/...`).

   **Server action (`_actions.ts`):** `'use server'`. Uses `withServerAction` compositor with `skipRlsContext: true` — user is authenticated but has no staff binding, so RLS context derivation will fail. The RPC is `SECURITY DEFINER` and validates `auth.uid()` internally (INV-7 exception, documented in WS2). Domain: `'casino'`, action: `'bootstrap'`. Validates input with `bootstrapCasinoSchema`. Returns `ServiceResult<BootstrapCasinoResult>`.

   **Client form (`bootstrap-form.tsx`):** `'use client'`. Uses `useActionState` (React 19) with bootstrap server action. Form fields:
   - Casino name — `Input` (required, min 1, max 100)
   - Timezone — `Select` with common IANA zones (America/Los_Angeles, America/New_York, America/Chicago, etc.)
   - Gaming day start — `Input` type="time" (default `06:00`)
   - States: idle → pending (button disabled) → success (Card with CTA) | error (inline messages)

3. **Invite Management** (`app/(onboarding)/invite/manage/page.tsx` + `_actions.ts` + `invite-form.tsx` + `invite-list.tsx`):

  **Page (server):** Auth + admin role check. Non-admin → redirect to `/start` with toast so the gateway can route appropriately. Renders `<InviteForm />` + `<InviteList />`.

   **Server action (`_actions.ts`):** `'use server'`. Uses `withServerAction` compositor (standard auth — admin has staff binding). Validates with `createInviteSchema`. Domain: `'casino'`, action: `'invite.create'`. Returns `ServiceResult<CreateInviteResult>`.

   **Invite form (`invite-form.tsx`):** `'use client'`. Uses `useMutation` from TanStack Query (NOT `useActionState` — needs to show generated link + compose with query cache). Fields:
   - Email — `Input` type="email"
   - Role — `Select` with options: dealer, pit_boss, cashier, admin
   - On success: renders generated invite URL in readonly `Input` with copy-to-clipboard `Button`. Uses `navigator.clipboard.writeText()`. Shows `toast.success` from sonner.
   - On error: `toast.error` with typed messages (INVITE_ALREADY_EXISTS, FORBIDDEN)
   - After creation: invalidates `casinoKeys.staffInvites.scope` via queryClient

   **Invite list (`invite-list.tsx`):** `'use client'`. Uses `useQuery` with `casinoKeys.staffInvites()` key. Renders table of invites with columns: email, role, status, created_at. Status derived from data:
   - `accepted_at` not null → `Badge` variant="default" (green) "Accepted"
   - `expires_at < now()` → `Badge` variant="destructive" (red) "Expired"
   - else → `Badge` variant="outline" (amber) "Pending"

4. **Accept Invite** (`app/(onboarding)/invite/accept/page.tsx` + `_actions.ts` + `accept-invite-handler.tsx`):

   **Page (server):** Auth check. No user → redirect to `/signin?redirect=/invite/accept?token=XXX` (preserves token). Reads `token` from `searchParams`. Renders `<AcceptInviteHandler token={token} />`.

   **Server action (`_actions.ts`):** `'use server'`. Uses `withServerAction` with `skipRlsContext: true` — accepting user has no staff binding yet (INV-7 exception, documented in WS3). Validates with `acceptInviteSchema`. Domain: `'casino'`, action: `'invite.accept'`. Returns `ServiceResult<AcceptInviteResult>`.

   **Accept handler (`accept-invite-handler.tsx`):** `'use client'`. Receives `token` prop. Uses `useMutation` wrapping `fetchAcceptInvite`. Auto-triggers on mount via `useEffect`. States:
   - Loading: Card with spinner text "Accepting invite..."
  - Success: `router.push('/start')` (leverages gateway; fallback to `/pit` only if `/start` route absent)
  - Error — typed states with distinct Card messaging:
    - `INVITE_NOT_FOUND` (P0002): "This invite link is invalid. Please request a new one."
    - `INVITE_EXPIRED` (P0003): "This invite has expired. Please ask your admin for a new link."
    - `STAFF_ALREADY_BOUND` (23505): "You already belong to a casino." → auto-redirect to /start

5. **Mutation Hooks** (`hooks/casino/use-onboarding-mutations.ts`):
   - `useBootstrapCasino()` — `useMutation` wrapping `fetchBootstrapCasino`. No cache invalidation (first action, no prior cache).
   - `useCreateInvite()` — `useMutation` wrapping `fetchCreateInvite`. On success: `queryClient.invalidateQueries({ queryKey: casinoKeys.staffInvites.scope })`.
   - `useAcceptInvite()` — `useMutation` wrapping `fetchAcceptInvite`. No cache invalidation (redirect away on success).

**State Management:**
- Bootstrap form: `useActionState` (React 19) — `[ServiceResult | null, formAction, isPending]`
- Invite creation: `useMutation` + `useState<string | null>` for generated link
- Invite list: `useQuery` with `casinoKeys.staffInvites()` key, auto-refreshed via cache invalidation
- Accept flow: `useMutation` auto-triggered via `useEffect` — mutation state covers loading/success/error

**Error Handling:**

| Flow | Error Code | User Message | Action |
|------|-----------|-------------|--------|
| Bootstrap | STAFF_ALREADY_BOUND (23505) | "You already have an active casino." | Auto-redirect to /start (gateway) |
| Bootstrap | VALIDATION_ERROR | Inline field errors from `ServiceResult.details` | Show under fields |
| Bootstrap | INTERNAL_ERROR | "Something went wrong. Please try again." | `toast.error` |
| Invite create | INVITE_ALREADY_EXISTS (23505) | "An active invite already exists for this email." | `toast.error` |
| Invite create | FORBIDDEN (P0001) | "Admin access required." | `toast.error` + redirect |
| Accept | INVITE_NOT_FOUND (P0002) | "This invite link is invalid." | Error Card |
| Accept | INVITE_EXPIRED (P0003) | "This invite has expired." | Error Card |
| Accept | STAFF_ALREADY_BOUND (23505) | "You already belong to a casino." | Auto-redirect to /start (gateway) |

**Auth Guards:**
- Bootstrap: server-side `getUser()` — no user → redirect to `/signin?redirect=/bootstrap`. User with staff claims → /start redirect.
- Invite manage: server-side `getUser()` + `app_metadata.staff_role === 'admin'` check — non-admin → /start redirect.
- Accept: server-side `getUser()` — no user → redirect to `/signin?redirect=/invite/accept?token=XXX` (preserving token param).

**Server Action RLS Context Notes:**
- Bootstrap and accept actions use `skipRlsContext: true` in `withServerAction` options — both target users without staff bindings. The RPCs are `SECURITY DEFINER` and validate `auth.uid()` internally. ADR-030 INV-030-3 structured warning logged per compositor.ts:109.
- Invite create action uses standard auth flow (admin has staff binding → `withRLS` succeeds).

**Patterns Applied:**
- `withServerAction` middleware compositor (matching `app/actions/table-context/*.ts`)
- `ServiceResult<T>` return type from server actions
- `useMutation` + `queryClient.invalidateQueries` (matching `hooks/player/use-player-mutations.ts`)
- `casinoKeys` key factory from `services/casino/keys.ts`
- `useAuth` hook for client-side auth/role checks
- shadcn/ui components: Card, Input, Select, Button, Badge, Label
- `toast` from sonner for mutation feedback
- `createClient()` from `@/lib/supabase/server` for server-side auth

**YAGNI Notes:**
- No wizard stepper — single-page form
- No complex state machine — `useActionState`/`useMutation` covers all states
- No real-time subscription for invite list — cache invalidation sufficient for v0.1
- No email preview/template — raw link with copy button
- No animated transitions — shadcn Card with conditional rendering

**External Dependency:**
- PRD-024 Phase 1B provides `(onboarding)` route group and `/start` gateway
- PRD-024 WS2 middleware public paths must be extended to include `/invite/manage` and `/invite/accept` (currently only includes `/bootstrap` and `/setup`). These pages perform internal auth checks — middleware must let them through.
- If PRD-024 not yet implemented: pages function standalone via direct navigation
- Route files created assuming route group will exist
- **Canonical auth route:** `/signin` (PRD-024 WS3 `app/(marketing)/signin/page.tsx`). All auth redirects in PRD-025 use `/signin`, NOT `(public)/auth/login`.

**Acceptance Criteria:**
- [ ] `npm run type-check` passes
- [ ] Onboarding layout renders centered, no sidebar/header
- [ ] Bootstrap form submits via server action and handles success/error states
- [ ] Bootstrap success shows confirmation Card with CTA
- [ ] Bootstrap conflict (already has staff) shows message and redirects to /start
- [ ] Invite form creates invite and displays copyable link
- [ ] Copy-to-clipboard works for invite link
- [ ] Invite list shows existing invites with correct status Badges (pending/accepted/expired)
- [ ] Accept page reads token from URL searchParams
- [ ] Accept page handles all 3 error types with distinct Card messaging
- [ ] Accept success redirects to /start
- [ ] Auth guards redirect unauthenticated users to `/signin` with return URL (NOT `/auth/login`)
- [ ] Redirect return URLs use `/bootstrap`, `/invite/accept` (NOT `/app/bootstrap`, `/app/invite/...`)
- [ ] Admin guard on invite/manage redirects non-admins
- [ ] Bootstrap and accept server actions use `skipRlsContext: true` (documented INV-7 exceptions)
- [ ] No `as any`, no `console.*` in production code
- [ ] All pages render without hydration errors (server/client boundary correct)

---

## Definition of Done (PRD-025)

### Functionality
- [ ] `rpc_bootstrap_casino` creates casino + casino_settings + staff admin atomically
- [ ] `rpc_bootstrap_casino` returns typed conflict if user already has staff binding
- [ ] `staff_invite` table exists with RLS policies (admin-only, casino-scoped)
- [ ] `rpc_create_staff_invite` creates invite with hashed token; returns raw token once
- [ ] `rpc_accept_staff_invite` validates token, creates staff binding, stamps `accepted_at`
- [ ] Expired/already-accepted tokens rejected with typed errors
- [ ] Bootstrap UI wizard creates tenant and routes to app
- [ ] Invite UI allows admin to create invite and displays link
- [ ] Accept UI processes token and completes staff binding

### Data & Integrity
- [ ] Bootstrap transaction is fully atomic
- [ ] Token never stored in plaintext; only `token_hash` persisted
- [ ] `token_hash` column not readable by `authenticated` role (column-level REVOKE)
- [ ] Bootstrap creates `casino_settings` row with defaults
- [ ] Malformed invite tokens produce clean `P0002` error, not raw Postgres exceptions

### Security & Access
- [ ] Company table has RLS enabled with deny-by-default
- [ ] `set_rls_context_from_staff()` validates `casino.status = 'active'` (GAP-4)
- [ ] `staff_invite` RLS: admin-only SELECT/INSERT/UPDATE within casino scope, all Template 2b session-var-only (no JWT fallback — PII tightening)
- [ ] All new RPCs are SECURITY DEFINER with `SET search_path = pg_catalog, public`
- [ ] No client-callable RPC accepts `casino_id` or `actor_id` as user input (INV-8)
- [ ] Identity model is Option A throughout: `auth.uid()` = `auth.users.id`, `staff.user_id` FK → `auth.users(id)`, `staff.id` = actor_id

### Testing
- [ ] Unit tests: bootstrap idempotency + invite lifecycle
- [ ] RPC contract tests: parameter/return type validation
- [ ] Integration test: full bootstrap → invite → accept → context derivation
- [ ] RLS test: casino isolation + company deny-by-default

### Operational Readiness
- [ ] `npm run db:types` regenerated after all migrations
- [ ] `npm run type-check`, `npm run lint`, `npm run test` pass
