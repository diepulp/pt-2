---
# EXECUTION-SPEC Frontmatter
# Generated by prd-pipeline skill with lead-architect + domain expert consultation

prd: GAP-SIGN-OUT
prd_title: "Sign-Out & Lock Screen Implementation"
service: CasinoService (Foundational) — staff PIN + rate-limit tables; UI/actions are application-layer
mvp_phase: 1
source_document: docs/issues/gaps/GAP-SIGN-OUT-IMPLEMENTATION.md

workstreams:
  WS1:
    name: Sign-Out Server Action
    description: >
      Server action using withServerAction compositor. Auth middleware chain
      identifies the user for observability. Handler emits structured log event
      (auth.sign_out) with actor/casino context via emitTelemetry(), returns
      ServiceResult for client-side cleanup. Does NOT clear app_metadata claims
      — see Claims Model. Failure semantics: server action is soft-fail (client
      sign-out proceeds regardless).
    executor: backend-service-builder
    executor_type: skill
    depends_on: []
    outputs:
      - app/actions/auth/sign-out.ts
    gate: type-check
    estimated_complexity: low

  WS2:
    name: NavUser Auth Wiring & Sign-Out UI
    description: >
      Wire NavUser to useAuth() hook (replace hardcoded mock data).
      Add functional "Sign out" calling WS1 action + client cleanup.
      Add stubbed "Lock screen" item. Update LogoutButton to share flow.
      Extract shared useSignOut() hook for reuse with failure semantics
      (soft-fail server action, hard-fail client signOut).
    executor: frontend-design-pt-2
    executor_type: skill
    depends_on: [WS1]
    outputs:
      - components/layout/nav-user.tsx
      - components/logout-button.tsx
      - hooks/auth/use-sign-out.ts
    gate: type-check
    estimated_complexity: medium

  WS3:
    name: Phase 1 Tests (Sign-Out)
    description: >
      Unit tests for sign-out server action and NavUser component.
      Server action tests: mock Supabase client, verify structured log emission.
      Component tests: auth data rendering, sign-out handler, loading state.
      Executor includes React Testing Library/Jest component test ownership for this repo.
    executor: backend-service-builder
    executor_type: skill
    depends_on: [WS1, WS2]
    outputs:
      - app/actions/auth/__tests__/sign-out.test.ts
      - components/layout/__tests__/nav-user.test.tsx
    gate: test-pass
    estimated_complexity: medium

  WS4:
    name: Staff PIN Schema + Rate Limit Table Migration
    description: >
      ALTER TABLE staff ADD COLUMN pin_hash text NULL.
      Nullable = PIN not yet set, triggers setup flow on first lock.
      Add staff_pin_attempts table for DB-backed rate limiting (replaces
      in-memory which is unsuitable for serverless). Add RLS self-update
      policy for staff pin_hash. Add atomic increment RPC.
    executor: backend-service-builder
    executor_type: skill
    depends_on: []
    outputs:
      - supabase/migrations/YYYYMMDDHHMMSS_add_staff_pin_hash.sql
      - supabase/migrations/YYYYMMDDHHMMSS_add_staff_pin_attempts.sql
      - supabase/migrations/YYYYMMDDHHMMSS_add_staff_pin_rls_policy.sql
    gate: schema-validation
    estimated_complexity: medium

  WS5:
    name: PIN Set/Verify Server Actions
    description: >
      setPinAction: validate 4-6 digit PIN (Zod + denylist), bcrypt hash,
      update staff.pin_hash via authed+RLS (no service-role).
      verifyPinAction: bcrypt compare, DB-backed per-staff rate limiting
      via staff_pin_attempts table (max 5 attempts/15min),
      RATE_LIMIT_EXCEEDED triggers UI-initiated sign-out (client-side session cleanup).
      Shared Zod schema with denylist in schemas.ts.
      Both actions use authed client (ADR-030 D4 compliant).
    executor: backend-service-builder
    executor_type: skill
    depends_on: [WS4]
    outputs:
      - app/actions/auth/set-pin.ts
      - app/actions/auth/verify-pin.ts
      - app/actions/auth/get-pin-status.ts
      - app/actions/auth/schemas.ts
    gate: type-check
    estimated_complexity: medium

  WS6:
    name: Lock Screen UI (Overlay + Idle Detection + Store)
    description: >
      LockScreen overlay (fixed inset-0, z-index from Z.LOCK_SCREEN constant, non-dismissible, backdrop-blur).
      useIdleDetection hook (configurable timeout, throttled activity tracking).
      Zustand useLockStore in store/lock-store.ts (isLocked, lockReason).
      Selector hook in hooks/ui/use-lock-screen.ts.
      NavUser "Lock screen" item enabled, idle detection wired.
      "Not you? Sign out" escape hatch on lock screen.
      Rendered in app/(dashboard)/layout.tsx after main content.
    executor: frontend-design-pt-2
    executor_type: skill
    depends_on: [WS1, WS5]
    outputs:
      - components/layout/lock-screen.tsx
      - hooks/use-idle-detection.ts
      - store/lock-store.ts
      - hooks/ui/use-lock-screen.ts
      - components/layout/nav-user.tsx
    gate: type-check
    estimated_complexity: high

  WS7:
    name: Phase 2 Tests (Lock Screen + PIN)
    description: >
      PIN server action tests (set, verify, rate-limit, denylist).
      LockScreen component tests (overlay render, PIN input, unlock, sign-out escape).
      useIdleDetection hook tests (timer, activity reset, throttle).
      useLockStore tests (state transitions).
      Integration smoke test: lock -> wrong PIN 5x -> UI-initiated sign-out.
      Executor includes React Testing Library/Jest component test ownership for this repo.
    executor: backend-service-builder
    executor_type: skill
    depends_on: [WS5, WS6]
    outputs:
      - app/actions/auth/__tests__/set-pin.test.ts
      - app/actions/auth/__tests__/verify-pin.test.ts
      - components/layout/__tests__/lock-screen.test.tsx
      - components/layout/__tests__/lock-screen.integration.test.tsx
      - hooks/__tests__/use-idle-detection.test.ts
      - store/__tests__/lock-store.test.ts
    gate: test-pass
    estimated_complexity: medium

execution_phases:
  - name: "Phase 1 - Sign-Out Foundation"
    parallel: [WS1]
    gates: [type-check]

  - name: "Phase 2 - Sign-Out UI + Phase 1 Tests"
    parallel: [WS2, WS3]
    gates: [type-check, test-pass]

  - name: "Phase 3 - Lock Screen Schema + Rate Limit Table"
    parallel: [WS4]
    gates: [schema-validation]

  - name: "Phase 4 - PIN Server Actions"
    parallel: [WS5]
    gates: [type-check]

  - name: "Phase 5 - Lock Screen UI + Phase 2 Tests"
    parallel: [WS6, WS7]
    gates: [type-check, test-pass, build]

gates:
  schema-validation:
    command: "npm run db:types && npm test -- --passWithNoTests schema-verification"
    success_criteria: "Exit code 0, types regenerated, schema verification passes"

  type-check:
    command: "npm run type-check"
    success_criteria: "Exit code 0, no type errors"

  lint:
    command: "npm run lint -- --max-warnings=0"
    success_criteria: "Exit code 0, zero warnings"

  test-pass:
    command: "npm test -- --passWithNoTests"
    success_criteria: "All tests pass"

  build:
    command: "npm run build"
    success_criteria: "Exit code 0, no build errors"

external_dependencies:
  - prd: ADR-030
    service: Auth Pipeline
    required_for: "Claims lifecycle rules, reconcileStaffClaims patterns, D4 write-path session vars"
  - prd: ADR-024
    service: RLS Context
    required_for: "Authoritative context derivation (no spoofable params)"
  - prd: ADR-015
    service: RLS Connection Pooling
    required_for: "Pattern C hybrid COALESCE(session_var, jwt_claim)"

risks:
  - risk: "bcryptjs not in package.json"
    mitigation: "Add bcryptjs + @types/bcryptjs as dependency in WS5. Must use bcryptjs (pure JS), NOT native bcrypt — server actions run on Node runtime (AsyncLocalStorage dependency) but bcryptjs ensures no native compilation issues across environments."
  - risk: "staff table UPDATE policy is admin-only; WS5 needs self-update"
    mitigation: "WS4 adds staff_update_own_pin RLS policy (Template 2b) + column-level privilege hardening (REVOKE UPDATE + GRANT UPDATE (pin_hash) only)"
  - risk: "useAuth() may not expose user email directly"
    mitigation: "user.email available from Supabase User object; staffRole from app_metadata"
  - risk: "PIN denylist is hardcoded, not casino-configurable"
    mitigation: "Acceptable for MVP; future enhancement can move to security_policies table"
  - risk: "rpc_increment_pin_attempt accepts spoofable casino_id/staff_id params"
    mitigation: "Rewritten to derive identity from set_rls_context_from_staff() per ADR-024 INV-7/INV-8. No caller-supplied identity params."
  - risk: "Client-side telemetry events (lock/unlock) are spoofable"
    mitigation: "Events classified as audit-grade (server) vs ux-grade (client). Only server-emitted events are trusted for compliance."
  - risk: "'Force sign-out' on rate-limit is client-initiated, not server-revoked"
    mitigation: "Renamed to 'UI-initiated sign-out'. Supabase access tokens remain valid until exp (3600s). Acceptable for MVP — lock screen is workflow gating, not cryptographic boundary."

---

> **Canonical Spec Notice**
> This document is the **single source of truth** for the Sign-out + Lock Screen gap closure.
> Any prior or copied variants containing the following patterns are **obsolete and must not be implemented**:
> - "call `verifyPinAction` with an empty PIN to detect setup mode"
> - "clear `staff_pin_attempts` via raw `DELETE` from TypeScript"
> - "emit `auth.lock_screen.*` telemetry from `lock-store.ts`"
> - "LockScreen uses `z-[100]` based on a one-time portal z-index audit"

# EXECUTION-SPEC: GAP-SIGN-OUT — Sign-Out & Lock Screen Implementation

## Overview

The PT-2 dashboard has neither functional sign-out nor a lock screen. The NavUser component renders a non-functional "Log out" dropdown item with hardcoded mock user data. A `LogoutButton` exists but performs client-only sign-out without server-side observability.

This spec implements both capabilities in two sequential shipping phases:
- **Phase 1 (Sign-Out)**: Server action (observability) + NavUser wiring + client cleanup
- **Phase 2 (Lock Screen)**: PIN schema + overlay + idle detection + Zustand store

## Claims Model

PT-2 has **two authorization layers**. Understanding their lifecycle is critical to this spec.

### Authorization Layers

| Layer | Storage | Lifecycle | Source of Truth | Updated When |
|-------|---------|-----------|-----------------|-------------|
| **JWT claims** (`app_metadata`) | `auth.users.raw_app_meta_data` | **Stable** — persists across sessions | `staff` table | Staff CREATE, UPDATE via `reconcileStaffClaims()` |
| **Session vars** (`SET LOCAL`) | Postgres connection | **Ephemeral** — per request/transaction | `set_rls_context_from_staff()` RPC | Every authenticated request via `withServerAction`/`withRLS` middleware |

### Claim Inventory

| Claim | `app_metadata` key | Session var | Classification | DB source |
|-------|--------------------|-------------|----------------|-----------|
| Casino ID | `casino_id` | `app.casino_id` | **Stable identity** | `staff.casino_id` |
| Staff role | `staff_role` | `app.staff_role` | **Stable identity** | `staff.role` |
| Staff ID | `staff_id` | `app.actor_id` | **Stable identity** | `staff.id` |

### Why Claims Live in `app_metadata`

- **RLS Pattern C fallback**: `COALESCE(session_var, jwt_claim)` — JWT claims provide authorization when the RPC hasn't run yet (e.g., direct PostgREST queries, connection pool reuse)
- **Connection pooling (ADR-015)**: JWT claims survive connection reuse; session vars are connection-scoped
- **Performance**: Avoids staff table lookup on every SELECT when RPC context injection hasn't occurred

### Claim Sync Triggers (via `reconcileStaffClaims()`)

| Event | Action | Function |
|-------|--------|----------|
| Staff created with `user_id` | Sync claims | `syncUserRLSClaims()` |
| Staff role changed | Re-sync claims | `syncUserRLSClaims()` |
| Staff casino changed | Clear old + sync new | `clearUserRLSClaims()` → `syncUserRLSClaims()` |
| Staff deactivated | Clear claims | `clearUserRLSClaims()` |
| Staff `user_id` removed | Clear claims | `clearUserRLSClaims()` |

### Claims Are NOT Cleared on Sign-Out

**Design decision**: Sign-out does **not** call `clearUserRLSClaims()`.

**Rationale**: `app_metadata` claims are stable identity attributes, not ephemeral session data. A pit boss at Casino A is still a pit boss at Casino A when they sign back in. Clearing claims on sign-out would:

1. **Break the next sign-in**: JWT arrives with null claims → Pattern C's `COALESCE(session_var, jwt_claim)` returns null → all casino-scoped queries return empty results → dashboard appears empty until the first RPC runs
2. **Create a race condition**: Quick re-sign-in operates with null claims before any sync mechanism triggers
3. **Add no security value**: The claims describe the user's real identity; clearing them doesn't revoke access (session termination does that)

**Gap doc G2 reclassification**: The original gap doc identified "stale JWT claims after sign-out" as a medium-severity risk. This is reclassified as **by design** — claims ARE the user's current identity. Staleness is only possible after a staff mutation, which already triggers `reconcileStaffClaims()` at mutation time.

### What Sign-Out Actually Needs

| Concern | Handled By | Notes |
|---------|-----------|-------|
| Session termination | `supabase.auth.signOut()` (client) | Clears browser cookies/tokens, invalidates refresh token |
| Cache purge | `queryClient.clear()` (client) | Prevents stale data on next sign-in by different user |
| Observability | Server action (WS1) | Structured log: who signed out, when, from which casino |
| Claims | **Nothing** | Stable identity — persists for next sign-in |

## Scope

**In Scope:**
- Server action for sign-out with structured observability logging
- NavUser wired to `useAuth()` with real user data
- Lock screen overlay with PIN re-authentication
- Idle detection hook with configurable timeout and throttled activity tracking
- Zustand lock state store
- DB-backed PIN rate limiting (staff_pin_attempts table)
- PIN denylist for common weak PINs
- Unit, component, and integration smoke tests for all new artifacts

**Out of Scope:**
- MFA/TOTP integration (disabled in supabase config)
- Session inactivity timeout at Supabase level (commented out in config.toml)
- Browser visibility change lock trigger (deferred — documented decision, not forgotten)
- Clearing `app_metadata` claims on sign-out (see Claims Model — by design)
- Self-service "forgot PIN" flow (admin manual reset only in MVP)
- Mandatory PIN rotation (no rotation policy in MVP)
- Cross-tab lock state synchronization (lock is per-tab). Recommended ops posture: single active tab/session per staff workstation.

## Security Posture

### Lock Screen Security Model

The lock screen is a **workflow gating mechanism**, not a cryptographic re-authentication boundary.

| What it IS | What it is NOT |
|-----------|----------------|
| Physical floor access control | Cryptographic re-auth |
| Prevents casual UI access during idle | API-level request blocking |
| Audit trail marker (locked/unlocked events) | Tamper-proof system boundary |
| Workflow interruption for shift handoff | Cross-tab session invalidation |

**Session validity**: The Supabase auth token remains valid while locked. Background token refresh continues. API calls from devtools or background tabs remain authorized.

**Acceptable for**: Casino floor operations where physical access control supplements software lock. A determined attacker with devtools access is outside the threat model for MVP.

**Future phase considerations** (out of scope):
- Step-up auth / short-lived re-auth tokens
- API-level lock enforcement (reject requests while locked)
- Browser tab visibility change triggers
- Biometric/hardware key integration

### Rate-Limit Sign-Out: Capability vs Limitation

When PIN rate limit is exceeded, the system triggers the standard client-initiated sign-out flow (`signOutAction` → `supabase.auth.signOut()` → cache clear → redirect). This is **NOT** server-side session revocation.

| What it does | What it does NOT do |
|-------------|---------------------|
| Revokes refresh tokens via Supabase Auth API (`global` scope, default) | Immediately invalidate the current access token (JWT) |
| Clears browser cookies and local storage | Prevent API calls using a previously-copied JWT |
| Purges TanStack Query cache | Revoke sessions on other devices if client call fails |
| Redirects to `/signin` | Use `auth.admin.signOut()` for server-authoritative revocation |

**JWT window exposure**: Access tokens remain valid until `exp` claim (currently `jwt_expiry = 3600` in `supabase/config.toml`; verify current value there — this spec does not hardcode it as immutable). A determined attacker who copies the JWT before rate-limit can make API calls for the duration of the JWT expiry window.

**Acceptable for MVP**: The lock screen threat model explicitly excludes determined attackers with devtools access. The PIN rate-limit escalation to sign-out is a UX safety net, not a cryptographic revocation boundary.

**Future hardening** (out of scope):
- Server-side session revocation via `auth.admin.signOut()` (requires service-role client in sign-out path)
- Reduced `jwt_expiry` (tradeoff: more frequent token refreshes for all users)
- Token denylist / short-lived access tokens

## Architecture Context

### Bounded Context Ownership (SRM v4.11.1)

| Artifact | Owner | Rationale |
|----------|-------|-----------|
| `staff` table (pin_hash column) | CasinoService | SRM: CasinoService owns staff table |
| `staff_pin_attempts` table | CasinoService | Operational rate-limit state for staff PIN — follows `audit_log` precedent (cross-cutting operational data owned by foundational context). Both FKs (`staff_id`, `casino_id`) reference CasinoService tables. |
| Server actions (`app/actions/auth/`) | Application layer (not a bounded context) | Code organization ≠ data ownership. Actions operate on CasinoService-owned tables via RLS. Same pattern as `app/actions/table-context/` → TableContextService. |
| NavUser, LockScreen components | Layout (UI) | `components/layout/` |
| Lock store, idle detection hook | UI state | `store/`, `hooks/` |

### Key ADR References

- **ADR-024**: No spoofable parameters — user identity derived from RLS context
- **ADR-030 D2**: Claims lifecycle — sync/clear on staff mutations; sign-out is NOT a clear trigger
- **ADR-030 D4**: Critical table writes use session vars only (staff is critical table)
- **ADR-015**: Pattern C hybrid — `COALESCE(session_var, jwt_claim)` depends on stable `app_metadata`
- **ADR-003**: Zustand for client-side UI state

### Sign-Out Flow Architecture

```
Client: User clicks "Sign out" in NavUser dropdown
  → Client calls signOutAction() server action
    → Server: withServerAction compositor runs auth + RLS middleware
    → Server: emits auth.sign_out.started via emitTelemetry()
    → Server: emits auth.sign_out.completed (or .failed) via emitTelemetry()
    → Server: returns ServiceResult<void>
  → Client: supabase.auth.signOut() (clears browser session/cookies)
  → Client: queryClient.clear() (purge TanStack Query cache)
  → Client: router.push('/signin') (redirect)
  → Claims in app_metadata: UNCHANGED (stable identity, persists for next sign-in)
```

### Sign-Out Failure Semantics

The sign-out flow has **four sequential steps**. Each has defined failure behavior:

| Step | Operation | Failure Type | Action on Failure |
|------|-----------|-------------|-------------------|
| 1 | `signOutAction()` server action | **Soft fail** | Log warning, show toast, proceed to step 2 |
| 2 | `supabase.auth.signOut()` client | **Hard fail** | Show error modal with Retry / Local Cleanup options. Do NOT redirect. |
| 3 | `queryClient.clear()` | **Soft fail** | Log error, proceed to step 4 |
| 4 | `router.push('/signin')` | **Soft fail** | Fallback to `window.location.href = '/signin'` after 500ms |

**Definitions:**
- **Hard fail**: Blocks the sign-out flow. User stays on current page. Must not proceed to later steps.
- **Soft fail**: Does not block. Proceed to next step. Surface warning/toast but complete the flow.

**Key principle**: Server action failures (step 1) never block client-side session termination (step 2). The server action exists for observability only. The client-side `supabase.auth.signOut()` is the only step that is non-negotiable and hard-fail.

**"Local Cleanup" (formerly "Force Clear") definition:**
When `supabase.auth.signOut()` fails (network error, Supabase outage), the user can choose "Clear local session" which performs client-only cleanup without contacting the auth server:

1. Calls `supabase.auth.signOut({ scope: 'local' })` — clears local cookies/storage only, does NOT revoke server-side refresh token. This call does not fail on network errors because it performs no HTTP request.
2. Calls `cleanupClientInstance()` exported from `lib/supabase/client.ts` (stable path; do not reference line numbers) — nulls the cached `browserInstance` singleton so the next page load creates a fresh SupabaseClient instance.
3. Calls `queryClient.clear()` — purges TanStack Query cache.
4. Redirects to `/signin` via `router.push()` with `window.location.href` fallback.
5. Shows a dismissible banner on `/signin`: "Your session may still be active on the server. For security, close this browser tab if you are on a shared device."

**What it does NOT do:**
- Revoke refresh tokens on the Supabase Auth server (session may remain active server-side until natural expiry)
- Emit server-side telemetry (the server action already soft-failed or was skipped)

This is a degraded sign-out — the refresh token remains valid server-side until it expires. Acceptable for MVP because the lock screen is a workflow gate, not a cryptographic boundary (see Security Posture).

**Error modal UX:**
```
┌──────────────────────────────────────────────┐
│  Sign-out failed                             │
│                                              │
│  Could not reach the authentication server.  │
│  Your local session will remain active       │
│  server-side until it expires.               │
│                                              │
│  [Retry]              [Clear local session]  │
└──────────────────────────────────────────────┘
```

**Naming**: User-facing label is "Clear local session" (not "Force Clear") to accurately describe the action in non-technical terms.

**Server action failure scenarios:**
- `UNAUTHORIZED` (user not authenticated) → Soft fail: user is already effectively logged out
- `FORBIDDEN` (staff inactive) → Soft fail: indicates data inconsistency, sign-out clears the session
- `INTERNAL_ERROR` (handler exception) → Soft fail: doesn't affect client session
- Network timeout → Soft fail: treat as if server couldn't confirm

### Lock Screen Flow Architecture

```
Trigger: NavUser "Lock screen" click OR idle timeout (5 min)
  → useLockStore.lock(reason)
  → emitTelemetry: auth.lock_screen.locked { reason }
  → LockScreen overlay renders (z-index: Z.LOCK_SCREEN, non-dismissible)
  → Supabase token refresh continues in background

Unlock: User enters PIN
  → verifyPinAction(pin) server action
    → bcrypt.compare(pin, staff.pin_hash)
    → Match: return { verified: true }, clear staff_pin_attempts
    → Mismatch: return { verified: false }, increment staff_pin_attempts
    → Rate limit exceeded (5 fails in 15min): return RATE_LIMIT_EXCEEDED
  → On success: useLockStore.unlock(), overlay dismissed
  → On rate limit: UI-initiated sign-out via useSignOut() hook
    (client-side session cleanup — NOT server-side session revocation.
     Access token remains valid until exp. See Security Posture.)

Escape: "Not you? Sign out" link
  → Triggers full sign-out flow (same as NavUser sign-out)
```

### Telemetry Event Schema

All events use `emitTelemetry()` from `lib/telemetry/emit-telemetry.ts`. Correlation ID is automatically injected via `getCorrelationId()` (AsyncLocalStorage). Do NOT use `console.log` directly.

#### Event Definitions

| Event | Severity | Trust Grade | Required Fields | Optional Fields | Emission Point |
|-------|----------|-------------|----------------|-----------------|----------------|
| `auth.sign_out.started` | info | **audit** | staffId, casinoId, staffRole | userAgent, ip | `sign-out.ts` handler entry |
| `auth.sign_out.completed` | info | **audit** | staffId, casinoId, staffRole, durationMs | | `sign-out.ts` before success return |
| `auth.sign_out.failed` | error | **audit** | staffId, casinoId, errorCode, errorMessage, durationMs | | `sign-out.ts` error handler |
| `auth.lock_screen.locked` | info | **ux** | staffId, casinoId, reason (`manual`\|`idle`) | idleTimeoutMs | `lock-screen.tsx` / `(dashboard)/layout.tsx` (component layer, NOT store) |
| `auth.lock_screen.unlocked` | info | **ux** | staffId, casinoId, method (`pin`), durationMs | attemptCount | `lock-screen.tsx` (component layer, NOT store) |
| `auth.lock_screen.pin_failed` | warn | **audit** | staffId, casinoId, attemptCount, maxAttempts (5) | windowStartMs | `verify-pin.ts` on mismatch |
| `auth.lock_screen.rate_limited` | error | **audit** | staffId, casinoId, attemptCount, windowDurationMs | | `verify-pin.ts` on exceed |

#### Telemetry Trust Classification

| Grade | Emission Context | Identity Source | Spoofability | Use For |
|-------|-----------------|-----------------|--------------|---------|
| **audit** | Server action (Node.js) | `mwCtx.rlsContext` (middleware-verified) | Non-spoofable (server-side, auth chain verified) | Compliance, security audit trail, incident investigation |
| **ux** | Client (browser) | `useAuth()` (cached JWT claims) | Spoofable (client-side, no server verification) | UX analytics, debugging, non-binding operational insight |

**Design decision**: Lock/unlock events are **ux-grade** because they are emitted client-side. A user with devtools could call `useLockStore.lock()` directly. This is acceptable because the lock screen is a workflow gate, not a security boundary. PIN verification outcomes (pass/fail/rate-limit) are **audit-grade** because they are emitted from server actions with middleware-verified identity.

**Telemetry emission location**: Lock/unlock telemetry is emitted from the **component layer** (`lock-screen.tsx`, `(dashboard)/layout.tsx`), **NOT from the Zustand store**. The store is pure state (matching `store/ui-store.ts` precedent — no side effects). The component layer has access to `useAuth()` for `staffId`/`casinoId` fields; the store module does not have hook access and would require parameter injection (brittle) or a module-level import (architecture violation). Emitting from components where `useAuth()` is naturally available keeps the telemetry clean and the store testable.

**`getCorrelationId()` note**: Uses `AsyncLocalStorage` (Node.js only). Client-side events will NOT have correlation IDs — this is expected. Do not import `getCorrelationId` in client components.

**Fields derived from context (never passed as parameters):**
- `staffId` → `mwCtx.rlsContext.actorId` (server actions, audit-grade) or `useAuth().staffId` (client, ux-grade)
- `casinoId` → `mwCtx.rlsContext.casinoId` (server actions, audit-grade) or `useAuth().casinoId` (client, ux-grade)
- `correlationId` → automatic via `getCorrelationId()` (server only — null on client)
- `ip` → `headers().get('x-forwarded-for')` (optional, server only)
- `userAgent` → `headers().get('user-agent')` (optional, server only)

---

## Workstream Details

### WS1: Sign-Out Server Action

**Purpose**: Create server action for sign-out observability (structured logging of who signed out, when, from which casino). Claims are NOT cleared — see Claims Model.

**File**: `app/actions/auth/sign-out.ts`

**Pattern**: Follows `app/actions/table-context/activate-table.ts` pattern:
- `'use server'` directive
- `createClient()` for authenticated Supabase client
- `withServerAction(supabase, handler, { domain: 'auth', action: 'sign-out' })`
- Handler emits `auth.sign_out.started` and `auth.sign_out.completed` via `emitTelemetry()`
- Returns `ServiceResult<void>`
- Does **NOT** call `clearUserRLSClaims` (see Claims Model)

**Why a server action at all?**
Without the server action, sign-out is purely client-side (`supabase.auth.signOut()`) with no audit trail. The server action provides:
1. Structured observability: `auth.sign_out` events with actor/casino context
2. Consistent pattern: all auth-significant operations go through `withServerAction`
3. Future extensibility: server-side cleanup hooks if needed later

**Failure semantics**: This action is **soft-fail** — see Sign-Out Failure Semantics. Client-side sign-out proceeds regardless of server action result.

**Critical compliance:**
- ADR-024: User identity derived from auth chain, not parameters
- No `skipAuth` — action requires authentication to identify who is signing out
- No `clearUserRLSClaims` — claims are stable identity (see Claims Model)

**Acceptance Criteria:**
- [ ] Server action file uses `'use server'` directive
- [ ] Uses `withServerAction` from compositor (not deprecated wrapper)
- [ ] Emits `auth.sign_out.started` and `auth.sign_out.completed` via `emitTelemetry()`
- [ ] Emits `auth.sign_out.failed` in error path
- [ ] Does NOT call `clearUserRLSClaims` (stable identity, not cleared on sign-out)
- [ ] Returns `ServiceResult<void>` for client consumption
- [ ] No `as any` casting, no `console.*`

### WS2: NavUser Auth Wiring & Sign-Out UI

**Purpose**: Replace hardcoded mock data with real auth context and wire sign-out.

**Files**:
- `components/layout/nav-user.tsx` (MODIFY)
- `components/logout-button.tsx` (MODIFY)
- `hooks/auth/use-sign-out.ts` (NEW)

**NavUser changes:**
1. Import and use `useAuth()` hook from `hooks/use-auth.ts`
2. Display `user.email`, `staffRole` (formatted), avatar initials from user name
3. Handle `isLoading` state with skeleton placeholder
4. Add "Sign out" menu item with `useTransition` for non-blocking async
5. Add "Lock screen" menu item (disabled in Phase 1, enabled in WS6)
6. Import `Lock` icon from lucide-react for lock screen item

**Shared sign-out hook** (`hooks/auth/use-sign-out.ts`):
- Encapsulates the 4-step flow with failure semantics:
  1. `signOutAction()` — soft fail (catch error, show toast, continue)
  2. `supabase.auth.signOut()` — hard fail (show error modal with Retry / Local Cleanup, do NOT redirect)
  3. `queryClient.clear()` — soft fail (log error, continue)
  4. `router.push('/signin')` — soft fail (fallback to `window.location.href`)
- Returns `{ signOut: () => void, isPending: boolean }` using `useTransition`
- Consumed by both NavUser and LogoutButton

**LogoutButton changes:**
- Replace inline client-only sign-out with `useSignOut()` hook
- Same visual appearance, shares server action flow

**React 19 compliance:**
- `useTransition` for sign-out button (no manual `useState(false)` loading)
- No `useEffect` sync patterns
- No over-memoization

**Acceptance Criteria:**
- [ ] NavUser displays real user data from `useAuth()` (email, role, initials)
- [ ] Loading skeleton while auth initializes
- [ ] "Sign out" uses `useTransition` (not manual loading state)
- [ ] "Lock screen" menu item present (disabled with tooltip in Phase 1)
- [ ] LogoutButton shares `useSignOut()` hook
- [ ] No hardcoded mock data remains
- [ ] Sign-out hook implements soft/hard fail semantics per spec
- [ ] Error modal on `signOut()` failure offers "Retry" and "Clear local session" options
- [ ] "Clear local session" calls `signOut({ scope: 'local' })`, `cleanupClientInstance()`, `queryClient.clear()`, then redirects
- [ ] `cleanupClientInstance()` verified to exist at `lib/supabase/client.ts` and covered by a unit test proving a new SupabaseClient instance is created after calling it (i.e., `createBrowserClient()` returns a different reference after cleanup)
- [ ] Error modal text explains that server-side session may remain active
- [ ] Local cleanup banner trigger is deterministic: redirect includes `?local_cleanup=1` or hook sets a `sessionStorage` flag consumed by `/signin`
- [ ] `/signin` displays the degraded sign-out banner only when the deterministic flag is present

### WS3: Phase 1 Tests (Sign-Out)

**Purpose**: Validate sign-out server action and NavUser component.

**Files**:
- `app/actions/auth/__tests__/sign-out.test.ts`
- `components/layout/__tests__/nav-user.test.tsx`

**Server action tests** (`sign-out.test.ts`):
- `signOutAction` returns `ServiceResult` with `ok: true` on success
- `signOutAction` returns `UNAUTHORIZED` when user not authenticated
- `signOutAction` does NOT call `clearUserRLSClaims` (verify no import/usage)
- `signOutAction` emits `auth.sign_out.started` and `auth.sign_out.completed` via `emitTelemetry()`

**Component tests** (`nav-user.test.tsx`):
- NavUser renders user email and role from `useAuth()`
- NavUser renders loading skeleton when `isLoading: true`
- "Sign out" menu item triggers sign-out handler
- "Lock screen" menu item is present and disabled

**Test patterns:**
- Mock `useAuth()` via `jest.mock('@/hooks/use-auth')`
- Mock `SupabaseClient<Database>` per QA-001 patterns
- Mock `emitTelemetry` to verify event emission

**Acceptance Criteria:**
- [ ] Server action tests cover happy path + error propagation
- [ ] Component tests cover auth data rendering + loading state
- [ ] Telemetry emission verified (event names + required fields)
- [ ] All tests pass with `npm test`

### WS4: Staff PIN Schema + Rate Limit Table Migration

**Purpose**: Add `pin_hash` column to `staff` table, create `staff_pin_attempts` table for DB-backed rate limiting, and add self-update RLS policy.

**Files**:
- `supabase/migrations/YYYYMMDDHHMMSS_add_staff_pin_hash.sql`
- `supabase/migrations/YYYYMMDDHHMMSS_add_staff_pin_attempts.sql`
- `supabase/migrations/YYYYMMDDHHMMSS_add_staff_pin_rls_policy.sql`

#### Migration 1: pin_hash column

```sql
-- ============================================================================
-- Migration: Add pin_hash column to staff table for lock screen PIN
-- Created: {REAL_TIMESTAMP}
-- Gap Reference: docs/issues/gaps/GAP-SIGN-OUT-IMPLEMENTATION.md
-- Purpose: Store bcrypt-hashed PIN for lock screen re-authentication
-- Bounded Context: CasinoService (SRM v4.11.1 — owns staff table)
-- ============================================================================

ALTER TABLE staff ADD COLUMN IF NOT EXISTS pin_hash text;

COMMENT ON COLUMN staff.pin_hash IS
  'Bcrypt hash of 4-6 digit PIN for lock screen re-authentication. NULL = PIN not yet set.';

NOTIFY pgrst, 'reload schema';
```

#### Migration 2: staff_pin_attempts table (DB-backed rate limiting)

**Why DB-backed**: In-memory rate limiting (`Map<staffId, { count, windowStart }>`) resets on serverless instance restart and is not shared across instances. On Vercel/serverless, each request may land on a different container, making in-memory rate limiting ineffective (placebo security).

**RPC Prerequisites — `set_rls_context_from_staff()` under pooling:**

The `rpc_increment_pin_attempt()` RPC calls `PERFORM public.set_rls_context_from_staff()` as its first statement (ADR-024 INV-7). This is safe under transaction pooling because the function satisfies all of the following:

1. **Zero-parameter derivation (INV-8):** Identity is derived internally, never from caller-supplied params. Two-path resolution:
   - **Primary:** Extracts `staff_id` from JWT `app_metadata.staff_id`, then **binds it to `auth.uid()`** by verifying `staff.user_id = auth.uid()`. This prevents mis-issued token escalation.
   - **Fallback:** If no JWT claim, maps `auth.uid()` → `staff.user_id` directly.
2. **Transaction-local context (INV-5):** All session variables (`app.actor_id`, `app.casino_id`, `app.staff_role`) are set via `set_config(..., true)` which is equivalent to `SET LOCAL` — scoped to the current transaction only. Context does **not** leak across pooled connections and is automatically reset on transaction commit/rollback.
3. **Active-staff gating (INV-4):** The function enforces `staff.status = 'active'` and `staff.casino_id IS NOT NULL`. Inactive or unscoped staff raise `FORBIDDEN`.
4. **Deterministic lookup (INV-6):** `staff.user_id` has a unique constraint, making the `auth.uid()` → staff mapping deterministic (exactly one staff record per auth user).

This is the same mechanism used by all existing ADR-024 compliant RPCs (e.g., `rpc_start_visit`, `rpc_complete_visit`). The implementation lives in migration `20251229152317_adr024_rls_context_from_staff.sql`.

```sql
-- ============================================================================
-- Migration: Staff PIN rate-limit attempts table
-- Created: {REAL_TIMESTAMP}
-- Purpose: DB-backed rate limiting for PIN verification (replaces in-memory)
-- Bounded Context: CasinoService (Foundational) — operational rate-limit state, follows audit_log precedent
-- ============================================================================

CREATE TABLE public.staff_pin_attempts (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  casino_id uuid NOT NULL REFERENCES public.casino(id) ON DELETE CASCADE,
  staff_id uuid NOT NULL REFERENCES public.staff(id) ON DELETE CASCADE,
  attempt_count int NOT NULL DEFAULT 1 CHECK (attempt_count >= 0),
  window_start timestamptz NOT NULL,
  last_attempt_at timestamptz NOT NULL DEFAULT now(),
  created_at timestamptz NOT NULL DEFAULT now()
);

CREATE UNIQUE INDEX ux_staff_pin_attempts_window
  ON public.staff_pin_attempts (casino_id, staff_id, window_start);

CREATE INDEX ix_staff_pin_attempts_window_start
  ON public.staff_pin_attempts (window_start DESC);

COMMENT ON TABLE public.staff_pin_attempts IS
  'Tracks PIN verification attempts per staff member per 15-minute window. '
  'window_start is a floored bucket (date_trunc to 15min), NOT raw now(). '
  'Expired entries (>30 min) pruned lazily inside rpc_increment_pin_attempt().';

-- Atomic increment RPC for race-safe attempt counting.
-- ADR-024 INV-7: calls set_rls_context_from_staff() as first statement.
-- ADR-024 INV-8: no spoofable params — derives staff_id/casino_id from context.
-- ADR-018: SECURITY DEFINER with REVOKE/GRANT privilege lockdown.
-- Includes lazy cleanup of expired windows (>30 min) — Issue A fix.
CREATE FUNCTION public.rpc_increment_pin_attempt()
RETURNS TABLE (attempt_count int, is_limited boolean)
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = pg_catalog, public
AS $$
DECLARE
  v_staff_id  uuid;
  v_casino_id uuid;
  v_count     int;
  v_now       timestamptz := now();
  -- **Timezone note:** v_now is timestamptz (now()), which represents an absolute time.
  -- Bucketing is deterministic regardless of session timezone. If future changes
  -- introduce timestamp without time zone, normalize via timezone('UTC', now())
  -- before computing v_window.
  -- Floor to 15-minute bucket: e.g. 14:07 → 14:00, 14:16 → 14:15
  v_window    timestamptz := date_trunc('hour', v_now)
    + (floor(extract(minute FROM v_now)::int / 15) * 15) * interval '1 minute';
BEGIN
  -- ═══════════════════════════════════════════════════════════════════════
  -- CONTEXT INJECTION (ADR-024 INV-7)
  -- ═══════════════════════════════════════════════════════════════════════
  PERFORM public.set_rls_context_from_staff();

  -- Derive identity from authoritative context (INV-8: no spoofable params)
  v_staff_id  := NULLIF(current_setting('app.actor_id', true), '')::uuid;
  v_casino_id := NULLIF(current_setting('app.casino_id', true), '')::uuid;

  IF v_staff_id IS NULL OR v_casino_id IS NULL THEN
    RAISE EXCEPTION 'UNAUTHORIZED: RLS context not available'
      USING ERRCODE = 'P0001';
  END IF;

  -- ═══════════════════════════════════════════════════════════════════════
  -- LAZY CLEANUP: prune expired windows (>30 minutes old)
  -- Scoped to calling staff only — no cross-tenant data manipulation.
  -- ═══════════════════════════════════════════════════════════════════════
  DELETE FROM public.staff_pin_attempts
  WHERE staff_id = v_staff_id
    AND casino_id = v_casino_id
    AND window_start < v_now - interval '30 minutes';

  -- ═══════════════════════════════════════════════════════════════════════
  -- ATOMIC UPSERT: increment attempt count within current 15-min bucket
  -- ═══════════════════════════════════════════════════════════════════════
  INSERT INTO public.staff_pin_attempts (
    casino_id, staff_id, window_start, attempt_count, last_attempt_at
  ) VALUES (v_casino_id, v_staff_id, v_window, 1, v_now)
  ON CONFLICT (casino_id, staff_id, window_start) DO UPDATE
  SET
    attempt_count = staff_pin_attempts.attempt_count + 1,
    last_attempt_at = v_now
  RETURNING staff_pin_attempts.attempt_count INTO v_count;

  RETURN QUERY SELECT v_count, v_count >= 5;
END;
$$;

COMMENT ON FUNCTION public.rpc_increment_pin_attempt() IS
  'Atomically increment PIN attempt count within a 15-minute bucket. '
  'ADR-024 INV-7/INV-8 compliant: calls set_rls_context_from_staff(), no spoofable params. '
  'Includes lazy cleanup of expired windows (>30 min). Returns (attempt_count, is_limited).';

-- ADR-018: SECURITY DEFINER privilege lockdown
REVOKE ALL ON FUNCTION public.rpc_increment_pin_attempt() FROM PUBLIC;
REVOKE ALL ON FUNCTION public.rpc_increment_pin_attempt() FROM anon;
GRANT EXECUTE ON FUNCTION public.rpc_increment_pin_attempt() TO authenticated;

-- ═══════════════════════════════════════════════════════════════════════════
-- CLEAR ATTEMPTS RPC: Called on successful PIN verify to reset attempt count.
-- Same ADR-024 INV-7/INV-8 pattern: zero params, identity from context.
-- ═══════════════════════════════════════════════════════════════════════════
CREATE FUNCTION public.rpc_clear_pin_attempts()
RETURNS void
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = pg_catalog, public
AS $$
DECLARE
  v_staff_id  uuid;
  v_casino_id uuid;
BEGIN
  PERFORM public.set_rls_context_from_staff();

  v_staff_id  := NULLIF(current_setting('app.actor_id', true), '')::uuid;
  v_casino_id := NULLIF(current_setting('app.casino_id', true), '')::uuid;

  IF v_staff_id IS NULL OR v_casino_id IS NULL THEN
    RAISE EXCEPTION 'UNAUTHORIZED: RLS context not available'
      USING ERRCODE = 'P0001';
  END IF;

  DELETE FROM public.staff_pin_attempts
  WHERE staff_id = v_staff_id
    AND casino_id = v_casino_id;
END;
$$;

COMMENT ON FUNCTION public.rpc_clear_pin_attempts() IS
  'Clear all PIN attempt records for the calling staff member on successful verify. '
  'ADR-024 INV-7/INV-8 compliant: calls set_rls_context_from_staff(), no spoofable params.';

REVOKE ALL ON FUNCTION public.rpc_clear_pin_attempts() FROM PUBLIC;
REVOKE ALL ON FUNCTION public.rpc_clear_pin_attempts() FROM anon;
GRANT EXECUTE ON FUNCTION public.rpc_clear_pin_attempts() TO authenticated;

-- ═══════════════════════════════════════════════════════════════════════════
-- INVARIANT: staff_pin_attempts is RPC-only. App code must never issue direct
-- SELECT/INSERT/UPDATE/DELETE against staff_pin_attempts. All access is via
-- rpc_increment_pin_attempt() and rpc_clear_pin_attempts().
-- ═══════════════════════════════════════════════════════════════════════════

-- ═══════════════════════════════════════════════════════════════════════════
-- TABLE ACCESS CONTROL: No direct DML on staff_pin_attempts.
-- All access via SECURITY DEFINER RPCs (rpc_increment_pin_attempt,
-- rpc_clear_pin_attempts). RLS is enabled but no policies are defined —
-- this means authenticated role has ZERO direct access (RLS defaults to
-- deny-all when enabled with no matching policy).
-- ═══════════════════════════════════════════════════════════════════════════
ALTER TABLE public.staff_pin_attempts ENABLE ROW LEVEL SECURITY;

-- Belt-and-suspenders: revoke direct DML even if RLS were somehow bypassed
REVOKE ALL ON public.staff_pin_attempts FROM authenticated;
REVOKE ALL ON public.staff_pin_attempts FROM anon;

NOTIFY pgrst, 'reload schema';
```

#### Migration 3: Staff self-update PIN RLS policy

**Why**: Current staff UPDATE policy is admin-only. Staff need to update their own `pin_hash`. This policy follows **Template 2b** (ADR-030 D4: session vars required, no JWT COALESCE fallback).

```sql
-- ============================================================================
-- Migration: Allow staff to update their own pin_hash (column-restricted)
-- Created: {REAL_TIMESTAMP}
-- ADR-030 D4 compliant: Template 2b (session vars required, no JWT fallback)
-- Purpose: Self-service PIN setup for lock screen
-- Column restriction: authenticated can only UPDATE pin_hash on staff
-- Precedent: staff_invite token_hash column-level hardening (PRD-025)
-- ============================================================================

-- ═══════════════════════════════════════════════════════════════════════════
-- 1. RLS Policy: row-level gating (self-only, same casino, active)
-- ═══════════════════════════════════════════════════════════════════════════
CREATE POLICY staff_update_own_pin
  ON staff
  FOR UPDATE
  USING (
    auth.uid() = user_id
    AND casino_id = NULLIF(current_setting('app.casino_id', true), '')::uuid
    AND status = 'active'
  )
  WITH CHECK (
    auth.uid() = user_id
    AND casino_id = NULLIF(current_setting('app.casino_id', true), '')::uuid
  );

COMMENT ON POLICY staff_update_own_pin ON staff IS
  'Allow staff to update their own row (pin_hash only via column-level grant). ADR-030 D4 Template 2b.';

-- ═══════════════════════════════════════════════════════════════════════════
-- 2. Column-Level Privilege Hardening
--
-- RLS policies control row access, not column access. Without column-level
-- restriction, a staff member matching staff_update_own_pin could UPDATE
-- their own role, status, casino_id, etc. — privilege escalation vector.
--
-- Admin staff writes use service_role client (services/casino/crud.ts),
-- which bypasses both RLS and column grants. The existing staff_update
-- admin-only policy remains as defense-in-depth but is not functionally
-- affected by this REVOKE.
--
-- Precedent: staff_invite.token_hash hardening (PRD-025 migration).
-- ═══════════════════════════════════════════════════════════════════════════
REVOKE UPDATE ON public.staff FROM authenticated;
GRANT UPDATE (pin_hash) ON public.staff TO authenticated;

NOTIFY pgrst, 'reload schema';
```

**Post-migration:** Run `npm run db:types` to regenerate `types/database.types.ts`.

**Acceptance Criteria:**
- [ ] Migration files follow `YYYYMMDDHHMMSS_description.sql` naming
- [ ] pin_hash uses `IF NOT EXISTS` for idempotency
- [ ] staff_pin_attempts has unique index on (casino_id, staff_id, window_start)
- [ ] RPC `rpc_increment_pin_attempt` is SECURITY DEFINER with restricted search_path
- [ ] RPC calls `set_rls_context_from_staff()` as first statement (ADR-024 INV-7)
- [ ] RPC accepts NO parameters — derives identity from context (ADR-024 INV-8)
- [ ] RPC has `REVOKE ALL FROM PUBLIC` + `GRANT EXECUTE TO authenticated` (ADR-018)
- [ ] RPC includes lazy cleanup of expired windows (>30 min) before upsert
- [ ] RLS policy uses Template 2b (NULLIF, no COALESCE fallback to JWT)
- [ ] Column-level privilege: `REVOKE UPDATE ON staff FROM authenticated` + `GRANT UPDATE (pin_hash) ON staff TO authenticated`
- [ ] `rpc_clear_pin_attempts()` is SECURITY DEFINER, no params, calls `set_rls_context_from_staff()`, REVOKE/GRANT lockdown
- [ ] `staff_pin_attempts` has RLS enabled with **no policies** (deny-all for direct access)
- [ ] `staff_pin_attempts` has `REVOKE ALL FROM authenticated` + `REVOKE ALL FROM anon` (belt-and-suspenders)
- [ ] All `staff_pin_attempts` access is via SECURITY DEFINER RPCs only (`rpc_increment_pin_attempt`, `rpc_clear_pin_attempts`)
- [ ] A lint/grep guard (or code review checklist item) exists: forbid `.from('staff_pin_attempts')` in app code
- [ ] All migrations end with `NOTIFY pgrst, 'reload schema'`
- [ ] `npm run db:types` succeeds
- [ ] `staff.pin_hash` appears in `database.types.ts` as `string | null`

### WS5: PIN Set/Verify Server Actions

**Purpose**: Server actions for PIN lifecycle (set, verify) with DB-backed rate limiting and denylist.

**Files**:
- `app/actions/auth/set-pin.ts`
- `app/actions/auth/verify-pin.ts`
- `app/actions/auth/get-pin-status.ts` (NEW — lightweight PIN status check)
- `app/actions/auth/schemas.ts`

#### RLS & Service-Role Boundary

**Both actions use authed+RLS** (no service-role). This is mandated by:
- **ADR-030 D4**: Staff is a security-critical table; writes must use session vars
- **ADR-024**: No spoofable parameters; staffId from `rlsContext.actorId`
- **Existing pattern**: `CasinoService.updateStaff()` uses authed client

The `staff_update_own_pin` RLS policy (WS4) permits self-update. The existing `staff_read` policy permits self-select (casino-scoped).

**Session-var prerequisite (load-bearing):** The `staff_update_own_pin` policy is Template 2b — it requires `current_setting('app.casino_id', true)` to be set. This means `withServerAction` **must** run `set_rls_context_from_staff()` (which sets `app.casino_id`, `app.actor_id`, `app.staff_role` via `SET LOCAL`) **before** the handler executes any SQL. Without session vars, the policy evaluates `casino_id = NULL` → rejects every UPDATE. This is not optional middleware — it is the reason the write path works. Both `setPinAction` and `verifyPinAction` depend on this guarantee from the compositor's auth chain. See WS4 Migration 2 "RPC Prerequisites" for the full mechanical description of how `set_rls_context_from_staff()` derives identity and achieves pooling safety (INV-4/5/6/7/8).

#### Shared schema with denylist (`schemas.ts`):

```typescript
import { z } from 'zod';

const PIN_DENYLIST = new Set([
  // Repeated digits
  '0000', '1111', '2222', '3333', '4444', '5555', '6666', '7777', '8888', '9999',
  // Sequential ascending
  '0123', '1234', '2345', '3456', '4567', '5678', '6789',
  '01234', '12345', '23456', '34567', '45678', '56789',
  '012345', '123456', '234567', '345678', '456789',
  // Sequential descending
  '4321', '3210', '5432', '6543', '7654', '8765', '9876',
  '54321', '43210', '65432', '76543', '87654', '98765',
  '654321', '543210', '765432', '876543', '987654',
  // Doubled adjacent
  '1122', '2233', '3344', '4455', '5566', '6677', '7788', '8899', '0011',
]);

export const pinSchema = z
  .string()
  .regex(/^\d{4,6}$/, 'PIN must be 4-6 digits')
  .refine(
    (pin) => !PIN_DENYLIST.has(pin),
    { message: 'PIN is too common. Choose a less predictable combination.' }
  );
```

#### setPinAction(pin: string)

- `withServerAction` compositor (auth chain establishes staff identity)
- Zod-validate PIN format + denylist via `pinSchema`
- `bcrypt.hash(pin, 10)` → update `staff.pin_hash` WHERE `id = rlsContext.actorId`
- Uses **authed client** (`ctx.supabase`) — RLS policy enforces self-only update
- Returns `ServiceResult<void>`

#### getPinStatusAction()

- `withServerAction` compositor (auth chain)
- No input parameters — identity derived from `rlsContext.actorId`
- Read `staff.pin_hash IS NOT NULL` WHERE `id = rlsContext.actorId`
- Returns `ServiceResult<{ hasPin: boolean }>`
- Does NOT expose the `pin_hash` value — boolean only
- Called by LockScreen on activation to determine setup vs verify mode

#### verifyPinAction(pin: string)

- `withServerAction` compositor (auth chain)
- Zod-validate PIN format
- Read `staff.pin_hash` WHERE `id = rlsContext.actorId`
- If `pin_hash` is null: return `{ ok: false, code: 'NOT_FOUND', error: 'PIN not set' }`
- `bcrypt.compare(pin, pinHash)`
- **DB-backed rate limiting** via `rpc_increment_pin_attempt()` (no arguments — identity derived from context):
  - Max 5 attempts per 15-minute window per staff member
  - On exceed: return `{ ok: false, code: 'RATE_LIMIT_EXCEEDED' }`, emit `auth.lock_screen.rate_limited`
  - Reset on successful verify: call `rpc_clear_pin_attempts()` (SECURITY DEFINER, no params — identity from context). Direct DELETE is not permitted (table has RLS enabled with no policies + REVOKE ALL).
  - Lazy cleanup of expired windows (>30 min) is handled inside the RPC — do NOT duplicate in TypeScript
- On mismatch: emit `auth.lock_screen.pin_failed` with attemptCount
- Returns `ServiceResult<{ verified: boolean }>`

#### PIN Lifecycle State Machine

```
[NULL] ──setPinAction()──→ [SET]
  ↑                          │
  │ (admin reset via          ├──verifyPinAction() match──→ [VERIFIED] → unlock overlay
  │  updateStaff(pin_hash:    │                              (stays SET)
  │  null))                   ├──verifyPinAction() mismatch──→ increment attempts
  │                           │                                (stays SET)
  └───────────────────────────├──5 failures in 15min──→ [RATE_LIMITED] → UI-initiated sign-out
                              │
                              └──verifyPinAction() pin_hash=null──→ [NULL] (trigger setup)
```

**PIN Reset Flow (MVP):**
- **Admin reset**: Admin/pit_boss NULLs `pin_hash` via `updateStaff()` (existing admin-only RLS policy)
- **No self-service "forgot PIN"**: Staff must sign out, re-sign-in, set new PIN on first lock
- **After rate-limit lockout**: UI-initiated sign-out occurs (client-side session cleanup). PIN is NOT automatically NULLed. Staff re-signs in normally. Note: access token remains valid until expiry (per `jwt_expiry` in `supabase/config.toml`) — this is a workflow gate, not cryptographic revocation.
- **Rotation policy**: No mandatory PIN rotation in MVP. PIN persists until admin reset or staff voluntary change.
- **Runbook (MVP):** Admin resets a staff PIN by setting `staff.pin_hash = NULL` using the existing admin staff edit surface (if present). If no UI exists yet, perform a controlled reset via a Supabase SQL console script (service role) and log the action in `audit_log` with `action='staff.pin_reset'`.

**Dependency**: `bcryptjs` + `@types/bcryptjs` must be added to `package.json`.

**Runtime constraint**: WS5 server actions MUST run on **Node.js runtime** (the default for Next.js server actions). Do NOT add `export const runtime = 'edge'`. The `withServerAction` compositor depends on `AsyncLocalStorage` (Node.js only) for correlation context. `bcryptjs` is pure JavaScript and works in Node.js without native compilation — do NOT import native `bcrypt` (which requires `node-gyp`).

**Acceptance Criteria:**
- [ ] Both actions use `withServerAction` from compositor
- [ ] `withServerAction` runs `set_rls_context_from_staff()` before handler — session vars (`app.casino_id`, `app.actor_id`) are set before any SQL executes
- [ ] Both actions use **authed client** (not service-role) — RLS enforces boundaries
- [ ] PIN validated via Zod + denylist before database access
- [ ] No `staffId` parameter from client (derived from `rlsContext.actorId`)
- [ ] bcrypt hash with salt rounds >= 10
- [ ] Rate limiting is DB-backed via `staff_pin_attempts` table + `rpc_increment_pin_attempt`
- [ ] Rate limiter returns `RATE_LIMIT_EXCEEDED` code
- [ ] Successful verify clears attempts via `rpc_clear_pin_attempts()` (not raw DELETE — table has no direct access)
- [ ] Lazy cleanup: old records (>30min) deleted inside `rpc_increment_pin_attempt()` — NOT duplicated in TypeScript
- [ ] `bcryptjs` added to dependencies
- [ ] Denylist rejects common PINs (0000, 1234, etc.)
- [ ] Telemetry events emitted: `pin_failed`, `rate_limited`
- [ ] No `console.*` in production, no `as any`
- [ ] The repo contains either (A) an admin UI reset path for PIN, or (B) a documented SQL snippet + audit_log requirement for the manual reset procedure

### WS6: Lock Screen UI (Overlay + Idle Detection + Store)

**Purpose**: Full lock screen implementation with idle detection and state management.

**Files**:
- `components/layout/lock-screen.tsx` (NEW)
- `hooks/use-idle-detection.ts` (NEW)
- `store/lock-store.ts` (NEW)
- `hooks/ui/use-lock-screen.ts` (NEW)
- `components/layout/nav-user.tsx` (MODIFY — enable lock item)

#### Lock Screen Overlay (`lock-screen.tsx`)

- `'use client'` component
- Full viewport: `fixed inset-0` with z-index from `Z.LOCK_SCREEN` constant (above all app UI except toaster)
- Non-dismissible: `onEscapeKeyDown={(e) => e.preventDefault()}`, no click-outside
- **z-index strategy**: The lock screen MUST render above **all application UI** (sidebar, header, modals, drawers, popovers) but **below** the Sonner toaster (toast notifications for sign-out errors and rate-limit warnings must remain visible during lock screen interaction). Define a single z-index scale object:

  ```typescript
  // lib/constants/z-index.ts
  export const Z = {
    TOASTER: 10000,
    LOCK_SCREEN: 9000,
    MODAL: 8000,
  } as const;
  // Sonner toasts: z-[999999999] (library default, always above)
  // Lock screen: z-[9000] (above all shadcn/Radix portals at z-50)
  // Modals/Drawers/Sheets: z-50 (shadcn/Radix default)
  // Header/Sidebar: z-50
  ```

  Use via `style={{ zIndex: Z.LOCK_SCREEN }}` (no inline magic numbers without reference). The `Z` object in `lib/constants/z-index.ts` is the single source of truth — if a future component needs to layer above modals but below the lock screen, it references this scale. The lock screen's security is in its non-dismissibility, not in z-index positioning.
- Backdrop: `bg-black/80 backdrop-blur-md`
- Content centered: user avatar/name, PIN input (4-6 masked digits), submit button
- "Not you? Sign out" link below PIN input
- `useTransition` for PIN verify and sign-out actions
- Error state: shake animation on wrong PIN, error message
- Rate limit state: auto-triggers sign-out
- PIN input uses shadcn `InputOTP` or standard `Input` with `type="password" inputMode="numeric"`
- Session stays alive (no interference with Supabase auth refresh)

**Lock Screen UI State Machine (PIN setup vs verify):**

When the lock screen activates, it must handle two distinct modes based on whether `pin_hash` is set:

```
[LOCK ACTIVATED]
  → Call getPinStatusAction() (lightweight, no PIN param)
  → If { hasPin: false }:
      → Show "Create Your PIN" mode:
        1. "Enter new PIN" input (4-6 digits, masked)
        2. "Confirm PIN" input (must match)
        3. Submit calls setPinAction(pin) → on success, unlock
        4. On denylist rejection: show inline error, clear inputs
  → If { hasPin: true }:
      → Show "Enter PIN" mode (default):
        1. PIN input (4-6 digits, masked)
        2. Submit calls verifyPinAction(pin)
        3. On success: unlock
        4. On mismatch: shake animation, error message, clear input
        5. On RATE_LIMIT_EXCEEDED: auto-trigger UI-initiated sign-out

Both modes show "Not you? Sign out" escape link.
```

**PIN status detection**: A dedicated `getPinStatusAction()` server action returns `ServiceResult<{ hasPin: boolean }>`. This is necessary because `verifyPinAction` validates PIN format (4-6 digits via Zod) — passing an empty string or omitting the PIN would fail schema validation before reaching the `pin_hash IS NULL` check. The status action:
- Uses `withServerAction` compositor (auth chain)
- Reads `staff.pin_hash IS NOT NULL` WHERE `id = rlsContext.actorId`
- Returns `{ hasPin: boolean }` — no PIN data exposed
- File: `app/actions/auth/get-pin-status.ts`
- Added to WS5 outputs

**Implementation note**: The lock screen component tracks an internal `mode: 'verify' | 'setup' | 'loading'` state. On mount, calls `getPinStatusAction()` to determine mode deterministically. No guessing, no empty-string hacks.

#### Idle Detection Hook (`use-idle-detection.ts`)

- Parameters: `{ timeout: number, onIdle: () => void, enabled?: boolean, throttleMs?: number }`
- Tracks: `mousemove`, `keydown`, `pointerdown` on `document` (`pointerdown` unifies mouse, touch, and pen input via Pointer Events API — replaces separate `click` + `touchstart` listeners. `click` fires on mouseup with delay; `pointerdown` fires immediately on press.)
- **Activity handler is throttled** (default 500ms) via simple `Date.now()` timestamp check — no external dependency. `mousemove` fires constantly; without throttle, timer reset causes perf churn.
- Sets timer via `setTimeout`; resets on any throttled tracked event
- Calls `onIdle()` when timeout reached
- Cleanup: removes listeners and clears timer on unmount
- **`enabled` flag is mandatory in integration**: MUST be `false` when lock screen is active to prevent timer reset while locked
- Default timeout: 5 minutes (300_000 ms)
- `visibilitychange`: **explicitly deferred** to future phase (documented, not forgotten)

#### Zustand Lock Store (`store/lock-store.ts`)

Follows existing store pattern (`store/ui-store.ts`). **Pure state — no side effects, no telemetry emission.** Lock/unlock telemetry is emitted from the component layer where `useAuth()` provides identity context (see Telemetry Event Schema).

```typescript
interface LockStore {
  isLocked: boolean;
  lockReason: 'manual' | 'idle' | null;
  lockedAt: number | null;  // Date.now() for duration tracking
  lock: (reason: 'manual' | 'idle') => void;
  unlock: () => void;
}
```

- Uses `create<LockStore>()(devtools((set) => ({...}), { name: 'lock-store' }))`
- `lock(reason)`: sets `isLocked: true`, `lockReason: reason`, `lockedAt: Date.now()`
- `unlock()`: sets `isLocked: false`, `lockReason: null`, `lockedAt: null`
- Zustand stores are module-level exports — no provider wrapper needed

#### Selector Hook (`hooks/ui/use-lock-screen.ts`)

Follows existing pattern (`hooks/ui/use-modal.ts`):

```typescript
export function useLockScreen() {
  return useLockStore(
    useShallow((s) => ({
      isLocked: s.isLocked,
      lockReason: s.lockReason,
      lockedAt: s.lockedAt,
      lock: s.lock,
      unlock: s.unlock,
    }))
  );
}
```

#### NavUser Update (Phase 2)

- Enable "Lock screen" menu item (remove disabled state)
- `onClick` calls `useLockScreen().lock('manual')`

#### Integration in Layout (Exact Placement)

The `LockScreen` component MUST be rendered in `app/(dashboard)/layout.tsx`.

**Provider hierarchy** (from root):
```
app/layout.tsx
  └─ app/providers.tsx
       ├─ QueryClientProvider (TanStack Query v5)
       ├─ ThemeProvider
       └─ Toaster

app/(dashboard)/layout.tsx
  ├─ Header (z-50, fixed, h-16)
  ├─ AppSidebar (w-14 collapsed)
  └─ main (pt-16 pl-14)
       ├─ {children}
       └─ {isLocked && <LockScreen />}  ← LAST CHILD, overlays everything
```

**Hard requirements:**
- Rendered **after** main content as last child, so it overlays everything
- Inside QueryClientProvider (needed for `useQueryClient` in sign-out hook)
- Zustand stores need no provider (module-level)
- Uses **conditional render** (`{isLocked && <LockScreen />}`), not CSS visibility
- `useIdleDetection` initialized at dashboard layout level with `enabled={!isLocked}`

**React 19 compliance:**
- `useTransition` for PIN verify and sign-out (no manual loading states)
- No `useEffect` sync patterns
- No over-memoization (React Compiler handles it)
- Key-based reset on lock/unlock transitions if needed

**Acceptance Criteria:**
- [ ] Lock screen overlay is `fixed inset-0` with z-index from `Z.LOCK_SCREEN` constant (`lib/constants/z-index.ts`) — renders above all app UI except toaster
- [ ] `lib/constants/z-index.ts` created with `Z` object (`Z.LOCK_SCREEN`, `Z.MODAL`, `Z.TOASTER`) and z-index scale documentation
- [ ] No usage of standalone `Z_LOCK_SCREEN` remains (single source of truth is `Z.LOCK_SCREEN`)
- [ ] Non-dismissible (no ESC, no click-outside)
- [ ] PIN input accepts 4-6 digits, masked
- [ ] Successful PIN verify dismisses overlay
- [ ] Wrong PIN shows error with visual feedback
- [ ] Rate limit exceeded auto-triggers UI-initiated sign-out (client-side cleanup)
- [ ] "Not you? Sign out" link triggers full sign-out flow
- [ ] Idle detection triggers lock after configurable timeout
- [ ] Idle detection activity handler is throttled (500ms default)
- [ ] Idle detection is disabled (`enabled=false`) when lock screen is active
- [ ] NavUser "Lock screen" triggers manual lock
- [ ] Zustand store is **pure state** — no telemetry emission, no side effects (matches `ui-store.ts` precedent)
- [ ] Zustand store uses `devtools` middleware with named actions
- [ ] Zustand store tracks `lockedAt` timestamp for duration calculation
- [ ] Lock/unlock telemetry (`auth.lock_screen.locked`, `auth.lock_screen.unlocked`) emitted from **component layer** (`lock-screen.tsx` / `(dashboard)/layout.tsx`) where `useAuth()` provides `staffId`/`casinoId`
- [ ] Selector hook uses `useShallow` for render optimization
- [ ] Session stays alive while locked (token refresh continues)
- [ ] LockScreen rendered in `app/(dashboard)/layout.tsx` as last child after main content
- [ ] Conditional render, not CSS visibility
- [ ] Idle detection uses `pointerdown` (not separate `click` + `touchstart`)
- [ ] Lock screen calls `getPinStatusAction()` on activation to determine setup vs verify mode — no empty-string hacks
- [ ] Lock screen handles PIN setup mode (`hasPin: false` → "Create PIN" with confirm) vs verify mode (`hasPin: true` → "Enter PIN")

### WS7: Phase 2 Tests (Lock Screen + PIN)

**Purpose**: Comprehensive tests for Phase 2 artifacts.

**Files**:
- `app/actions/auth/__tests__/set-pin.test.ts`
- `app/actions/auth/__tests__/verify-pin.test.ts`
- `components/layout/__tests__/lock-screen.test.tsx`
- `components/layout/__tests__/lock-screen.integration.test.tsx` (NEW)
- `hooks/__tests__/use-idle-detection.test.ts`
- `store/__tests__/lock-store.test.ts`

**PIN server action tests:**
- `setPinAction` hashes PIN and stores in `staff.pin_hash`
- `setPinAction` rejects invalid PIN format (< 4 digits, > 6 digits, non-numeric)
- `setPinAction` rejects denied PINs (`1234`, `0000`) via denylist
- `setPinAction` updates correct staff record (from `rlsContext.actorId`)
- `setPinAction` fails when session vars are not set (RLS policy rejects UPDATE — verifies Template 2b dependency on `withServerAction` context injection). **Test strategy**: Mock the `withRLS` middleware to skip context injection for this specific test (i.e., mock `injectRLSContext` from `lib/supabase/rls-context.ts` to return a context with null `actorId`/`casinoId`), then verify the Supabase UPDATE returns a Postgres permission error. This is deterministic because the RLS policy `staff_update_own_pin` evaluates `casino_id = NULLIF(current_setting('app.casino_id', true), '')::uuid` — with no session vars set, this is NULL, and the policy rejects. Do NOT use `skipAuth: true` (that skips both auth AND RLS, which is too broad).
- `verifyPinAction` returns `verified: true` on correct PIN
- `verifyPinAction` returns `verified: false` on wrong PIN
- `verifyPinAction` returns `RATE_LIMIT_EXCEEDED` after 5 failed attempts (via DB)
- `verifyPinAction` resets on successful verify (calls `rpc_clear_pin_attempts()`, not raw DELETE)
- `verifyPinAction` returns `NOT_FOUND` when `pin_hash` is null
- `verifyPinAction` emits `auth.lock_screen.pin_failed` on wrong PIN
- `verifyPinAction` emits `auth.lock_screen.rate_limited` on exceed
- `getPinStatusAction` returns `{ hasPin: true }` when `pin_hash` is set
- `getPinStatusAction` returns `{ hasPin: false }` when `pin_hash` is null
- `getPinStatusAction` does not expose `pin_hash` value

**Component tests:**
- LockScreen renders overlay when `isLocked: true`
- LockScreen does not render when `isLocked: false`
- PIN input accepts digits and masks them
- Successful PIN verify calls `unlock()`
- "Not you? Sign out" triggers sign-out flow

**Integration smoke test** (`lock-screen.integration.test.tsx`):
- Lock screen → enter wrong PIN 5 times → verify UI-initiated sign-out is triggered
- Uses Jest (not Playwright) for speed (~200ms vs ~2000ms+)
- Mocks `verifyPinAction` to return sequential failures then `RATE_LIMIT_EXCEEDED`
- Mocks `useSignOut()` hook to verify sign-out flow is triggered on rate limit
- Uses `@testing-library/user-event` for PIN entry simulation

**Hook tests** (`use-idle-detection.test.ts`):
- Timer fires `onIdle` after timeout
- Activity events (`mousemove`, `keydown`, `pointerdown`) reset timer
- Cleanup removes listeners on unmount
- `enabled: false` prevents timer
- Throttled activity handler doesn't reset timer more often than throttleMs

**Store tests** (`lock-store.test.ts`):
- `lock('manual')` sets `isLocked: true`, `lockReason: 'manual'`, `lockedAt` is set
- `lock('idle')` sets `isLocked: true`, `lockReason: 'idle'`, `lockedAt` is set
- `unlock()` resets to `isLocked: false`, `lockReason: null`, `lockedAt: null`
- Initial state is unlocked
- Store is pure state: `lock()` and `unlock()` do NOT call `emitTelemetry` or any external function (verify no side-effect imports)

**Acceptance Criteria:**
- [ ] All PIN action tests pass (set, verify, rate-limit, denylist, format validation, missing-session-vars rejection)
- [ ] LockScreen component tests cover render, PIN flow, sign-out escape
- [ ] Integration smoke test: lock → 5 wrong PINs → UI-initiated sign-out triggered
- [ ] useIdleDetection tests cover timer, reset, cleanup, throttle, enabled flag
- [ ] useLockStore tests cover all state transitions including lockedAt
- [ ] Telemetry emission verified in action tests
- [ ] `npm test` passes all new tests

---

## Definition of Done

### Phase 1: Sign-Out (WS1 + WS2 + WS3)

- [ ] Server action `signOutAction` emits structured telemetry events (does NOT clear claims)
- [ ] `NavUser` displays real user data from `useAuth()` (email, role)
- [ ] `NavUser` menu has "Lock screen" (stubbed) and "Sign out" (functional)
- [ ] `NavUser` "Sign out" triggers full flow with failure semantics: server action (soft) → client signOut (hard) → cache clear → redirect
- [ ] `LogoutButton` shares `useSignOut()` hook
- [ ] `app_metadata` claims are untouched by sign-out (stable identity — see Claims Model)
- [ ] All Phase 1 tests pass
- [ ] `npm run type-check && npm run lint && npm test` all pass

### Phase 2: Lock Screen (WS4 + WS5 + WS6 + WS7)

- [ ] Migration adds `pin_hash` to `staff` table
- [ ] Migration adds `staff_pin_attempts` table with ADR-024 compliant RPCs (`rpc_increment_pin_attempt`, `rpc_clear_pin_attempts` — no spoofable params, REVOKE/GRANT, lazy cleanup)
- [ ] `staff_pin_attempts` has RLS enabled with no policies (deny-all direct access) + `REVOKE ALL FROM authenticated/anon`
- [ ] Migration adds `staff_update_own_pin` RLS policy (Template 2b, ADR-030 D4) + column-level privilege hardening (pin_hash only)
- [ ] `npm run db:types` regenerates types with `pin_hash`
- [ ] PIN set/verify/status server actions use **authed+RLS** (not service-role)
- [ ] `getPinStatusAction()` returns `{ hasPin: boolean }` without exposing `pin_hash` value
- [ ] PIN denylist rejects common weak PINs
- [ ] PIN rate limiting is DB-backed (survives serverless restarts)
- [ ] Successful verify clears attempts via `rpc_clear_pin_attempts()` (not raw DELETE)
- [ ] Lock screen overlay is full viewport, non-dismissible, z-index from `Z.LOCK_SCREEN` constant (above all UI except toaster)
- [ ] `lib/constants/z-index.ts` defines z-index scale via `Z` object (`Z.LOCK_SCREEN`, `Z.MODAL`, `Z.TOASTER`)
- [ ] Lock screen rendered in `app/(dashboard)/layout.tsx` as last child
- [ ] Lock screen calls `getPinStatusAction()` to determine setup vs verify mode (no empty-string hacks)
- [ ] `useIdleDetection` triggers lock after configurable timeout with throttled activity handler
- [ ] Zustand `useLockStore` is pure state (no telemetry, no side effects) with `lockedAt` and devtools
- [ ] Lock/unlock telemetry emitted from component layer (not store) using `useAuth()` for identity
- [ ] NavUser "Lock screen" item is enabled and triggers overlay
- [ ] "Not you? Sign out" escape hatch on lock screen triggers full sign-out
- [ ] Rate-limit exceeded on PIN attempts triggers UI-initiated sign-out (client-side cleanup, not server revocation)
- [ ] `cleanupClientInstance()` covered by unit test (verifies fresh client instance after call)
- [ ] Missing-session-vars test uses deterministic strategy (mock `injectRLSContext` to skip context, verify RLS rejection)
- [ ] Integration smoke test validates lock → 5 wrong PINs → UI-initiated sign-out
- [ ] `verifyPinAction` success path must call `rpc_clear_pin_attempts()` (test asserts invocation)
- [ ] LockScreen setup/verify mode must be based on `getPinStatusAction()` (test asserts behavior)
- [ ] `lock-store.ts` must not import auth hooks or telemetry modules (lint/test guard)
- [ ] LockScreen z-index must reference `Z.LOCK_SCREEN` (test or static assertion)
- [ ] All Phase 2 tests pass
- [ ] `npm run type-check && npm run lint && npm test && npm run build` all pass
