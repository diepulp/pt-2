---
# EXECUTION-SPEC Frontmatter
# Generated by prd-pipeline (lead-architect + rls-expert + backend-service-builder)

prd: AUTH-HARDENING-V01
prd_title: "Auth/RLS Reliability Hardening (Multi-Tenant SaaS Baseline)"
service: CrossCutting
mvp_phase: 0  # Horizontal / cross-cutting

workstreams:
  WS1:
    name: RPC Return Type Migration
    description: "Alter set_rls_context_from_staff() from RETURNS VOID to RETURNS TABLE so middleware can consume the authoritative context"
    executor: rls-expert
    executor_type: skill
    depends_on: []
    outputs:
      - supabase/migrations/20260130012200_auth_hardening_rpc_return_context.sql
    gate: schema-validation
    estimated_complexity: low

  WS2:
    name: Middleware Single-Source-of-Truth
    description: "Update injectRLSContext() to return RLSContext; withRLS overwrites ctx.rlsContext from RPC return; add structured logging"
    executor: backend-service-builder
    executor_type: skill
    depends_on: [WS1]
    outputs:
      - lib/supabase/rls-context.ts
      - lib/server-actions/middleware/rls.ts
      - lib/server-actions/middleware/__tests__/rls.test.ts
    gate: type-check
    estimated_complexity: medium

  WS3:
    name: Claims Lifecycle Hardening
    description: "Remove silent try/catch around syncUserRLSClaims; add clearUserRLSClaims on deactivation; add structured logging"
    executor: backend-service-builder
    executor_type: skill
    depends_on: [WS2]
    outputs:
      - lib/supabase/auth-admin.ts
      - lib/supabase/claims-reconcile.ts
      - lib/supabase/__tests__/claims-lifecycle.test.ts
      - lib/server-actions/middleware/__tests__/auth-chain-entrypoints.test.ts
    gate: type-check
    estimated_complexity: medium

  WS4:
    name: Bypass Lockdown and CI Guard
    description: "Require ENABLE_DEV_AUTH=true for dev bypass; add skipAuth telemetry; CI test for skipAuth in non-test files"
    executor: backend-service-builder
    executor_type: skill
    depends_on: [WS3]
    outputs:
      - lib/supabase/dev-context.ts
      - lib/supabase/service.ts
      - lib/server-actions/middleware/compositor.ts
      - lib/supabase/__tests__/bypass-lockdown.test.ts
      - .env.local.example
    gate: type-check
    estimated_complexity: medium

  WS5:
    name: Write RLS Policy Tightening
    description: "Remove JWT COALESCE fallback from INSERT/UPDATE/DELETE policies; require SET LOCAL session vars for all writes"
    executor: rls-expert
    executor_type: skill
    depends_on: [WS4]
    outputs:
      - supabase/migrations/20260130012300_auth_hardening_write_rls_tightening.sql
    gate: schema-validation
    estimated_complexity: high

  WS6:
    name: JWT Fallback Observability
    description: "Add app-layer structured logging when JWT fallback would be exercised in SELECT path"
    executor: backend-service-builder
    executor_type: skill
    depends_on: [WS4]
    outputs:
      - lib/supabase/rls-context.ts
      - lib/server-actions/middleware/rls.ts
    gate: type-check
    estimated_complexity: low

execution_phases:
  - name: "Phase 1 - TOCTOU Removal (PR-1)"
    parallel: [WS1]
    gates: [schema-validation]

  - name: "Phase 1b - Middleware Update (PR-1 cont.)"
    parallel: [WS2]
    gates: [type-check]

  - name: "Phase 2 - Claims Lifecycle (PR-2)"
    parallel: [WS3]
    gates: [type-check, test-pass]

  - name: "Phase 3 - Bypass Lockdown (PR-3)"
    parallel: [WS4]
    gates: [type-check, lint, test-pass]

  - name: "Phase 4 - Write Tightening + Observability (PR-4)"
    parallel: [WS5, WS6]
    gates: [schema-validation, type-check, test-pass]

gates:
  schema-validation:
    command: "npm run db:types"
    success_criteria: "Exit code 0, types regenerated"

  type-check:
    command: "npm run type-check"
    success_criteria: "Exit code 0, no type errors"

  lint:
    command: "npm run lint"
    success_criteria: "Exit code 0"

  test-pass:
    command: "npm test"
    success_criteria: "All tests pass"

risks:
  - risk: "PostgreSQL does not allow CREATE OR REPLACE to change return type"
    mitigation: "WS1 migration uses DROP FUNCTION + CREATE FUNCTION (safe — no dependents on void return)"

  - risk: "ENABLE_DEV_AUTH breaks developer workflow"
    mitigation: "WS4 updates .env.local.example; clear error at boot explains the requirement"

  - risk: "Write policy tightening blocks writes if middleware skipped"
    mitigation: "Phases 1-3 ensure middleware always runs; this is the intended enforcement"

  - risk: "Claims sync error propagation could fail staff mutations"
    mitigation: "WS3 logs errors but lets sync failure propagate — this surfaces latent issues that were previously hidden"

---

# EXECUTION-SPEC: AUTH-HARDENING v0.1 — Auth/RLS Reliability Hardening

## Overview

PT-2 uses the correct security spine: Postgres RLS is the enforcement boundary, requests run through `withAuth -> withRLS -> set_rls_context_from_staff()`. The problem is **reliability**: fallback/bypass paths cause tenant isolation to silently depend on stale JWT metadata or service-role execution. This spec converts auth correctness from **best-effort** to **enforced** without expanding the domain model.

**Primary Sources:**
- `docs/00-vision/auth-hardening/AUTH-HARDENING-v0.1-EXECUTION-PATCH.md`
- `docs/00-vision/auth-hardening/PT-2_AUTH_SYSTEM_HARDENING_REPORT.md`

## Scope

- **In Scope**: TOCTOU elimination, claims lifecycle hardening, bypass lockdown, write policy tightening
- **Out of Scope**: company_id RLS, replacing Supabase Auth, role hierarchy changes, material schema changes

## Architecture Context

- **ADR-024**: Authoritative context derivation (frozen) — `set_rls_context_from_staff()` is the single source
- **ADR-015**: Connection pooling strategy — Pattern C hybrid with JWT fallback (reads keep fallback; writes lose it)
- **ADR-018**: SECURITY DEFINER governance
- **ADR-020**: Track A hybrid for MVP

---

## Workstream Details

### WS1: RPC Return Type Migration

**Purpose**: Eliminate TOCTOU drift by making the RPC return the context it derives.

**Deliverables**:
1. Migration: `20260130012200_auth_hardening_rpc_return_context.sql`
   - Drop ALL known overloads defensively (PG cannot ALTER return type):
     ```sql
     DROP FUNCTION IF EXISTS public.set_rls_context_from_staff();     -- no-arg (guard against drift)
     DROP FUNCTION IF EXISTS public.set_rls_context_from_staff(text); -- actual current signature
     ```
     - **Signature audit**: migration `20251229152317` declares `(p_correlation_id text DEFAULT NULL)` → PG signature is `(text)`. Only one overload exists today. The `()` DROP is a safety net — if the signature was ever iterated locally, this prevents a stale ghost function from remaining.
   - `CREATE FUNCTION ... RETURNS TABLE (actor_id uuid, casino_id uuid, staff_role text)`
   - Body identical to current except: assigns output columns + `RETURN NEXT` after SET LOCAL block
   - Preserves: SECURITY DEFINER, `SET search_path = pg_catalog, public`, grants (authenticated EXECUTE, PUBLIC REVOKED)
   - Preserves: All security invariants (INV-3, INV-5, INV-6)

**SQL (key change at end of function body)**:
```sql
-- After existing SET LOCAL block, add:
  actor_id := v_staff_id;
  casino_id := v_casino_id;
  staff_role := v_role;
  RETURN NEXT;
```

**Acceptance Criteria**:
- [ ] `npm run db:types` succeeds with new return type
- [ ] RPC returns `{actor_id, casino_id, staff_role}` for authenticated active staff
- [ ] RPC raises `UNAUTHORIZED` for unknown staff identity
- [ ] RPC raises `FORBIDDEN` for inactive/unscoped staff
- [ ] Existing callers that ignore return are unaffected

---

### WS2: Middleware Single-Source-of-Truth

**Purpose**: Make `ctx.rlsContext` come exclusively from the RPC return, not from a separate `getAuthContext()` lookup.

**Deliverables**:
1. `lib/supabase/rls-context.ts` — Change `injectRLSContext()`:
   - Return type: `Promise<void>` -> `Promise<RLSContext>`
   - Parse RPC response (first row of returned TABLE) into `RLSContext`
   - Remove deprecated `_context` parameter
   - Add structured logging: `[RLS] context set: actor={actorId} casino={casinoId} role={staffRole}`
     - **Log level**: `info` for success, `error` for failure
     - **Redaction**: UUIDs are internal server-side identifiers (not PII); safe for server logs. Do NOT log to client-visible responses or Next.js RSC payloads.
     - **Destination**: server-side only (Next.js `console` in server context writes to stdout, not client)
   - Add structured error logging on RPC failure

2. `lib/server-actions/middleware/rls.ts` — Change `withRLS()`:
   - Capture return: `const rpcContext = await injectRLSContext(ctx.supabase, ctx.correlationId)`
   - Overwrite: `ctx.rlsContext = rpcContext`
   - This makes the RPC the **single source of truth** for downstream handlers

3. `lib/server-actions/middleware/__tests__/rls.test.ts` — Update tests:
   - Verify `ctx.rlsContext` matches RPC output exactly
   - Verify RPC rejection (UNAUTHORIZED/FORBIDDEN) prevents handler execution
   - Verify `ctx.rlsContext` is never from client payload

**Patterns**: ADR-024 (authoritative context), no `console.*` (use structured logging)

**Acceptance Criteria**:
- [ ] `injectRLSContext()` returns `RLSContext` parsed from RPC response
- [ ] `withRLS` overwrites `ctx.rlsContext` with RPC-derived context
- [ ] `getAuthContext()` only used for early-reject in `withAuth` (pre-RPC validation)
- [ ] RPC success/failure logged with correlation context
- [ ] `npm run type-check` passes

---

### WS3: Claims Lifecycle Hardening

**Purpose**: Make JWT claims sync/clear deterministic — failures surface instead of being silently swallowed.

**Deliverables**:
1. `services/casino/crud.ts` — `createStaff()`:
   - Remove silent `catch` block (line ~361)
   - Replace with: let `syncUserRLSClaims` throw propagate to caller
   - Add structured error log before propagation

2. `services/casino/crud.ts` — `updateStaff()`:
   - Remove silent `catch` block (line ~449) for sync
   - Add: detect `status` change to `'inactive'` -> call `clearUserRLSClaims(currentRow.user_id)`
   - Add: detect `user_id` removal (input sets it to null) -> call `clearUserRLSClaims(currentRow.user_id)`
   - Add: detect `casino_id` change -> call `clearUserRLSClaims(currentRow.user_id)` before re-sync to avoid stale bindings
   - Log claim clearing events

3. `lib/supabase/claims-reconcile.ts` — `reconcileStaffClaims()` helper:
   - New shared function (cross-cutting; placed in `lib/supabase/` alongside `auth-admin.ts`, not in `services/casino/` to avoid bounded context ambiguity)
   - Invoked by `createStaff()` and `updateStaff()` — encapsulates sync + conditional clear logic
   - Emits structured logs for each action and bubbles failures

4. `lib/supabase/auth-admin.ts`:
   - Add structured logging to `syncUserRLSClaims()`: success log with userId + claims summary
   - Add structured logging to `clearUserRLSClaims()`: success log with userId
   - Failure logging already exists (the functions throw)

5. `lib/supabase/__tests__/claims-lifecycle.test.ts` — New test file:
   - Staff create triggers claim sync exactly once
   - Staff deactivation triggers claim clearing
   - Staff user_id removal triggers claim clearing
   - Staff casino_id change triggers claim clearing before re-sync
   - Sync/clear failures are surfaced (not silently ignored)

6. `lib/server-actions/middleware/__tests__/auth-chain-entrypoints.test.ts` — New regression test:
   - **Enforcement method: static grep gate** (chosen over runtime instrumentation for simplicity and CI speed)
   - Glob `app/**/*.ts` for files exporting server actions (files containing `'use server'`) and route handlers (`export async function GET/POST/PUT/DELETE/PATCH`)
   - Assert each matches at least one of:
     - Calls `withServerAction(` or `withAuth(` (compositor wrapper)
     - Is explicitly allowlisted in `AUTH_CHAIN_ALLOWLIST` (for edge cases like health checks)
   - Fails if new entrypoints skip the middleware chain
   - The allowlist must be reviewed in PR review to prevent silent bypass accumulation

**Patterns**: ADR-012 (error handling layers), structured logging (no `console.*`)

**Acceptance Criteria**:
- [ ] No silent `catch` blocks around claim sync/clear in production code
- [ ] Staff deactivation calls `clearUserRLSClaims()`
- [ ] Staff user_id removal calls `clearUserRLSClaims()`
- [ ] Staff casino_id change calls `clearUserRLSClaims()` prior to sync
- [ ] Claim sync/clear success and failure events are logged
- [ ] Tests verify lifecycle correctness and the shared `reconcileStaffClaims()` helper is used consistently
- [ ] Auth chain regression test covers every production entrypoint (server actions + route handlers)

---

### WS4: Bypass Lockdown and CI Guard

**Purpose**: Prevent `DEV_AUTH_BYPASS` from slipping into production; restrict `skipAuth` to test helpers.

**Deliverables**:
1. `lib/supabase/dev-context.ts` — `isDevAuthBypassEnabled()`:
   - Change: require `process.env.ENABLE_DEV_AUTH === 'true'` (explicit opt-in)
   - Combined gate: `NODE_ENV === 'development' && ENABLE_DEV_AUTH === 'true'`
   - Without both: throw a startup error when `DEV_AUTH_BYPASS` or dev service client toggles are enabled; expose helper `assertDevAuthBypassAllowed()` used during boot

2. `lib/supabase/service.ts` — `shouldUseDevServiceClient()`:
   - Same dual-gate: `isDevMode() && process.env.ENABLE_DEV_AUTH === 'true'`
   - Call `assertDevAuthBypassAllowed()` and emit structured log `[AUTH BYPASS ENABLED]` with environment + operator ID when bypass becomes active

3. `lib/server-actions/middleware/compositor.ts`:
   - When `skipAuth` is true: log error-level structured event before skipping auth chain
   - `[AUTH WARNING] skipAuth=true used — auth chain bypassed (endpoint={endpoint})`
   - Log includes correlation ID and file origin to aid CI enforcement

4. `lib/supabase/__tests__/bypass-lockdown.test.ts` — New test file:
   - CI test: scan non-test source files for `skipAuth: true`; fail if found outside `__tests__/`, `test-utils/`, `seed`
   - Unit test: `isDevAuthBypassEnabled()` returns false without `ENABLE_DEV_AUTH=true`
   - Unit test: `isDevAuthBypassEnabled()` throws when bypass requested outside allowed envs
   - Unit test: enabling bypass emits `[AUTH BYPASS ENABLED]` log exactly once

5. `app/(admin)/layout.tsx` bootstrap hook (or equivalent server entrypoint):
   - Calls `assertDevAuthBypassAllowed()` during startup so production deploys fail fast if bypass env vars leak

6. `.env.local.example` — Add:
   ```
   # Required for dev auth bypass (AUTH-HARDENING v0.1)
   # Set to 'true' to enable DEV_AUTH_BYPASS in development mode
   ENABLE_DEV_AUTH=true
   ```

**Acceptance Criteria**:
- [ ] Dev bypass requires explicit `ENABLE_DEV_AUTH=true`
- [ ] Production runtime cannot enable bypass regardless of env vars (boot throws)
- [ ] `skipAuth` usage outside test files fails CI test
- [ ] Error-level log emitted whenever `skipAuth` is exercised and whenever DEV_AUTH_BYPASS toggles on
- [ ] `npm run type-check && npm run lint` pass

---

### WS5: Write RLS Policy Tightening

**Purpose**: Writes require session vars — JWT fallback removed for INSERT/UPDATE/DELETE.

**Deliverables**:
1. Migration: `20260130012300_auth_hardening_write_rls_tightening.sql`

**Tables affected (write policies only — SELECT policies UNCHANGED)**:

> **Schema verification**: All table names verified against `types/database.types.ts` and `information_schema`-equivalent (generated types). Run `npm run db:types` as preflight gate before writing migration. Only tables with a `casino_id` column are included — tables without it use different enforcement patterns.

| Table | has `casino_id` | Policies Tightened | Role Gate |
|-------|:-:|-------------------|-----------|
| `visit` | YES | INSERT, UPDATE | `pit_boss, admin` |
| `player_casino` | YES | INSERT, UPDATE | `pit_boss, admin` / `admin` |
| `rating_slip` | YES | INSERT, UPDATE | `pit_boss, admin` |
| `rating_slip_pause` | YES | INSERT, UPDATE | (any authenticated — casino scope only) |
| `gaming_table` | YES | INSERT, UPDATE | `pit_boss, admin` |
| `dealer_rotation` | YES | INSERT, UPDATE | `pit_boss, admin` |
| `player_financial_transaction` | YES | INSERT | `cashier, admin` |
| `loyalty_ledger` | YES | INSERT | `pit_boss, cashier, admin` |
| `player_loyalty` | YES | INSERT, UPDATE, DELETE | varies per operation |
| `staff` | YES | INSERT, UPDATE | `admin` |

> **Excluded**: `player` — does NOT have a `casino_id` column. The `player` table is globally scoped; casino access is controlled through `player_casino` enrollment. Its write policies (`player_insert_admin`, `player_update_enrolled`) use the `player_casino` join for casino scoping and cannot use the standard `casino_id = current_setting(...)` pattern. Tightening `player` write policies requires a different approach (deferred to v0.2).

**Pattern change (writes only)**:
```sql
-- OLD (hybrid):
casino_id = COALESCE(
  NULLIF(current_setting('app.casino_id', true), '')::uuid,
  (auth.jwt() -> 'app_metadata' ->> 'casino_id')::uuid
)

-- NEW (session-vars required):
-- Universal: casino_id column matched to session var (every casino-scoped table has this column)
-- Universal: actor_id session var must be present (presence check only — NOT a column comparison)
-- Per-table: staff_role gate preserved from existing policy
NULLIF(current_setting('app.casino_id', true), '') IS NOT NULL
AND NULLIF(current_setting('app.actor_id', true), '') IS NOT NULL
AND casino_id = current_setting('app.casino_id', true)::uuid
-- NOTE: actor_id is checked for presence only. It is a session variable, NOT a table column.
-- Only compare row columns (casino_id, created_by, etc.) to session vars.
```

**Acceptance Criteria**:
- [ ] Writes without context RPC fail (even if JWT metadata exists)
- [ ] Writes with context RPC succeed
- [ ] SELECT still works with JWT fallback (no regression)
- [ ] All existing role gates preserved per table
- [ ] Denial policies (`no_updates`, `no_deletes`) untouched

---

### WS6: JWT Fallback Observability

**Purpose**: Make JWT fallback reliance visible — RPC failure in production is **fatal** (not a tolerable fallback). Observability is for bypass/test mode and defensive monitoring only.

**Design principle**: After WS2, if the RPC fails the request hard-fails. There is no "fallback to JWT" in the production path. WS6 adds observability for two remaining scenarios:
1. **Bypass mode** (dev/test only): when `DEV_AUTH_BYPASS` or `skipAuth` is active, no RPC runs — SELECT policies fall back to JWT. This is the only path where JWT fallback is exercised, and it MUST be logged.
2. **Defensive monitoring**: if a code regression causes the middleware chain to be skipped, write policies (WS5) will hard-fail; SELECT policies will silently use JWT. A canary assertion in the middleware detects this case.

**Deliverables**:
1. `lib/supabase/rls-context.ts` or `lib/server-actions/middleware/rls.ts`:
   - After RPC call in `injectRLSContext()`: if RPC fails, the request **hard-fails** (no fallback logging — the error propagates)
   - Add canary assertion: if a DB query executes without prior RPC context set (detectable via a request-scoped flag), emit `[RLS CANARY] DB query executed without RPC context — JWT fallback in effect`
   - This is a defensive signal for middleware regressions, not a normal operating path

2. `lib/supabase/dev-context.ts` and `lib/server-actions/middleware/compositor.ts`:
   - Whenever DEV_AUTH_BYPASS or `skipAuth` toggles are exercised, emit structured `[AUTH BYPASS] bypass-mode active — SELECT queries rely on JWT metadata (endpoint={endpoint}, correlationId={id})`
   - This is the ONLY expected path where JWT fallback fires; label it explicitly as bypass-mode

**Acceptance Criteria**:
- [ ] RPC failure in production paths is fatal (request fails, no "fallback" logging)
- [ ] Bypass-mode usage emits structured `[AUTH BYPASS]` log with endpoint + correlation context
- [ ] Canary assertion detects missing RPC context before DB queries (defensive, not normal path)
- [ ] No new `console.*` calls (use structured logging pattern)

---

## Definition of Done

From AUTH-HARDENING-v0.1-EXECUTION-PATCH.md §3:

- [ ] `set_rls_context_from_staff()` returns `{actor_id, casino_id, staff_role}` and middleware uses ONLY this to populate `ctx.rlsContext` (WS1 + WS2)
- [ ] Claim sync/clear calls are NOT silently ignored; failures surface and are logged (WS3)
- [ ] `DEV_AUTH_BYPASS` requires `NODE_ENV=development AND ENABLE_DEV_AUTH=true`; otherwise hard fail (WS4)
- [ ] `skipAuth: true` restricted to test helpers; CI test fails if found in production files (WS4)
- [ ] Telemetry/logging for: RPC context success/failure, JWT-branch reliance, claim sync failures, DEV_AUTH_BYPASS/`skipAuth` usage (WS2 + WS3 + WS4 + WS6)
- [ ] Writes cannot succeed without `app.*` session context (WS5)
- [ ] Every production entrypoint is covered by auth-chain regression tests
- [ ] All gates pass: `npm run db:types && npm run type-check && npm run lint && npm run test`
